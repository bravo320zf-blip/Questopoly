<!DOCTYPE html>
<html lang="en">
<!-- 
================================================================
   QUESTOPOLY: LEGENDS - POLISHED UI EDITION
   UI Overhaul: Glass & Gold Theme
   Logic: Original (Preserved)
================================================================
-->

<!--
How to Manage "Premium" Users (Manual Verification)
Because you do not have a backend server listening for automatic receipts (Webhooks), the process for a user getting their ads removed will be:
1. Player clicks "$3.00" inside the game.
2. Player is taken to PayPal in a new tab and pays you.
3. You (The Admin) get an email from PayPal saying "You received $3.00 from [Player Email]".
4. You go to your Firebase Console:
     -Go to Authentication to find the user's UID based on their email.
     -Go to Realtime Database.
     -Navigate to users > [THE USER'S UID].
     -Add a new field: isPremium and set the value to true (boolean).
5. Player clicks the "â†» Restore Purchase / Check Status" button inside the game store.
6. The game checks Firebase, sees isPremium: true, and removes the ads instantly.
(Note: In the future, you can automate step 4 using Firebase Cloud Functions, but doing it manually is perfectly fine for starting out!)
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Questopoly: Legends</title>
    
    <!-- LIBRARIES -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
	<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
	<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
	<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

<style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Lato:wght@400;700&display=swap');

    :root {
        --bg-dark: #020617;
        --glass-bg: rgba(15, 23, 42, 0.85);
        --glass-border: rgba(255, 255, 255, 0.1);
        --gold-main: #f59e0b;
        --gold-glow: #fbbf24;
        --gold-dim: #78350f;
        --accent-red: #ef4444;
        --accent-green: #10b981;
        --accent-blue: #3b82f6;
        --accent-purple: #a855f7;
        --font-head: 'Cinzel', serif;
        --font-body: 'Lato', sans-serif;
        --radius-main: 12px;
    }

    /* --- 1. GLOBAL RESETS --- */
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; user-select: none; }
    html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; color: #e2e8f0; font-family: var(--font-body); position: fixed; touch-action: none; }
    h1, h2, h3, button, .modal-title { font-family: var(--font-head); text-transform: uppercase; }

    /* --- 2. GAME LAYOUT LAYERS --- */
    #game-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
    
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 100; pointer-events: none; 
        overflow: hidden; 
    }

    /* --- NEW LAYOUT CONTAINERS --- */
    body {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        overflow: hidden;
    }

    /* This holds the 3D Game and the UI Layer */
    #game-viewport-wrapper {
        position: relative;
        width: 100%;
        flex: 1; /* Takes up all remaining space */
        overflow: hidden;
        order: 1; /* Visual order: Top */
    }

    /* This is the Wood Bar at the bottom */
    #ad-container {
        position: relative;
        width: 100%;
        height: 12%; /* Adjust this % to control bar size */
        min-height: 90px; /* Ensure space for standard ads */
        background-color: #3e2723; /* Fallback brown */
        /* Wood Texture Pattern */
        background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png'); 
        border-top: 4px solid var(--gold-main);
        box-shadow: 0 -5px 20px rgba(0,0,0,0.8);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        order: 2; /* Visual order: Bottom */
        pointer-events: auto;
    }

    /* Hide ads if user is premium */
    body.premium-user #ad-container {
        display: none !important;
    }

    /* Ensure absolute items position relative to the wrapper, not body */
    #game-layer, #ui-layer, #splash-screen, #create-screen, #lobby-screen, #gameroom-screen {
        position: absolute;
        width: 100%;
        height: 100%;
    }

    /* DESKTOP DEFAULT: Centered Square Aspect Ratio */
    #board-anchor {
        position: absolute; top: 50%; left: 50%; 
        transform: translate(-50%, -50%);
        height: 96vh; width: 96vh; 
        max-width: 96vw; max-height: 96vw; 
        pointer-events: none;
    }

    #inner-zone {
        position: absolute; top: 14.5%; left: 14.5%;
        width: 71%; height: 77%;
        pointer-events: none;
    }

    /* --- 3. SHARED UI COMPONENTS --- */
    .glass-panel { 
        background: var(--glass-bg); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); 
        border: 1px solid var(--glass-border); border-radius: var(--radius-main); 
        box-shadow: 0 4px 20px rgba(0,0,0,0.5); color: #fff; 
        display: flex; flex-direction: column; overflow: hidden; pointer-events: auto;
    }
    
    .gold-border { border: 1px solid var(--gold-dim); box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 0 10px rgba(0,0,0,0.5); }
    
    button { pointer-events: auto; }
    
    .choice-btn { 
        background: linear-gradient(to right, #2d3748, #1a202c); 
        border: 1px solid #4a5568; padding: 15px; margin-bottom: 8px; 
        text-align: left; cursor: pointer; border-radius: 8px; 
        display: flex; justify-content: space-between; align-items: center; 
        pointer-events: auto;
    }
    .choice-btn:hover { border-color: var(--gold-main); transform: translateX(5px); background: #2d3748; }

    .close-x { 
        position: absolute; top: 10px; right: 10px; 
        width: 30px; height: 30px; 
        background: var(--accent-red); color: white; border: 2px solid #fff; border-radius: 50%; 
        font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 50;
        box-shadow: 0 2px 5px rgba(0,0,0,0.5); pointer-events: auto;
    }

    /* --- 4. HUD WIDGETS (Relative to Container) --- */
    
    #turn-widget {
        position: absolute; top: -8%; left: 50%; transform: translate(-50%, 0);
        width: 60%; padding-top: 1vmin;
        background: linear-gradient(90deg, transparent, rgba(0,0,0,0.9), transparent); 
        text-align: center; z-index: 150; pointer-events: auto;
    }
    #turn-banner { font-size: 4.5vmin; color: #fff; text-shadow: 0 0 10px var(--gold-glow); margin: 0; white-space: nowrap; }
    #day-night-indicator { font-size: 2.5vmin; color: var(--accent-blue); padding: 0.5vmin 2vmin; background: rgba(0,0,0,0.5); border-radius: 10px; display: inline-block; border: 1px solid #333; margin-top: 0.5vmin; }

    #treasury-widget {
        position: absolute; top: -5%; left: -5%;
        background: radial-gradient(circle, #451a03 0%, #000 100%);
        border: 2px solid var(--gold-main); border-radius: 15px; padding: 1vmin 2vmin; 
        box-shadow: 2px 2px 10px rgba(0,0,0,0.8);
        display: flex; flex-direction: column; align-items: center; 
        z-index: 150; min-width: 12vmin; pointer-events: auto;
    }
    .treasury-icon { font-size: 3.5vmin; margin-bottom: 0; line-height: 1; }
    .treasury-amount { font-family: var(--font-head); font-size: 3vmin; color: var(--gold-glow); font-weight: 900; text-shadow: 0 0 5px var(--gold-main); }
    .treasury-label { font-size: 1.5vmin; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }

    #mystats-widget {
        position: absolute; top: -5%; right: -5%;
        background: radial-gradient(circle, #0f172a 0%, #000 100%);
        border: 2px solid var(--gold-main); border-radius: 0 0 0 15px;
        padding: 10px 20px; box-shadow: -2px 2px 10px rgba(0,0,0,0.8);
        display: flex; flex-direction: column; align-items: flex-end; 
        z-index: 150; pointer-events: auto;
    }
    .stat-row { display: flex; align-items: center; gap: 8px; margin-bottom: 2px; }
    .ms-icon { font-size: 1.8vh; }

    #adventure-log-widget {
        position: absolute; top: 8%; left: 50%; transform: translateX(-50%);
        height: 20%; width: 60%;
        background: rgba(15, 23, 42, 0.6); border: 1px solid var(--glass-border); 
        border-radius: 10px; padding: 5px 10px;
        display: flex; flex-direction: column; overflow: hidden; pointer-events: auto;
    }
    #game-log {
        width: 100%; height: 100%; overflow-y: auto; display: flex; flex-direction: column;
        mask-image: linear-gradient(to bottom, transparent, black 15%); 
        -webkit-mask-image: linear-gradient(to bottom, transparent, black 15%);
    }
    .log-entry { font-size: 1.4vh; padding: 2px 0; text-shadow: 1px 1px 2px #000; border-bottom: 1px solid rgba(255,255,255,0.05); flex-shrink: 0; }

    /* --- 5. SKILL BAR & CONTROLS --- */
    #skill-bar-container {
        position: absolute; bottom: 8%; left: 50%; transform: translateX(-50%);
        width: 85%; height: 15%; 
        display: flex; justify-content: center; align-items: flex-end; 
        z-index: 3000; pointer-events: auto;
    }
    #skill-bar {
        background: linear-gradient(to top, #020617, rgba(2,6,23,0.95));
        border: 2px solid var(--gold-dim); border-radius: 15px;
        width: 100%; height: 100%;
        display: flex; gap: 2%; justify-content: space-between; align-items: center;
        padding: 0 2%; box-shadow: 0 0 30px rgba(0,0,0,0.9);
    }
    .skill-slot {
        flex: 1; height: 80%; background: #1e293b; border: 2px solid #475569; border-radius: 8px;
        position: relative; cursor: pointer; display: flex; flex-direction: column; justify-content: flex-end;
        background-size: cover; background-position: center; overflow: hidden; transition: transform 0.1s; box-shadow: inset 0 0 10px #000;
        pointer-events: auto;
    }
    .skill-slot:active { transform: scale(0.95); }
    .skill-slot span { font-size: 1.5vmin; padding: 2px; background: rgba(0,0,0,0.8); text-align: center; width: 100%; white-space:nowrap; overflow:hidden;}
    .skill-key { font-size: 1.5vmin; width: 2.5vmin; height: 2.5vmin; position: absolute; top: 2px; left: 2px; background: #000; color: #fff; display: flex; align-items: center; justify-content: center; border: 1px solid #666; border-radius: 4px; }
    .spacer-slot { width: 30%; height: 0; pointer-events: none; }

    #btn-action-container {
        position: absolute; left: 50%; bottom: 50%; transform: translate(-50%, 50%); 
        width: 25%; height: auto; aspect-ratio: 1; pointer-events: none;
        display: flex; justify-content: center; align-items: center; z-index: 3000;
    }
    #btn-action {
        width: 90%; height: 90%; border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, var(--gold-glow), var(--gold-main));
        border: 3px solid #fff; box-shadow: 0 0 30px var(--gold-glow), 0 10px 0 #451a03;
        color: #2a1a00; font-family: var(--font-head); font-weight: 900; font-size: 3vmin;
        cursor: pointer; display: flex; align-items: center; justify-content: center; text-align: center;
        pointer-events: auto;
    }
    #btn-action:active { box-shadow: inset 0 0 15px rgba(0,0,0,0.5); transform: scale(0.98); }
    #btn-action:disabled { filter: grayscale(1); cursor: not-allowed; background: #333; border-color:#555; box-shadow:none; color:#888;}
    #btn-action.state-end { background: radial-gradient(circle at 30% 30%, #ef4444, #991b1b); color: #fff; box-shadow: 0 0 30px #ef4444, 0 10px 0 #450a0a; }

    #utility-stack {
        position: absolute; bottom: 3%; right: -4%; width: 8%;
        display: flex; flex-direction: column-reverse; gap: 1vh; z-index: 500;
    }
    .util-btn {
        width: 100%; aspect-ratio: 1; border-radius: 50%;
        background: rgba(15, 23, 42, 0.9); border: 2px solid var(--gold-dim);
        color: var(--gold-main); font-size: 2.5vh;
        display: flex; align-items: center; justify-content: center;
        cursor: pointer; transition: 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); pointer-events: auto;
    }
    .util-btn:hover { background: var(--gold-main); color: #000; transform: scale(1.1); }

    /* --- 6. SIDEBARS (Desktop) --- */
    #p1-sheet { 
        position: absolute; top: 10%; left: 20px; width: 280px; height: 60%; 
        z-index: 20; transition: transform 0.3s ease; 
    }
    #leaderboard { 
        position: absolute; top: 10%; right: 20px; width: 240px; height: auto; max-height: 58%; 
        z-index: 20; transition: transform 0.3s ease; 
    }
    .char-header, .leader-header { padding: 10px; border-bottom: 1px solid var(--glass-border); display: flex; justify-content: space-between; align-items: center; cursor: move; }
    .char-portrait { width: 50px; height: 50px; border-radius: 50%; border: 2px solid var(--gold-main); background-color: #000; background-size: cover; margin-right: 10px; cursor: pointer; }
    .stat-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; padding: 10px; }
    .stat-box { background: rgba(0,0,0,0.3); padding: 5px; text-align: center; border-radius: 4px; }
    .stat-val { font-weight: bold; color: #fff; } .stat-lbl { font-size: 0.65rem; color: #aaa; }
    .paper-doll { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; padding: 0 10px 10px 10px; }
    .equip-slot { background: rgba(0,0,0,0.4); border: 1px dashed #444; color: #666; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; cursor: pointer; border-radius: 4px; transition: 0.2s; pointer-events: auto;}
    .equip-slot.filled { border: 1px solid var(--gold-dim); background: rgba(16, 185, 129, 0.2); color: #fff; text-shadow: 0 1px 2px #000; }
    .inv-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; padding: 10px; background: rgba(0,0,0,0.2); flex-grow: 1; align-content: flex-start; overflow-y: auto; pointer-events: auto; }
    .inv-slot { aspect-ratio: 1; background: #1e293b; border: 1px solid #333; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 0.6rem; cursor: pointer; pointer-events: auto; }
    .leader-row.boss { border: 1px solid #ef4444; background: linear-gradient(90deg, rgba(20,0,0,0.9), rgba(60,0,0,0.8)); }
    .leader-row.merchant { border: 1px solid #a855f7; background: linear-gradient(90deg, rgba(20,0,20,0.9), rgba(50,0,60,0.8)); }
    .boss-icon { font-size: 1.2rem; margin-right: 5px; }
    .panel-close-btn { margin: 10px auto; display: block; background: rgba(127, 29, 29, 0.8); border: 1px solid #ef4444; color: #fff; padding: 8px 20px; border-radius: 4px; cursor: pointer; width: 80%; }

    /* --- 7. GENERIC MODALS --- */
.modal-overlay { 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    background: rgba(0, 0, 0, 0.85); 
    
    /* NEW: Higher than Ad Bar (9999) and HUD (10000) */
    z-index: 20000 !important; 
    
    display: none; 
    align-items: center; 
    justify-content: center; 
    flex-direction: column; 
    pointer-events: auto;
}
    .modal-overlay.active { display: flex; }

    .modal-content { 
        background: #1a1a1a; border: 2px solid var(--gold-dim); border-radius: 16px; 
        box-shadow: 0 0 50px rgba(0,0,0,1); max-width: 600px; width: 95%; max-height: 90vh;
        overflow: hidden; display: flex; flex-direction: column; 
        transform: scale(0.95); transition: transform 0.2s; pointer-events: auto; 
    }
    .modal-overlay.active .modal-content { transform: scale(1); }

    /* Help Modal */
    #help-modal { z-index: 2000; }
    .help-window { background: #111; border: 2px solid #f59e0b; }
    .help-header-title { background: #f59e0b; color: #fff; font-weight: 900; text-align: center; padding: 10px; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
    .help-tabs { display: flex; background: #222; border-bottom: 2px solid #444; overflow-x: auto; }
    .help-tab { flex: 1; background: transparent; border: none; color: #888; padding: 15px 5px; font-weight: bold; cursor: pointer; border-bottom: 4px solid transparent; }
    .help-tab.active { color: #f59e0b; border-bottom-color: #f59e0b; background: rgba(251, 191, 36, 0.1); }
    .help-section { display: none; padding: 20px; overflow-y: auto; text-align: left; color: #ccc; line-height: 1.5; }
    .help-section.active { display: block; }

    /* --- 8. ENCOUNTER/SKIRMISH CARD STYLES --- */
    #arrival-modal, #card-modal {
        position: fixed !important; top: 50% !important; left: 50% !important;
        transform: translate(-50%, -50%) scale(0.9) !important;
        opacity: 0 !important; pointer-events: none !important; z-index: -1 !important;
        display: flex !important; flex-direction: column !important;
        max-height: 90vh !important; max-width: 600px !important; width: 95% !important;
        margin: 0 !important; transition: opacity 0.2s ease, transform 0.2s ease !important;
        background: transparent !important; border: none !important; box-shadow: none !important;
    }
    #arrival-modal.active, #card-modal.active {
        opacity: 1 !important; pointer-events: auto !important; z-index: 2000 !important;
        transform: translate(-50%, -50%) scale(1) !important;
    }
    #card-modal .card-header, #card-modal .card-body {
        pointer-events: auto !important; background: #1a1a1a !important; width: 100%; box-shadow: 0 10px 40px #000; position: relative;
    }
    #card-modal .card-header {
        border: 2px solid var(--gold-dim); border-bottom: 2px solid #000; border-radius: 12px 12px 0 0;
        padding: 15px; text-align: center; color: #fff; font-size: 1.4rem; font-weight: 900; text-shadow: 0 2px 0 rgba(0,0,0,0.5);
    }
    #card-modal .card-body {
        border: 2px solid var(--gold-dim); border-top: none; border-radius: 0 0 12px 12px; padding: 20px; text-align: center;
    }
    .card-header.skirmish { background: #991b1b !important; } 
    .card-header.loot { background: #065f46 !important; } 
    .card-header.market { background: #713f12 !important; }
    .card-desc { font-style: italic; margin-bottom: 20px; color: #fff; }
    .dice-result { display: flex; gap: 10px; justify-content: center; margin-top: 15px; min-height: 40px; }
    .mini-die { width: 36px; height: 36px; background: #000; color: #fff; display: flex; align-items: center; justify-content: center; font-weight: bold; border-radius: 4px; border: 1px solid #444; }
    .mini-die.win { background: var(--accent-green); border-color: #fff; } 
    .mini-die.lose { background: var(--accent-red); }

    .card-border { background: #111; border: 4px solid #fff; border-radius: 12px; overflow: hidden; box-shadow: 0 0 50px #000; display: flex; flex-direction: column; max-height: 90vh; pointer-events: auto; width: 100%; }
    #arrival-image { display: block; width: 100%; height: auto; max-height: 50vh; object-fit: contain; background: #000; border-bottom: 2px solid #fff; }
    #arrival-modal button.primary { background: linear-gradient(to bottom, #fbbf24, #d97706); border: 2px solid #78350f; color: #000; font-family: 'Cinzel', serif; font-weight: 900; font-size: 1.5rem; padding: 15px 0; width: 100%; margin-top: 15px; border-radius: 8px; cursor: pointer; pointer-events: auto; }

    /* --- 9. CHARACTER SHEET --- */
    #char-detail-modal {
        position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important;
        width: 100vw !important; height: 100vh !important;
        background-color: rgba(0, 0, 0, 0.85) !important;
        z-index: 5000 !important;
        display: none !important; align-items: center; justify-content: center;
        transform: none !important; margin: 0 !important; pointer-events: none !important;
    }
    #char-detail-modal.active { display: flex !important; pointer-events: auto !important; }
    #char-detail-modal .modal-content {
        position: relative !important; top: auto !important; left: auto !important; transform: none !important; margin: auto !important;
        background: linear-gradient(160deg, #1e293b 0%, #0f172a 100%);
        border: 2px solid var(--gold-main); box-shadow: 0 0 50px rgba(0, 0, 0, 0.8), inset 0 0 20px rgba(0,0,0,0.5);
        border-radius: 16px; width: 92vw !important; max-width: 450px !important; max-height: 90vh !important;
        padding: 0; overflow-y: auto !important; overflow-x: hidden; display: flex; flex-direction: column;
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); pointer-events: auto;
    }
    @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    .cs-header-bg { background: linear-gradient(to right, rgba(0,0,0,0.8), rgba(0,0,0,0.4)), url('https://www.transparenttextures.com/patterns/dark-leather.png'); padding: 15px; border-bottom: 2px solid var(--gold-dim); display: flex; align-items: center; gap: 15px; position: relative; flex-shrink: 0; }
    .cs-portrait { width: 60px; height: 60px; min-width: 60px; border-radius: 50%; border: 2px solid var(--gold-main); background-color: #000; background-size: cover; box-shadow: 0 0 10px var(--gold-dim); }
    .cs-info { display: flex; flex-direction: column; }
    .cs-name { font-family: var(--font-head); font-size: 1.4rem; color: var(--gold-glow); text-transform: uppercase; text-shadow: 0 2px 4px #000; line-height: 1; margin-bottom: 5px; }
    .cs-class { font-size: 0.8rem; color: #94a3b8; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
    .cs-main-stats { display: flex; justify-content: space-evenly; background: rgba(0,0,0,0.3); padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1); flex-shrink: 0; }
    .cs-stat-orb { display: flex; flex-direction: column; align-items: center; width: 60px; }
    .cs-stat-val { font-family: var(--font-head); font-size: 1.5rem; color: #fff; font-weight: 900; text-shadow: 0 0 10px var(--accent-blue); }
    .cs-stat-label { font-size: 0.6rem; color: var(--gold-main); letter-spacing: 1px; margin-top: -2px; }
    .cs-skills { padding: 15px; flex-shrink: 0; }
    .cs-skill-row { display: flex; align-items: center; background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.05); padding: 8px; border-radius: 8px; margin-bottom: 8px; }
    .cs-skill-icon { width: 32px; height: 32px; min-width: 32px; border-radius: 6px; border: 1px solid #555; margin-right: 10px; object-fit: cover; background: #000; }
    .cs-skill-text { display: flex; flex-direction: column; overflow: hidden; }
    .cs-skill-name { font-weight: bold; color: #e2e8f0; font-size: 0.85rem; }
    .cs-skill-desc { font-size: 0.7rem; color: #94a3b8; font-style: italic; line-height: 1.1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .cs-metrics { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; padding: 0 15px 15px 15px; flex-shrink: 0; }
    .cs-metric-box { background: rgba(0,0,0,0.4); border-radius: 6px; padding: 6px 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.75rem; border: 1px solid #334155; }
    .cs-metric-lbl { color: #94a3b8; }
    .cs-metric-val { color: #fff; font-weight: bold; }
    #char-detail-modal .close-x { top: 15px !important; right: 15px !important; background: #ef4444 !important; border: 2px solid #fff !important; box-shadow: 0 2px 5px #000 !important; z-index: 20 !important; }
    #cd-inv-grid-new { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; }

    /* --- 10. START & CREATION SCREENS --- */
    #splash-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3)), url('https://static.wixstatic.com/media/b16479_5511adb144cb426889022f08534446d6~mv2.jpg'); background-size: cover; background-position: center; z-index: 500 !important; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1.5s ease-in-out; pointer-events: auto; }
    #splash-screen h1 { font-size: 13vw !important; line-height: 1.1; margin-bottom: 20px; color: #fff; text-shadow: 0 0 30px var(--gold-main); }
    #splash-screen h2 { font-size: 5vw !important; margin-bottom: 40px; color: #ddd; text-shadow: 2px 2px 5px #000; }
    #splash-screen button { font-size: 1.5rem; padding: 15px 40px; background:var(--gold-main); border:none; font-weight:900; cursor:pointer; box-shadow: 0 0 20px #000; }

    #create-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: url('https://static.wixstatic.com/media/b16479_564e3eade6b7410785d835af2f340665~mv2.jpg'); background-size: cover; background-position: center; z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: flex-start; padding: 80px 20px 40px 20px; overflow-y: auto; opacity: 0; transition: opacity 1s ease-in-out; pointer-events: auto; }
    #create-screen h1 { font-size: 8rem; color: #000; text-shadow: 2px 2px 0px #FFF; text-align: center; }
    #create-screen h3 { color: #fff; font-size: 1.5rem; font-weight: 900; margin: 15px 0 10px 0; background: rgba(0,0,0,0.4); padding: 5px 15px; border-radius: 20px; display: inline-block; text-shadow: 2px 2px 0 #000; }
    .input-group label { display: block; color: #fff; margin-bottom: 8px; font-size: 2rem; font-weight: 900; font-family: 'Cinzel', serif; text-shadow: 3px 3px 0 #000; }
    .input-group input { padding: 15px; font-size: 1.5rem; border-radius: 5px; border: 3px solid #fbbf24; background: rgba(30, 41, 59, 0.9); color: white; text-align: center; width: 300px; font-weight: bold; }
    .sel-grid { 
        display: grid; 
        grid-template-columns: repeat(4, 1fr); 
        gap: 12px; 
        margin: 10px 0 20px 0; 
        width: 100%; 
        max-width: 900px;
    }
    .skill-grid { 
        display: grid; 
        grid-template-columns: repeat(3, 1fr); 
        gap: 15px; 
        margin-bottom: 30px; 
        width: 100%; 
        max-width: 900px;
    }
    .color-grid { display: flex; gap: 15px; justify-content: center; margin-top: 10px; }
    .color-opt { width: 50px; height: 50px; border-radius: 50%; border: 3px solid #000; cursor: pointer; transition: 0.2s; }
    .color-opt:hover, .color-opt.selected { transform: scale(1.2); border-color: white; box-shadow: 0 0 15px var(--gold-main); }
    .sel-opt { 
        background: linear-gradient(145deg, #1e293b, #0f172a) !important;
        border: 2px solid #475569; 
        border-radius: 12px; 
        padding: 15px 10px; 
        cursor: pointer; 
        text-align: center; 
        transition: all 0.2s ease; 
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 90px;
        position: relative;
        overflow: hidden;
    } 
    .sel-opt:hover { 
        transform: translateY(-4px); 
        border-color: #94a3b8;
        background: linear-gradient(145deg, #334155, #1e293b) !important;
        box-shadow: 0 8px 15px rgba(0,0,0,0.5);
    } 
    .sel-opt.selected { 
        border-color: var(--gold-main); 
        background: linear-gradient(145deg, #0f172a, #020617) !important;
        box-shadow: 0 0 15px rgba(251, 191, 36, 0.4); 
    } 
    .sel-opt b { color: #fff; display: block; margin-bottom: 6px; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1px; } 
    .sel-opt small { color: #94a3b8; display: block; font-size: 0.75rem; font-family: monospace; }
    .skill-card { 
        background: linear-gradient(160deg, #1e293b, #0f172a) !important; 
        border: 2px solid #334155; 
        border-radius: 12px; 
        padding: 15px; 
        cursor: pointer; 
        width: 100%; 
        text-align: center; 
        box-shadow: 0 4px 10px rgba(0,0,0,0.3); 
        transition: all 0.2s;
        display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
        min-height: 180px;
    }
    .skill-card:hover { 
        border-color: var(--gold-glow); 
        transform: translateY(-3px);
        background: #1e293b !important;
    } 
    .skill-card.selected { 
        background: linear-gradient(160deg, #064e3b, #022c22) !important; 
        border-color: var(--accent-green); 
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); 
    } 
    .skill-card img { 
        width: 64px; 
        height: 64px; 
        border-radius: 8px; 
        border: 2px solid #555; 
        object-fit: cover; 
        margin-bottom: 12px; 
        background: #000;
        box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    }
	.skill-card b { 
        color: #f1f5f9; 
        display: block; 
        margin-bottom: 8px; 
        font-size: 1rem; 
        font-family: var(--font-head);
        letter-spacing: 0.5px;
        text-shadow: 0 2px 2px #000;
        min-height: 1.2em;
    } 
	.skill-card small { 
        color: #cbd5e1; 
        font-size: 0.8rem; 
        line-height: 1.4;
        display: block;
        font-style: italic;
    }

    #creator-portrait-frame { position: fixed; right: 5%; top: 50%; transform: translateY(-50%); width: 400px; height: 500px; border: 4px solid var(--gold-main); border-radius: 10px; box-shadow: 0 0 30px #000; background-color: #000; background-size: cover; background-position: top center; background-repeat: no-repeat; display: none; z-index: 5000; transition: all 0.3s ease; }
    #creator-portrait-frame.minimized { width: 80px !important; height: 80px !important; right: 20px !important; top: 20px !important; transform: none !important; border-width: 2px !important; }

    #logo-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000 !important; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1.5s ease-out; pointer-events: auto; }
    #logo-img { width: 60%; max-width: 800px; height: auto; opacity: 0; animation: logoFadeIn 5s forwards; }
    #logo-text { margin-top: 20px; color: #fff; font-family: 'Cinzel', serif; font-size: 3vmin; opacity: 0; animation: logoFadeIn 2s forwards 5.5s; }
    @keyframes logoFadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

    /* --- 11. DEBUG CONSOLE --- */
    #debug-console { position: fixed; top: 10px; left: 10px; width: 300px; max-width: 90vw; background: rgba(0, 0, 0, 0.85); border: 1px solid #0f0; padding: 10px; z-index: 10000; border-radius: 4px; box-shadow: 0 0 10px #000; }
    #console-input { width: 100%; background: #111; border: none; border-bottom: 1px solid #0f0; color: #fff; font-family: monospace; padding: 5px; outline: none; }
    .debug-btn { background: #333; color: #fff; border: 1px solid #555; padding: 8px; cursor: pointer; text-align: left; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .debug-btn:hover { background: #ef4444; border-color: #fff; }
    
    #debug-log-overlay { position: fixed; bottom: 160px; left: 10px; width: 300px; height: 200px; background: rgba(0, 0, 0, 0.85); border: 1px solid #0f0; z-index: 10000; font-family: monospace; font-size: 12px; display: flex; flex-direction: column; pointer-events: none; transition: height 0.3s ease, width 0.3s ease; }
    #debug-log-overlay.minimized { height: 38px !important; overflow: hidden; border-bottom: none; }
    .debug-header { background: #000; color: #0f0; padding: 5px; font-weight: bold; border-bottom: 1px solid #0f0; display: flex; justify-content: space-between; align-items: center; pointer-events: auto; height: 36px; box-sizing: border-box; }
    #debug-log-content { flex-grow: 1; overflow-y: auto; padding: 5px; color: #fff; display: flex; flex-direction: column-reverse; }
    .debug-line { margin-bottom: 2px; border-bottom: 1px solid #333; }
    .debug-line span { color: #0f0; margin-right: 5px; }
    #btn-copy-log, #btn-min-log { background: #000; color: #0f0; border: 1px solid #0f0; font-family: monospace; font-size: 10px; padding: 2px 8px; cursor: pointer; pointer-events: auto; text-transform: uppercase; border-radius: 2px; height: auto; }
    #btn-min-log { margin-left: 5px; font-size: 14px; line-height: 20px; display: flex; align-items: center; justify-content: center; }
    #btn-copy-log:hover, #btn-min-log:hover { background: #0f0; color: #000; }

    /* Tooltip */
    #tooltip { position: absolute; display: none; background: rgba(10,10,15,0.98); border: 2px solid var(--gold-main); padding: 15px; font-size: 0.9rem; z-index: 9999; pointer-events: none; max-width: 250px; border-radius: 8px; box-shadow: 0 5px 20px #000; }
    .tt-icon { width: 40px !important; height: 40px !important; min-width: 40px; object-fit: cover; border: 1px solid var(--gold-main); margin-right: 10px; background: #000; }
    #context-menu { position: absolute; display: none; flex-direction: column; background: #222; border: 1px solid var(--gold-main); z-index: 1000; border-radius: 4px; pointer-events: auto; }
    .ctx-item { padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #333; color: #eee; } .ctx-item:hover { background: var(--gold-dim); }

    /* --- 12. MOBILE & RESPONSIVE (EDGE-TO-EDGE FIX) --- */
    @media (max-width: 1600px) {
        #p1-sheet, #leaderboard { display: none !important; }
        #p1-sheet.active, #leaderboard.active {
            display: flex !important; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 80vw; max-width: 400px; height: 70vh;
            z-index: 4000 !important; background: rgba(15, 23, 42, 0.98); border: 2px solid var(--gold-main);
        }
        .mobile-toggle-btn { display: flex !important; }
    }

    @media (max-width: 1000px) {
        .sel-grid { grid-template-columns: repeat(2, 1fr); }
        .skill-grid { grid-template-columns: repeat(2, 1fr); }
        .input-group input { width: 100%; } 
        #splash-screen h1, #create-screen h1 { font-size: 4rem; }
        #creator-portrait-frame { width: 120px; height: 120px; right: 10px; top: 10px; transform: none; border-width: 2px; }
        .skill-card { min-height: 200px; }
    }

/* --- MOBILE FULL SCREEN UI --- */
    @media only screen and (max-width: 768px) {
        /* Expand the Container to Full Screen */
        #board-anchor {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            max-height: none !important;
            transform: none !important; 
            top: 0 !important;
            left: 0 !important;
        }

        /* Expand the Inner Zone */
        #inner-zone {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
        }

        /* RE-POSITION WIDGETS TO SCREEN EDGES */
        
        /* Top Left - Treasury */
        #treasury-widget {
            top: 10px !important;
            left: 10px !important;
            padding: 5px 10px !important;
        }

        /* Top Center - Turn */
        #turn-widget {
            top: 10px !important;
            width: 90% !important;
        }

        /* Top Right - Stats */
        #mystats-widget {
            top: 10px !important;
            right: 10px !important;
            left: auto !important;
            min-width: auto !important;
            padding: 5px 10px !important;
        }

        /* Below Top Widgets - Log */
        #adventure-log-widget {
            top: 80px !important; 
            width: 90% !important;
            height: 15vh !important;
        }

        /* Bottom Center - Skill Bar (Attached to bottom edge) */
        #skill-bar-container {
            bottom: 5px !important; /* Hug bottom */
            width: 98% !important; /* Full width */
            height: 16vh !important; /* Fixed height for consistent layout */
            align-items: flex-end !important;
        }
        
        /* Action Button (Centered inside the Skill Bar) */
        #btn-action-container {
             bottom: 15px !important; /* Sits inside the bar */
             /* Use vh for size so it matches the bar height, not screen width */
             width: 17vh !important; 
             height: 17vh !important;
             left: 50% !important;
             transform: translateX(-50%) !important;
             z-index: 3001 !important; /* Ensure it sits on top of bar border */
        }
        
        /* Fix Button Font Size for Mobile */
        #btn-action {
            font-size: 2.5vh !important;
        }

        /* Utility Buttons (Moved UP above the Skill Bar) */
        #utility-stack {
            bottom: 22% !important; /* Clears the 16vh skill bar + gap */
            right: 10px !important;
            gap: 15px !important;
        }
        
        /* HUD Open Buttons (Same position as Utility stack) */
        #hud-toggles {
            bottom: 22% !important;
            right: 10px !important;
            top: auto !important;
        }
    }
	
	/* --- MULTIPLAYER UI STYLES --- */
#auth-screen, #lobby-screen { 
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
    background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.8)), url('https://static.wixstatic.com/media/b16479_5511adb144cb426889022f08534446d6~mv2.jpg'); 
    background-size: cover; background-position: center; 
    z-index: 1000 !important; display: flex; flex-direction: column; 
    align-items: center; justify-content: center; 
    pointer-events: auto; color:#fff; 
}

.auth-container { 
    background: rgba(0,0,0,0.85); padding: 40px; 
    border: 2px solid var(--gold-main); border-radius: 12px; 
    text-align: center; width: 90%; max-width: 400px; 
    box-shadow: 0 0 50px #000; 
}

.auth-input { 
    width: 100%; padding: 12px; margin: 10px 0; 
    background: #222; border: 1px solid #444; 
    color: #fff; border-radius: 4px; 
}

.auth-btn { 
    width: 100%; padding: 12px; margin-top: 10px; 
    font-weight: bold; cursor: pointer; border-radius: 4px; 
    text-transform: uppercase; font-family: var(--font-head); 
}

.btn-login { background: var(--gold-main); border: none; color: #000; }
.btn-reg { background: transparent; border: 1px solid var(--gold-main); color: var(--gold-main); }
.auth-link { color: #aaa; text-decoration: underline; cursor: pointer; font-size: 0.8rem; margin-top: 15px; display: block; }

.lobby-list { 
    width: 100%; 
    /* Remove fixed height, use flex to fill available space */
    flex-grow: 1; 
    height: 100%; 
    min-height: 200px;
    background: rgba(0,0,0,0.5); 
    border: 1px solid #444; 
    margin: 10px 0; 
    overflow-y: auto; 
    text-align: left; 
}
.lobby-item { padding: 10px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; cursor: pointer; }
.lobby-item:hover { background: rgba(255,255,255,0.1); }


/* --- GLOBAL CHAT (In Main Lobby) --- */
.lobby-layout { display: flex; gap: 20px; width: 90%; max-width: 1000px; height: 80vh; }
.lobby-left { flex: 1; display: flex; flex-direction: column; gap: 10px; }
.lobby-right { flex: 1; display: flex; flex-direction: column; background: rgba(0,0,0,0.6); border: 1px solid #444; }

.chat-box { flex-grow: 1; overflow-y: auto; padding: 10px; font-size: 0.9rem; text-align: left; display: flex; flex-direction: column; justify-content: flex-end; }
.chat-msg { margin-bottom: 4px; text-shadow: 1px 1px 0 #000; }
.chat-msg .name { font-weight: bold; color: var(--gold-main); margin-right: 5px; }
.chat-input-row { display: flex; border-top: 1px solid #444; }
.chat-input { flex-grow: 1; background: transparent; border: none; padding: 10px; color: #fff; outline: none; }
.chat-send { background: var(--gold-dim); border: none; color: #fff; padding: 0 20px; cursor: pointer; }

/* --- GAME ROOM (Pre-Game Lobby) --- */
#gameroom-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
    z-index: 350; display: none;
    flex-direction: column; align-items: center; justify-content: center;
}

.room-container {
    width: 95%; max-width: 1400px; height: 85vh;
    display: grid; grid-template-columns: 2.5fr 1fr; gap: 30px;
    padding: 20px;
}

.room-slots-panel {
    display: flex; flex-direction: column; gap: 15px;
    padding: 10px; overflow-y: auto;
}

.room-info-panel {
    background: rgba(15, 23, 42, 0.6);
    border: 1px solid var(--glass-border);
    border-radius: 12px;
    display: flex; flex-direction: column;
    overflow: hidden;
}

.player-slot {
    background: linear-gradient(145deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.95));
    border: 1px solid #334155;
    border-left: 5px solid #334155; /* Status bar */
    border-radius: 8px;
    padding: 15px 20px;
    display: flex; align-items: center; justify-content: space-between;
    height: 100px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    position: relative;
}
.player-slot.open {
    border-style: dashed;
    background: rgba(255,255,255,0.02);
    opacity: 0.7;
    border-left-color: #666;
}
.player-slot.ready {
    border-left-color: var(--accent-green);
    background: linear-gradient(145deg, rgba(6, 78, 59, 0.3), rgba(2, 44, 34, 0.8));
    box-shadow: 0 0 20px rgba(16, 185, 129, 0.15);
}

.slot-left-group { display: flex; align-items: center; gap: 20px; flex-grow: 1; }
.slot-avatar {
    width: 70px; height: 70px;
    border-radius: 12px;
    background-color: #000;
    border: 2px solid #555;
    background-size: cover;
    background-position: top center;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}
.slot-details { flex-grow: 1; text-align: left; }
.slot-info { display: flex; flex-direction: column; justify-content: center; text-align: left; }
.slot-name { font-family: var(--font-head); font-size: 1.4rem; color: #fff; text-shadow: 0 2px 2px #000; }
.slot-meta { font-size: 0.85rem; color: #94a3b8; font-style: italic; margin-top: 4px; }
.slot-controls { display: flex; gap: 10px; align-items: center; }
.slot-action-btn {
    background: linear-gradient(to bottom, #a855f7, #7e22ce);
    border: 1px solid #d8b4fe;
    color: white;
    padding: 8px 16px;
    border-radius: 6px;
    font-weight: bold;
    font-size: 0.8rem;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    text-transform: uppercase;
    animation: glowPulse 2s infinite;
}
.slot-action-btn.edit {
    background: #334155; border-color: #64748b; animation: none;
}

/* Dropdowns for Host */
.slot-select {
    background: #0f172a; color: #e2e8f0;
    border: 1px solid #475569; padding: 8px;
    border-radius: 4px; cursor: pointer;
}

@keyframes glowPulse {
    0% { box-shadow: 0 0 5px #a855f7; }
    50% { box-shadow: 0 0 15px #a855f7; }
    100% { box-shadow: 0 0 5px #a855f7; }
}

.room-actions { 
    grid-column: 1 / -1; display: flex; justify-content: space-between; 
    padding: 15px; background: #000; border-top: 2px solid var(--gold-dim); 
}

/* Password Modal */
#password-modal { z-index: 6000; }


/* --- RARITY BORDERS --- */
.rarity-common { border: 2px solid #9ca3af !important; box-shadow: inset 0 0 5px rgba(156, 163, 175, 0.5); }
.rarity-rare { border: 2px solid #3b82f6 !important; box-shadow: inset 0 0 8px rgba(59, 130, 246, 0.5); }
.rarity-epic { border: 2px solid #a855f7 !important; box-shadow: inset 0 0 10px rgba(168, 85, 247, 0.5); }
.rarity-legendary { border: 2px solid #f59e0b !important; box-shadow: inset 0 0 15px rgba(245, 158, 11, 0.6); animation: legendaryPulse 2s infinite; }

@keyframes legendaryPulse {
    0% { box-shadow: inset 0 0 10px rgba(245, 158, 11, 0.4); border-color: #f59e0b; }
    50% { box-shadow: inset 0 0 20px rgba(251, 191, 36, 0.8); border-color: #fbbf24; }
    100% { box-shadow: inset 0 0 10px rgba(245, 158, 11, 0.4); border-color: #f59e0b; }
}

/* Ensure background images fit nicely */
.inv-slot, .equip-slot {
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
}
/* Make text readable over images */
.inv-slot, .equip-slot { 
    text-shadow: 0 0 4px #000, 0 0 4px #000, 0 0 4px #000; 
    font-weight: 900;
}

/* --- PAPER DOLL & BODY DIAGRAM --- */
.paper-doll-container {
    position: relative;
    width: 280px; /* Fixed width for the body diagram */
    height: 360px; /* Fixed height */
    margin: 0 auto 10px auto;
    background-image: url('https://static.wixstatic.com/media/b16479_fee22d2bd55c4370948ba43e38ae62fb~mv2.jpg');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    /* Invert colors to make black SVG look like a light silhouette on dark bg */
   /* filter: invert(0.3) opacity(0.5); */
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
}

/* Base style for slots on the body */
.doll-slot {
    position: absolute;
    width: 70px;  /* Match inventory size */
    height: 70px; /* Match inventory size */
    background-color: rgba(0, 0, 0, 0.9);
    border: 1px solid #444;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.6rem;
    color: #aaa;
    cursor: pointer;
    box-shadow: 0 0 5px #000;
    transition: 0.2s;
    
    /* Ensure images cover the slot */
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    
    /* Remove the filter from parent so slots look normal */
    filter: invert(0) opacity(1) !important; 
    z-index: 10;
}

.doll-slot.filled {
    border-color: var(--gold-dim);
    color: transparent; /* Hide text when image is present */
    text-shadow: none;
}

/* --- SLOT POSITIONS (Adjusted for the silhouette) --- */
#slot-head, #cd-slot-head { top: 2%; left: 50%; transform: translateX(-50%); }
#slot-body, #cd-slot-body { top: 30%; left: 50%; transform: translateX(-50%); }
#slot-main, #cd-slot-main { top: 45%; left: 3%; } /* Left Hand (Viewer's Left) */
#slot-off,  #cd-slot-off  { top: 45%; right: 3%; } /* Right Hand */

/* Update Inventory Slots to match size exactly */
.inv-slot {
    width: 50px;
    height: 50px;
    aspect-ratio: 1; /* Force square */
}

/* --- TOP RIGHT HUD CONTAINER --- */
#top-right-hud {
    position: fixed;
    top: 15px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 15px; /* Space between buttons */
    z-index: 10000; /* Above everything */
    pointer-events: auto;
}

/* --- ICON BUTTON RESETS --- */
/* We remove fixed positioning because the container handles it now */

#bug-btn,
#store-floating-btn,
.notification-icon-container, 
#start-profile-btn,
#lobby-profile-btn {
    position: relative !important;
    top: auto !important;
    right: auto !important;
    left: auto !important;
    margin: 0 !important;
    
    /* Keep visual style */
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    
    /* Stability Fixes */
    transform: translateZ(0);
    -webkit-transform: translateZ(0);
    transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
}

#bug-btn {
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #ef4444; /* Red border for bugs */
    font-size: 1.5rem;
}
#bug-btn:hover {
    background-color: #450a0a;
    border-color: #f87171;
    box-shadow: 0 0 20px #ef4444;
}

/* Specific Styles */
#store-floating-btn {
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #10b981;
    font-size: 1.5rem;
}
#store-floating-btn:hover {
    background-color: #064e3b;
    border-color: #34d399;
    box-shadow: 0 0 20px #10b981;
}

.notification-icon-container {
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid var(--gold-dim);
    font-size: 1.5rem;
}
.notification-icon-container:hover {
    background-color: #451a03;
    border-color: var(--gold-glow);
    box-shadow: 0 0 20px var(--gold-main);
}

/* Profile button specific overrides to fit container */
#start-profile-btn, #lobby-profile-btn {
    display: block; /* Ensure visibility */
    background-size: cover;
    background-position: center;
    background-color: #000;
    border: 2px solid var(--gold-main);
}
#start-profile-btn:hover, #lobby-profile-btn:hover {
    box-shadow: 0 0 20px var(--gold-glow);
    border-color: #fff;
}

/* Hide Store if Premium */
body.premium-user #store-floating-btn {
    display: none !important;
}

/* In-Lobby Profile Button */
.lobby-profile-btn {
    width: 40px; height: 40px; border-radius: 50%;
    background-size: cover; background-color: #000; border: 1px solid var(--gold-main);
    cursor: pointer; margin-right: 10px;
}

.profile-layout { display: flex; gap: 20px; text-align: left; }
.profile-left { width: 120px; text-align: center; }
.profile-avatar-lg {
    width: 100px; height: 100px; border-radius: 50%; 
    border: 3px solid var(--gold-main); margin-bottom: 10px;
    background-size: cover; background-position: center; background-color: #000;
}
.profile-right { flex-grow: 1; display: flex; flex-direction: column; gap: 10px; }
.profile-label { font-size: 0.8rem; color: #aaa; text-transform: uppercase; }
.profile-textarea { 
    width: 100%; height: 80px; background: rgba(0,0,0,0.5); 
    border: 1px solid #444; color: #fff; padding: 5px; resize: none; 
}

/* Friend List */
.friend-list { 
    max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.3); 
    border: 1px solid #444; margin-top: 10px; 
}
.friend-item { 
    display: flex; align-items: center; justify-content: space-between; 
    padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); 
    cursor: pointer; transition: 0.2s;
}
.friend-item:hover { background: rgba(255,255,255,0.1); }
.friend-info { display: flex; align-items: center; gap: 10px; }
.friend-avatar { width: 30px; height: 30px; border-radius: 50%; background-size: cover; border: 1px solid #666; }
.online-dot { 
    width: 10px; height: 10px; border-radius: 50%; 
    background: #666; box-shadow: 0 0 5px #000; 
}
.online-dot.online { background: #10b981; box-shadow: 0 0 5px #10b981; }

/* Lobby Search */
.lobby-search-row { display: flex; gap: 10px; margin-bottom: 10px; }
.lobby-search { flex-grow: 1; background: rgba(0,0,0,0.5); border: 1px solid #444; padding: 8px; color: #fff; }

/* Dropdown Context Menu for Friends */
.friend-dropdown { display: none; position: absolute; background: #222; border: 1px solid var(--gold-main); z-index: 7000; flex-direction: column; }

/* --- MOBILE LOBBY ADJUSTMENTS --- */
@media only screen and (max-width: 900px) {
    /* Switch to Vertical Stack */
    .lobby-layout {
        display: flex;
        flex-direction: column;
        height: 100vh !important; /* Force viewport height */
        max-height: 100vh;
        width: 100% !important;
        margin: 0 !important;
        gap: 0;
    }

    /* Top Section: Game List */
   .lobby-left {
        flex: 1; /* Takes top half */
        display: flex;
        flex-direction: column;
        padding: 10px;
        min-height: 50%;
    }


    /* Bottom Section: Chat */
    .lobby-right {
        flex: 1; /* Takes bottom half */
        display: flex;
        flex-direction: column;
        padding: 10px;
        border-top: 2px solid var(--gold-dim);
    }

    /* Fix Lists to Scroll properly */
    #lobby-list {
        flex-grow: 1;
        overflow-y: auto;
        min-height: 0; /* Important for flex scrolling */
        margin-bottom: 10px;
    }

    /* Adjust Inputs for Touch */
    .chat-input, .lobby-search, .auth-input {
        font-size: 16px; /* Prevents iOS zoom on focus */
        padding: 12px;
    }
	
	.lobby-left button.auth-btn.btn-reg {
        flex-shrink: 0; /* Prevent button from shrinking */
        margin-top: auto; /* Push to bottom */
    }
    
    .chat-send, .auth-btn {
        padding: 12px;
    }

    /* Header Adjustments */
    .lobby-left h1 {
        font-size: 1.5rem !important;
    }
    
    .lobby-profile-btn {
        width: 35px;
        height: 35px;
    }
}

/* --- MOBILE GAME ROOM ADJUSTMENTS --- */
@media only screen and (max-width: 900px) {
    /* 1. Switch Grid to Vertical Flex Column */
    .room-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        max-width: none;
        padding: 5px;
        gap: 5px;
    }

    /* 2. Top Section: Player Slots (Flexible Height) */
    .room-slots-panel {
        flex: 1; /* Grows to fill available space */
        overflow-y: auto; /* Scroll if too many slots fit */
        min-height: 0; /* Crucial for nested flex scrolling */
        padding: 5px;
        gap: 8px;
    }

    /* Compact Player Slot Cards */
    .player-slot {
        height: auto;
        min-height: 70px;
        padding: 10px;
    }
    .slot-avatar {
        width: 50px;
        height: 50px;
        border-radius: 8px;
    }
    .slot-name {
        font-size: 1rem;
    }
    .slot-meta {
        font-size: 0.7rem;
    }
    /* Hide the kick/remove buttons' text on very small screens if needed, 
       or keep them as is since they are just "X" usually */

    /* 3. Middle Section: Map & Chat */
    .room-info-panel {
        height: 35vh; /* Fixed height for chat area */
        flex-shrink: 0; /* Don't shrink below this */
        display: flex;
        flex-direction: column;
    }
    
    /* Shrink the Map Image to save space */
    .room-info-panel img {
        height: 40px; 
        width: auto;
        object-fit: contain;
        margin: 2px auto;
    }
    .room-info-panel > div:first-child {
        padding: 5px; /* Reduce padding around map/title */
    }

    /* Ensure Chat fills the remaining info panel space */
    #room-chat-box {
        flex-grow: 1;
        min-height: 0;
    }

    /* 4. Bottom Section: Actions/Buttons */
    .room-actions {
        flex-shrink: 0;
        display: flex;
        flex-direction: column; /* Stack the two button rows */
        gap: 8px;
        padding: 10px;
    }
    
    /* Make button rows full width */
    .room-actions > div {
        display: flex;
        width: 100%;
        gap: 8px;
    }
    
    /* Make buttons huge and tappable */
    .room-actions button {
        flex: 1; /* Stretch to fill row */
        padding: 15px;
        font-size: 1rem;
    }
}

/* --- MOBILE PROFILE & MAP ADJUSTMENTS --- */
@media only screen and (max-width: 900px) {
    
    /* 1. Game Room Map Swapping */
    #desktop-map-view { display: none !important; }
    #mobile-map-btn { display: flex !important; }
    
    /* Allow chat to expand since map is gone */
    .room-info-panel { height: auto !important; flex: 1; } 
    .map-container-wrapper { padding: 5px !important; }

    /* 2. Profile Modal Responsiveness */
    #profile-modal .modal-content {
        width: 95% !important;
        height: 90vh !important; /* Full height */
        max-height: none !important;
        overflow-y: auto !important; /* Enable scrolling */
        display: block !important; /* Fix flex issues in scrollable container */
    }

    /* Stack Profile Layout Vertically */
    .profile-layout {
        flex-direction: column !important;
        gap: 15px !important;
    }

    /* Center the Avatar section */
    .profile-left {
        width: 100% !important;
        display: flex;
        flex-direction: column;
        align-items: center;
        border-bottom: 1px solid #333;
        padding-bottom: 15px;
        margin-bottom: 10px;
    }
    
    /* Inputs full width */
    .profile-right {
        width: 100% !important;
    }

    /* Adjust Friend List height in profile */
    #profile-friends-list {
        max-height: 200px !important; /* Limit height so it doesn't push off screen */
    }
    
    /* Make the Password Button bigger/easier to tap */
    #profile-modal button[onclick*="changePassword"] {
        position: relative !important;
        top: auto !important;
        right: auto !important;
        width: 100%;
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #444 !important;
        background: rgba(0,0,0,0.3) !important;
        border-radius: 4px;
    }
}

/* --- FRIEND REQUESTS --- */
.request-item {
    background: rgba(234, 179, 8, 0.1); /* Gold tint */
    border: 1px solid var(--gold-main);
    padding: 8px; margin-bottom: 5px;
    display: flex; justify-content: space-between; align-items: center;
    border-radius: 4px;
}
.req-actions { display: flex; gap: 5px; }
.req-btn { padding: 4px 8px; font-size: 0.7rem; cursor: pointer; border: none; border-radius: 3px; font-weight: bold; }

/* Notification Badge on Profile Button */
.notify-badge {
    position: absolute; top: -5px; right: -5px;
    width: 20px; height: 20px; background: #ef4444;
    border-radius: 50%; border: 2px solid #fff;
    color: #fff; font-size: 12px; font-weight: bold;
    display: flex; align-items: center; justify-content: center;
    z-index: 700;
}

/* --- DIRECT MESSAGING --- */
#dm-window {
    position: fixed; bottom: 20px; right: 20px;
    width: 300px; height: 400px;
    z-index: 8000; display: none;
    flex-direction: column;
}
.dm-header {
    padding: 10px; background: rgba(0,0,0,0.8);
    border-bottom: 1px solid var(--gold-dim);
    font-weight: bold; cursor: move;
    display: flex; justify-content: space-between;
}
.dm-body {
    flex-grow: 1; overflow-y: auto; padding: 10px;
    background: rgba(0,0,0,0.5); display: flex; flex-direction: column;
}
.dm-msg {
    margin-bottom: 5px; padding: 5px 8px; border-radius: 4px;
    max-width: 80%; word-wrap: break-word; font-size: 0.9rem;
}
.dm-msg.me { align-self: flex-end; background: var(--gold-dim); color: #fff; }
.dm-msg.them { align-self: flex-start; background: #334155; color: #e2e8f0; }

/* --- FRIEND SETTINGS --- */
.setting-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 10px; border-bottom: 1px solid #333;
}
.setting-row label { color: #ccc; font-size: 0.9rem; }
/* Custom Checkbox */
.toggle-chk { width: 20px; height: 20px; accent-color: var(--gold-main); cursor: pointer; }

/* The Red Counter */
.notify-count-badge {
    position: absolute; top: -5px; right: -5px;
    background: #ef4444; color: #fff;
    border: 2px solid #fff; border-radius: 50%;
    width: 22px; height: 22px;
    font-size: 0.75rem; font-weight: bold;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
}

/* On Mobile, if we are in the Lobby (Start Screen hidden), we can move it to the corner 
   But keeping it at 85px is safer to avoid overlap with the "X" buttons or scrollbars */

/* Notification List Items in Modal */
.notify-item {
    background: rgba(30, 41, 59, 0.9);
    border: 1px solid #444; border-radius: 6px;
    padding: 10px; margin-bottom: 8px;
    display: flex; flex-direction: column; gap: 5px;
    text-align: left;
}
.notify-header { font-size: 0.8rem; color: var(--gold-dim); display:flex; justify-content:space-between;}
.notify-body { font-size: 0.9rem; color: #fff; }
.notify-actions { display: flex; gap: 10px; margin-top: 5px; }

/* --- WHISPER CHAT STYLE --- */
.chat-msg.whisper {
    background: rgba(88, 28, 135, 0.4); /* Dark Purple BG */
    border-left: 3px solid #d8b4fe; /* Light Purple Bar */
}
.chat-msg .whisper-name { color: #d8b4fe; font-weight: bold; }
.chat-msg .whisper-text { color: #f3e8ff; font-style: italic; }

/* --- FIX: SCREEN CONTAINMENT --- */
/* This forces all main game screens to stay inside the Game Wrapper 
   instead of stretching over the Ad Bar */

#logo-screen,
#splash-screen,
#auth-screen,
#lobby-screen,
#gameroom-screen,
#create-screen {
    position: absolute !important; /* Changed from 'fixed' */
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    overflow-y: auto !important; /* Ensure scrolling works inside the box */
    overflow-x: hidden !important;
}

/* Add extra padding to the bottom of the Character Creator 
   so the button doesn't feel cramped against the wood bar */
#create-screen {
    padding-bottom: 50px !important;
}
</style>
</head>

<body>
<div id="game-viewport-wrapper">

<!-- TOP RIGHT HUD CONTAINER -->
<div id="top-right-hud">
    
    <!-- 1. Bug Report Button -->
    <div id="bug-btn" onclick="BUG_REPORT.open()">ðŸž</div>

    <!-- 2. Store Button -->
    <div id="store-floating-btn" onclick="STORE.open()">ðŸ’Ž</div>

    <!-- 3. Notification Bell -->
    <div id="global-notify-btn" class="notification-icon-container" onclick="NOTIFICATIONS.openModal()">
        <div class="notification-bell">ðŸ””</div>
        <div id="notify-badge-count" class="notify-count-badge" style="display:none;">0</div>
    </div>

    <!-- 4. Profile Button -->
    <div id="start-profile-btn" class="profile-btn-floating" onclick="PROFILE.open()"></div>

</div>

<!-- LOGO SCREEN (Preserved) -->
<div id="logo-screen">
    <img id="logo-img" src="https://static.wixstatic.com/media/b16479_0a56fee31ec34232abc426d0ee72b6b1~mv2.png" alt="Logo">
    <div id="logo-text">Click to Continue</div>
</div>

<div id="game-layer"></div>

<!-- AUTH SCREEN -->
<div id="auth-screen" style="display:none;">
    <div class="auth-container">
        <h1 style="color:var(--gold-main); margin-bottom:10px;">Login</h1>
        <input type="email" id="auth-email" class="auth-input" placeholder="Email Address">
        <input type="password" id="auth-pass" class="auth-input" placeholder="Password" onkeydown="if(event.key==='Enter') AUTH.login()">
        <button class="auth-btn btn-login" onclick="AUTH.login()">Sign In</button>
        <button class="auth-btn btn-reg" onclick="AUTH.register()">Register</button>
        <span class="auth-link" onclick="AUTH.recover()">Forgot Password?</span>
        <div id="auth-msg" style="color:#ef4444; margin-top:10px; font-size:0.9rem;"></div>
    </div>
</div>

<!-- LOBBY SCREEN -->
<div id="lobby-screen" style="display:none;">
    <div class="lobby-layout">
        <!-- LEFT: Game List & Create -->
<div class="lobby-left">
    <div style="display:flex; align-items:center; margin-bottom: 10px;">
        <div id="lobby-profile-btn" class="lobby-profile-btn" onclick="PROFILE.open()"></div>
        <h1 style="color:var(--gold-main); text-align:left; margin:0;">MULTIPLAYER</h1>
    </div>
    
    <div class="lobby-search-row">
        <input type="text" id="lobby-search" class="lobby-search" placeholder="Search games..." onkeyup="LOBBY.refreshList()">
        <button class="auth-btn btn-reg" style="width:auto; padding:8px 15px; margin:0;" onclick="LOBBY.refreshList()">â†»</button>
    </div>
    <button class="auth-btn btn-login" style="width:100%; margin-bottom:10px;" onclick="createGameLogic()">Create Game</button>
    
    <div id="lobby-list" class="lobby-list">
        <div style="padding:20px; text-align:center; color:#666;">Loading games...</div>
    </div>
    <button class="auth-btn btn-reg" onclick="LOBBY.exit()">Back to Main Menu</button>
</div>

        <!-- RIGHT: Global Chat -->
        <div class="lobby-right">
            <div class="chat-header" style="padding:10px; background:#111; border-bottom:1px solid #444; font-weight:bold; color:var(--gold-main);">GLOBAL CHAT</div>
            <div id="global-chat-box" class="chat-box"></div>
            <div class="chat-input-row">
                <input type="text" id="global-chat-input" class="chat-input" placeholder="Type message..." onkeydown="if(event.key==='Enter') LOBBY.sendChat()">
                <button class="chat-send" onclick="LOBBY.sendChat()">SEND</button>
            </div>
        </div>
    </div>
</div>

<!-- NEW GAME ROOM SCREEN (The StarCraft Style Lobby) -->
<div id="gameroom-screen">
    <div class="room-container">
        <!-- LEFT: Slots -->
        <div class="room-slots-panel">
            <h2 id="room-name" style="color:#fff; border-bottom:1px solid #333; padding-bottom:10px;">Game Room</h2>
            <div id="slot-0" class="player-slot"></div>
            <div id="slot-1" class="player-slot"></div>
            <div id="slot-2" class="player-slot"></div>
            <div id="slot-3" class="player-slot"></div>
        </div>

        <!-- RIGHT: Map Info & Chat -->
        <div class="room-info-panel">
            <div style="padding:10px; text-align:center; border-bottom:1px solid #444;">
                <img src="https://static.wixstatic.com/media/b16479_5caac3525f59406d8ff175695ef11cb1~mv2.jpg" style="width:80%; border:2px solid var(--gold-dim); margin-bottom:5px;">
                <div style="color:var(--gold-main); font-weight:bold;">Kingdom Map</div>
				<div class="map-container-wrapper" style="padding:10px; border-bottom:1px solid #444;">
    <!-- Desktop View: Shows Image -->
    <div id="desktop-map-view">
        <img src="https://static.wixstatic.com/media/b16479_5caac3525f59406d8ff175695ef11cb1~mv2.jpg" style="width:80%; border:2px solid var(--gold-dim); margin-bottom:5px;">
        <div style="color:var(--gold-main); font-weight:bold;">Kingdom Map</div>
    </div>

    <!-- Mobile View: Shows Button -->
    <button id="mobile-map-btn" class="choice-btn" style="display:none; width:100%; text-align:center; justify-content:center;" onclick="document.getElementById('map-modal').style.display='flex'">ðŸ—º View Kingdom Map</button>

    <!-- Password Input (Keep this here) -->
    <div id="host-settings-area" style="padding-top:10px; display:none;">
        <label style="font-size:0.8rem; color:#aaa;">Game Password (Optional)</label>
        <input type="text" class="chat-input" placeholder="No Password" style="background:rgba(0,0,0,0.3); border:1px solid #555; width:100%;" onchange="ROOM.setPassword(this.value)">
    </div>
</div>
				<!-- Password Input for Host -->
<div id="host-settings-area" style="padding:10px; border-bottom:1px solid #444; display:none;">
    <label style="font-size:0.8rem; color:#aaa;">Game Password (Optional)</label>
    <input type="text" class="chat-input" placeholder="No Password" style="background:rgba(0,0,0,0.3); border:1px solid #555; width:100%;" onchange="ROOM.setPassword(this.value)">
</div>
            </div>
            <div id="room-chat-box" class="chat-box"></div>
            <div class="chat-input-row">
                <input type="text" id="room-chat-input" class="chat-input" placeholder="Chat with players..." onkeydown="if(event.key==='Enter') ROOM.sendChat()">
                <button class="chat-send" onclick="ROOM.sendChat()">SEND</button>
            </div>
        </div>

        <!-- BOTTOM: Actions -->
<!-- UPDATED FOOTER -->
<div class="room-actions">
    <div style="display:flex; gap:10px;">
        <button class="auth-btn btn-reg" style="width:auto; margin:0;" onclick="ROOM.leave()">Leave Game</button>
        <button class="auth-btn btn-login" style="width:auto; margin:0; background:#3b82f6; color:#fff;" onclick="ROOM.copyLink()">Copy Link</button>
    </div>
    <div style="display:flex; gap:10px;">
        <!-- Edit Character button removed from here -->
        <button id="btn-room-start" class="auth-btn btn-login" style="width:auto; margin:0; padding:10px 40px; font-size:1.2rem;" disabled onclick="ROOM.startGame()">START GAME</button>
    </div>
</div>
    </div>
</div>

<!-- PASSWORD MODAL -->
<div id="password-modal" class="modal-overlay">
    <div class="modal-content" style="width:300px;">
        <h3 style="color:var(--gold-main); margin-top:20px;">Private Game</h3>
        <input type="password" id="join-pass" class="auth-input" placeholder="Enter Password" style="width:80%; margin:10px auto;">
        <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px;">
            <button class="choice-btn" onclick="LOBBY.submitPassword()">Join</button>
            <button class="choice-btn" style="background:#444;" onclick="document.getElementById('password-modal').style.display='none'">Cancel</button>
        </div>
    </div>
</div>

<!-- SPLASH SCREEN (Preserved) -->
<div id="splash-screen">
    <h1 style="font-size: 8rem; color: #fff; text-shadow: 0 0 30px var(--gold-main); margin-bottom: 20px;">QUESTOPOLY</h1>
    <h2 style="color: #ddd; font-size: 2rem; margin-top: 0; margin-bottom: 50px; text-shadow: 2px 2px 5px #000;">LEGENDS</h2>
	
    
    <!-- UPDATED BUTTONS -->
    <div style="display:flex; flex-direction:column; gap:15px; align-items:center;">
        <button class="primary" style="font-size: 1.5rem; padding: 15px 40px; width: 300px; background:var(--gold-main); border:none; font-weight:900; cursor:pointer;" onclick="enterCreation(false)">SINGLE PLAYER</button>
        <button class="primary" style="font-size: 1.5rem; padding: 15px 40px; width: 300px; background:#3b82f6; border:2px solid #fff; color:#fff; font-weight:900; cursor:pointer;" onclick="LOBBY.enter()">MULTIPLAYER</button>
		<div id="start-profile-btn" class="profile-btn-floating" onclick="PROFILE.open()" style="display:none;"></div>
    </div>
    
    <div style="margin-top:20px; color:#aaa; cursor:pointer; text-decoration:underline;" onclick="AUTH.logout()">Log Out</div>
</div>

<!-- CREATE SCREEN (Preserved) -->
<div id="create-screen" style="display:none;">
    <div class="input-group"><label>Name Your Hero</label><input type="text" id="char-name-input" value="Hero" maxlength="12"></div>
    <div class="input-group"><label>Choose Color</label><div class="color-grid" id="color-grid"></div></div>
    <h3 style="color:#888;">Select Race</h3><div class="sel-grid" id="race-grid"></div>
    <h3 style="color:#888;">Select Class</h3><div class="sel-grid" id="class-grid"></div>
    <div id="active-section" style="display:none; width:100%; flex-direction:column; align-items:center;">
        <h3 style="color:#888;">Choose Active Skill</h3><div class="skill-grid" id="active-grid"></div>
    </div>
    <div id="passive-section" style="display:none; width:100%; flex-direction:column; align-items:center;">
        <h3 style="color:#888;">Choose Passive Trait</h3><div class="skill-grid" id="passive-grid"></div>
    </div>
    <button id="btn-start-game" class="primary" style="padding:15px 50px; font-size:1.5rem; background:var(--gold-main); border:none; font-weight:900; cursor:pointer; opacity:0.5;" onclick="startGame()" disabled>Start Adventure</button>
    <div style="height:50px;"></div>
    <div id="creator-portrait-frame"><button id="btn-min-portrait" class="minimize-btn" onclick="toggleCreatorPortrait()" style="position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.8); border: 1px solid var(--gold-main); color: var(--gold-main); z-index: 205; width: 20px; height: 30px; line-height: 28px; padding: 0;">-</button></div>
</div>

<!-- MAIN UI OVERLAY (REPLACED WITH NEW GLASS UI) -->
<div id="ui-layer">

    <!-- LEFT SIDEBAR: PLAYER SHEET -->
    <div id="p1-sheet" class="glass-panel gold-border">
        <div class="char-header">
            <div style="display:flex; align-items:center;">
                <div id="p1-portrait" class="char-portrait" onclick="openCharDetail(0)"></div>
                <div>
                    <div id="p1-name" style="font-weight:bold; cursor:pointer;" onclick="openCharDetail(0)">Hero</div>
                    <div id="p1-class" style="font-size:0.8rem; color:#aaa;">Class</div>
                </div>
            </div>
            <div class="gold-display"><span id="p1-gold">0</span> G</div>
        </div>
        <div class="stat-grid">
            <div class="stat-box"><div id="p1-str" class="stat-val">0</div><div class="stat-lbl">STR</div></div>
            <div class="stat-box"><div id="p1-dex" class="stat-val">0</div><div class="stat-lbl">DEX</div></div>
            <div class="stat-box"><div id="p1-int" class="stat-val">0</div><div class="stat-lbl">INT</div></div>
        </div>
<!-- Paper Doll -->
<div class="paper-doll-container">
    <div id="slot-head" class="doll-slot">HEAD</div>
    <div id="slot-body" class="doll-slot">BODY</div>
    <div id="slot-main" class="doll-slot">MAIN</div>
    <div id="slot-off" class="doll-slot">OFF</div>
</div>
        <div style="padding:0 10px; font-size:0.7rem; color:#888; margin-bottom:5px;">INVENTORY</div>
        <div id="p1-inv" class="inv-grid"></div>
        
        <!-- CLOSE BUTTON -->
        <button class="panel-close-btn" onclick="togglePanelVisibility('p1-sheet')">CLOSE</button>
    </div>

    <!-- CENTER BOARD AREA -->
    <div id="board-anchor">
        <div id="inner-zone">
            
            <!-- Turn Tracker -->
            <div id="turn-widget">
                <h2 id="turn-banner">SETUP</h2>
                <div id="day-night-indicator">â˜€ DAY</div>
            </div>

           <!-- TREASURY WIDGET (Top Left) -->
            <div id="treasury-widget">
                <div class="treasury-icon">ðŸ‘‘</div>
                <div id="treasury-val" class="treasury-amount">0</div>
                <div class="treasury-label">Treasury</div>
            </div>
			
			<!-- NEW: PLAYER STATS WIDGET (Top Right) -->
            <div id="mystats-widget">
                <div class="stat-row">
                    <span class="ms-icon">ðŸ’°</span> <span id="ms-gold" class="treasury-amount">0</span>
                </div>
                <div class="stat-row">
                    <span class="ms-icon">â›º</span> <span id="ms-camps" class="treasury-amount">0</span>
                </div>
                <div class="stat-row">
                    <span class="ms-icon">ðŸº</span> <span id="ms-taverns" class="treasury-amount">0</span>
                </div>
            </div>

            <!-- Adventure Log -->
            <div id="adventure-log-widget">
                <div id="game-log">
                    <div class="log-entry" style="text-align:center; color:#aaa;">- Log Start -</div>
                </div>
            </div>

            <!-- Skill Bar -->
            <div id="skill-bar-container">
                <div id="btn-action-container">
                    <button id="btn-action" onclick="handleActionClick()">ROLL</button>
                </div>
                <div id="skill-bar">
                    <div class="skill-slot" id="skill-0" onclick="useSkill(0)"><div class="skill-key">1</div><span id="txt-skill-0">Class</span></div>
                    <div class="skill-slot" id="skill-1" onclick="useSkill(1)"><div class="skill-key">2</div><span id="txt-skill-1">-</span></div>
                    <div class="skill-slot" id="skill-2" onclick="useSkill(2)"><div class="skill-key">3</div><span id="txt-skill-2">-</span></div>
                    <div class="spacer-slot"></div>
                    <div class="skill-slot" id="skill-3" onclick="useSkill(3)"><div class="skill-key">4</div><span id="txt-skill-3">-</span></div>
                    <div class="skill-slot" id="skill-4" onclick="useSkill(4)"><div class="skill-key">5</div><span id="txt-skill-4">-</span></div>
                    <div class="skill-slot" id="skill-5" onclick="useSkill(5)" ondragover="allowDrop(event)" ondrop="handleSkillDrop(event, 0)" style="border-style:dashed; opacity:0.6;"><div class="skill-key">6</div><span id="txt-skill-5">Drag</span></div>
                </div>
            </div>

            <!-- Utility Stack (OPEN BUTTONS) -->
            <div id="utility-stack">
                <div id="btn-help" class="util-btn" onclick="toggleHelpModal()">?</div>
                <div id="btn-settings" class="util-btn" onclick="toggleSettingsModal()">âš™</div>
                <!-- REMOVED 'mobile-toggle-btn' class so they show on desktop -->
                <div class="util-btn" onclick="togglePanelVisibility('p1-sheet')">ðŸ‘¤</div>
                <div class="util-btn" onclick="togglePanelVisibility('leaderboard')">ðŸ“œ</div>
            </div>

        </div>
    </div>

<!-- RIGHT SIDEBAR: LEADERBOARD -->
    <div id="leaderboard" class="glass-panel">
        <!-- ADDED class="leader-header" HERE: -->
        <div class="leader-header" style="padding:10px; background:rgba(0,0,0,0.3); border-bottom:1px solid #444; font-weight:bold; font-size:0.9rem; text-align:center;">
            LEADERBOARD
        </div>
        <div id="leader-list"></div>
        
        <!-- CLOSE BUTTON -->
        <button class="panel-close-btn" onclick="togglePanelVisibility('leaderboard')">CLOSE</button>
    </div>

</div>

<!-- NOTIFICATION LIST MODAL -->
<div id="notification-modal" class="modal-overlay" style="z-index: 9500;">
    <div class="modal-content" style="width: 400px;">
        <div class="close-x" onclick="document.getElementById('notification-modal').style.display='none'">Ã—</div>
        <h3 style="color:var(--gold-main); margin-top:15px; text-align:center;">NOTIFICATIONS</h3>
        <div style="padding:15px;">
            <button class="choice-btn" style="width:100%; text-align:center; margin-bottom:10px; padding:5px; font-size:0.8rem;" onclick="NOTIFICATIONS.clearAll()">Clear All</button>
            <div id="notification-list" style="max-height:300px; overflow-y:auto;">
                <!-- Items injected here -->
            </div>
        </div>
    </div>
</div>

<!-- TOOLTIP -->
<div id="tooltip"></div>
<div id="context-menu"></div>

<!-- MODALS (Using New Styles but preserving IDs) -->
<div id="card-modal" class="modal-overlay">
    <div class="card-modal" ondragover="allowDrop(event)" ondrop="handleSellDrop(event)">
        <div class="close-x" onclick="closeEnc()">Ã—</div>
        <div class="card-header" id="enc-header">Encounter</div>
        <div class="card-body">
            <h2 id="enc-title" style="margin:0 0 10px 0; color:var(--gold-main);">Title</h2>
            <p id="enc-desc" class="card-desc">...</p>
            <div id="market-sell-area" style="display:none; border:1px dashed #666; padding:15px; margin-bottom:15px; border-radius:8px; color:#aaa;">Drag items here to SELL</div>
            <div id="choice-list"></div>
            <div id="dice-result" class="dice-result"></div>
        </div>
    </div>
</div>

<div id="arrival-modal" class="card-modal" style="padding: 0; overflow: visible;">
    <button class="close-x" onclick="continueFromArrival()">Ã—</button>
    
    <!-- Wrapper for the visual border style -->
    <div class="card-border">
        <img id="arrival-image" src="" alt="Location Image" style="display:none;">
        <div class="card-body">
            <div id="arrival-flavor" class="flavor-text" style="font-style: italic; color: #fff;">...</div>
            <button class="primary" onclick="continueFromArrival()">CONTINUE</button>
        </div>
    </div>
</div>

<div id="char-detail-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="close-x" onclick="closeCharDetail()">Ã—</div>
        <div class="card-body">
            <div style="display:flex; align-items:center; margin-bottom:20px;">
                <div id="cd-portrait" class="char-portrait"></div>
                <div style="text-align:left;">
                    <div id="cd-header" style="font-weight:bold; font-size:1.2rem; color:var(--gold-main);">Name</div>
                    <div id="cd-sub" style="font-size:0.9rem; color:#aaa;">Class</div>
                </div>
            </div>
            
            <div style="display:flex; justify-content:space-around; background:#111; padding:10px; border-radius:8px; margin-bottom:15px;">
                <div style="text-align:center;">
                    <b id="cd-str" style="color:#fff; font-size:1.2rem;">0</b><br>
                    <small id="cd-lbl-str" style="color:#666">STR</small>
                </div>
                <div style="text-align:center;">
                    <b id="cd-dex" style="color:#fff; font-size:1.2rem;">0</b><br>
                    <small id="cd-lbl-dex" style="color:#666">DEX</small>
                </div>
                <div style="text-align:center;">
                    <b id="cd-int" style="color:#fff; font-size:1.2rem;">0</b><br>
                    <small id="cd-lbl-int" style="color:#666">INT</small>
                </div>
            </div>

            <div style="text-align:left; border-top:1px solid #333; padding-top:10px;">
                <div style="margin-bottom:10px;"><span style="color:var(--gold-main)">Active:</span> <span id="cd-active">-</span><div id="cd-active-desc" style="font-size:0.8rem; color:#666; font-style:italic;"></div></div>
                <div><span style="color:var(--accent-purple)">Passive:</span> <span id="cd-passive">-</span><div id="cd-passive-desc" style="font-size:0.8rem; color:#666; font-style:italic;"></div></div>
            </div>
            
            <!-- Injection point for dynamic stats from JS -->
            <div id="cd-extra-stats"></div>
            
            <div id="cd-inventory-section" style="display:none; margin-top:15px; border-top:1px solid #333; padding-top:10px;">
                <div class="paper-doll" style="margin-bottom:10px;">
                    <div id="cd-slot-head" class="equip-slot">Head</div>
                    <div id="cd-slot-body" class="equip-slot">Body</div>
                    <div id="cd-slot-main" class="equip-slot">Main</div>
                    <div id="cd-slot-off" class="equip-slot">Off</div>
                </div>
                <div id="cd-inv-grid" class="inv-grid"></div>
            </div>
            <div id="cd-hidden-msg" style="display:none; margin-top:20px; color:#555;">Inventory Hidden</div>
        </div>
    </div>
</div>

<!-- SETTINGS MODAL -->
<div id="settings-modal" class="modal-overlay">
    <div class="modal-content" style="width: 400px; max-width: 90%;">
        <button class="close-x" onclick="toggleSettingsModal()">Ã—</button>
        
        <!-- UPDATED LINE: Added onclick and cursor style -->
        <h2 style="color:var(--gold-main); margin-top:0; cursor:pointer; user-select:none;" onclick="handleSecretDebugTap()">SETTINGS</h2>
        
        <!-- Existing Volume Controls -->
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="color:#fff; display:block; margin-bottom:10px;">Music Volume</label>
            <input type="range" id="vol-bgm" min="0" max="1" step="0.1" value="0.4" style="width:100%; cursor:pointer;" oninput="AUDIO.setBGM(this.value)">
        </div>
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="color:#fff; display:block; margin-bottom:10px;">Sound Effects</label>
            <input type="range" id="vol-sfx" min="0" max="1" step="0.1" value="0.3" style="width:100%; cursor:pointer;" oninput="AUDIO.setSFX(this.value)">
        </div>

        <!-- NEW: DEBUG SECTION (Hidden by default) -->
        <div id="debug-controls" style="display:none; border-top: 1px solid #444; margin-top: 15px; padding-top: 10px; text-align:left;">
            <h3 style="color:#ef4444; font-size: 1rem;">DEV TOOLS: EVENTS</h3>
            <div id="debug-event-list" style="max-height: 200px; overflow-y: auto; display: grid; grid-template-columns: 1fr; gap: 5px;">
                <!-- Buttons will be injected here via JS -->
            </div>
        </div>

        <button class="choice-btn" style="width:100%; justify-content:center; margin-top:15px;" onclick="toggleSettingsModal()">Close</button>
    </div>
</div>

<!-- UPDATE: EXISTING SETTINGS MODAL -->
<div id="settings-modal" class="modal-overlay">
    <div class="modal-content" style="width: 400px; max-width: 90%;">
        <button class="close-x" onclick="toggleSettingsModal()">Ã—</button>
        <h2 style="color:var(--gold-main); margin-top:0; cursor:pointer; user-select:none;" onclick="handleSecretDebugTap()">SETTINGS</h2>
        
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="color:#fff; display:block; margin-bottom:10px;">Music Volume</label>
            <input type="range" id="vol-bgm" min="0" max="1" step="0.1" value="0.4" style="width:100%; cursor:pointer;" oninput="AUDIO.setBGM(this.value)">
        </div>
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="color:#fff; display:block; margin-bottom:10px;">Sound Effects</label>
            <input type="range" id="vol-sfx" min="0" max="1" step="0.1" value="0.3" style="width:100%; cursor:pointer;" oninput="AUDIO.setSFX(this.value)">
        </div>
        
        <!-- NEW: QUIT BUTTONS -->
        <hr style="border: 1px solid #333; margin: 20px 0;">
        <button class="choice-btn" style="width:100%; justify-content:center; background:#7f1d1d; border-color:#ef4444; margin-bottom:10px;" onclick="GAME_FLOW.requestQuit(false)">Quit to Main Menu</button>
        <button class="choice-btn" style="width:100%; justify-content:center; background:#450a0a; border-color:#991b1b;" onclick="GAME_FLOW.requestQuit(true)">Quit & Log Out</button>

        <div id="debug-controls" style="display:none; border-top: 1px solid #444; margin-top: 15px; padding-top: 10px; text-align:left;">
            <h3 style="color:#ef4444; font-size: 1rem;">DEV TOOLS: EVENTS</h3>
            <div id="debug-event-list" style="max-height: 200px; overflow-y: auto; display: grid; grid-template-columns: 1fr; gap: 5px;"></div>
        </div>
        
        <button class="choice-btn" style="width:100%; justify-content:center; margin-top:15px;" onclick="toggleSettingsModal()">Close Settings</button>
    </div>
</div>

<!-- NEW: CONFIRMATION MODAL -->
<div id="confirm-modal" class="modal-overlay">
    <div class="modal-content" style="width:350px; text-align:center;">
        <h3 style="color:var(--gold-main); margin-top:20px;">Are you sure?</h3>
        <p id="confirm-msg" style="color:#ccc; margin-bottom:20px;">Current game progress will be lost.</p>
        <div style="display:flex; justify-content:center; gap:15px; margin-bottom:20px;">
            <button id="btn-confirm-yes" class="choice-btn" style="background:#ef4444; width:100px; justify-content:center;">Yes</button>
            <button class="choice-btn" style="background:#444; width:100px; justify-content:center;" onclick="document.getElementById('confirm-modal').style.display='none'">No</button>
        </div>
    </div>
</div>

<div id="help-modal" class="modal-overlay">
    <div class="modal-content help-window">
        <button class="close-x" onclick="toggleHelpModal()">Ã—</button>
        
        <div class="help-header-title">ADVENTURER'S GUIDE</div>

        <!-- TABS NAVIGATION (Updated with data-tab attributes) -->
        <div class="help-tabs">
            <button class="help-tab active" onclick="switchHelpTab('tab-basics')" data-tab="tab-basics">Basics</button>
            <button class="help-tab" onclick="switchHelpTab('tab-combat')" data-tab="tab-combat">Conquest</button>
            <button class="help-tab" onclick="switchHelpTab('tab-upgrades')" data-tab="tab-upgrades">Upgrades</button>
            <button class="help-tab" onclick="switchHelpTab('tab-loot')" data-tab="tab-loot">Loot & Glory</button>
        </div>

        <!-- TAB 1: BASICS -->
        <div id="tab-basics" class="help-section active">
            <h3><span style="color:var(--gold)">âœ¦</span> The Objective</h3>
            <p>Be the last Hero standing! Bankrupt your rivals by capturing locations and hoarding Gold. When a player runs out of money and property, they are forgotten by history.</p>
            
            <h3><span style="color:var(--gold)">âœ¦</span> Movement & The Inn</h3>
            <p>Every journey begins at <b>Old Crooks Inn</b>. Roll <b>2d6</b> to move.</p>
            <ul>
                <li><b>Passing Start:</b> Gain <span style="color:var(--success)">+200 Gold</span> and recharge all abilities.</li>
                <li><b>Landing on Start:</b> Visit the Merchant to buy supplies. Long-press items in your inventory to sell them.</li>
            </ul>

            <h3><span style="color:var(--gold)">âœ¦</span> Mystery Spaces</h3>
            <p><b>Fairy Ring</b> and <b>Smuggler Cove</b> (Purple) are unstable locations. They cannot be captured.</p>
            <p>When you land here, you must face an Encounter. If you succeed, you are instantly <b>Teleported</b> to a random space on the board!</p>

            <h3><span style="color:var(--gold)">âœ¦</span> The Dungeon</h3>
            <p>If you land on "Go to Dungeon," you are arrested! You must <b>Skip your next turn</b>. If you land on the Dungeon space itself (Just Visiting), you are safe.</p>
        </div>

        <!-- TAB 2: CONQUEST -->
        <div id="tab-combat" class="help-section">
            <h3><span style="color:var(--gold)">âœ¦</span> Empty Lands</h3>
            <p>When you discover a new location, you draw an <b>Encounter Card</b>. You must pass a Stat Check (Str, Dex, or Int) to save the town.</p>
            <ul>
                <li><b>Success:</b> You capture the location and set up Camp. You must then assign a <b>Defending Stat</b> (STR, DEX, or INT) to protect the land.</li>
                <li><b>Failure:</b> You pay a fine to the Treasury (Capital City) to repair damages.</li>
            </ul>

            <h3><span style="color:var(--gold)">âœ¦</span> Enemy Lands</h3>
            <p>If you land on a space owned by a rival, you have two choices:</p>
            <ol>
                <li><b>Pay Rent:</b> Pay the fee directly to the owner.</li>
                <li><b>Siege (Attack):</b> Attempt to steal the land! You must roll against the location's assigned <b>Defending Stat</b>.
                    <ul>
                        <li><b>Win Siege:</b> You take the land (or kill a guard).</li>
                        <li><b>Lose Siege:</b> You pay <b>DOUBLE</b> the rent to the owner.</li>
                    </ul>
                </li>
            </ol>
        </div>

        <!-- TAB 3: UPGRADES -->
        <div id="tab-upgrades" class="help-section">
            <h3><span style="color:var(--gold)">âœ¦</span> Building Taverns</h3>
            <p>If you land on a location you already own, you can upgrade your Camp into a <b>Tavern</b>.</p>
            <p>Taverns force enemies to draw harder <b>Skirmish Cards</b> when attacking.</p>

            <h3><span style="color:var(--gold)">âœ¦</span> Guards</h3>
            <p>Owners of a Tavern can hire <b>Bodyguards</b> for <span style="color:var(--gold)">50G</span> each.</p>
            <p>If an enemy successfully Sieges your land, a Guard dies to protect the property. You only lose the property if there are no Guards left.</p>
        </div>

        <!-- TAB 4: LOOT -->
        <div id="tab-loot" class="help-section">
            <h3><span style="color:var(--gold)">âœ¦</span> Treasure</h3>
            <p>Items range from <span style="color:#fff">Common</span>, <span style="color:var(--rare)">Magic</span>, <span style="color:var(--epic)">Rare</span>, to <span style="color:var(--legend)">Legendary</span>.</p>
            <p>Some items grant passive stat bonuses, while others provide active skills. <b>Scrolls</b> (like Town Portals) are one-time use.</p>

            <h3><span style="color:var(--gold)">âœ¦</span> Capital City</h3>
            <p>Taxes collected from the Tax spaces and fines from failed captures are stored in the Kingdom's Treasury.</p>
            <p><b>Landing on Capital City</b> awards you the entire contents of the Treasury!</p>
        </div>

        <div style="text-align: center; margin-top: auto; padding: 15px; border-top: 1px solid #444; background: #111;">
            <button class="primary" onclick="toggleHelpModal()">Return to Game</button>
        </div>
    </div>
</div>

<div id="game-over-modal" class="modal-overlay">
    <div class="modal-content">
        <h1 id="go-title" style="font-size:3rem; margin:20px 0; text-shadow:0 0 10px #000;">GAME OVER</h1>
        <p id="go-msg" style="color:#ccc;">...</p>
        <div id="go-stats" style="text-align:left; padding:20px; background:#111; margin:20px 0; border-radius:8px;"></div>
        <div id="graph-legend" style="display:flex; justify-content:center; gap:10px; margin-bottom:10px;"></div>
        <div id="graph-container" style="display:none; width:100%; height:200px; background:#222; border:1px solid #444;">
            <canvas id="game-chart"></canvas>
        </div>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button class="choice-btn" onclick="toggleGraph()">View Graph</button>
            <button class="choice-btn" style="background:var(--gold-dim);" onclick="resetGame()">PLAY AGAIN</button>
        </div>
        <div style="display:none;"><input type="checkbox" id="chk-gold" checked><input type="checkbox" id="chk-props" checked></div>
    </div>
</div>

<div id="bankruptcy-modal" class="modal-overlay">
    <div class="modal-content" style="border-color:var(--accent-red);">
        <h1 style="color:var(--accent-red); margin:20px 0;">DEBT!</h1>
        <p>You owe <span id="debt-amount" style="color:#fff; font-weight:bold;">0</span> G</p>
        <div id="debt-prop-list" style="padding:10px; background:#111; max-height:200px; overflow-y:auto; margin-bottom:20px;"></div>
        <button id="btn-debt-done" class="choice-btn" style="width:100%; justify-content:center;" onclick="checkDebtCleared()" disabled>Pay & Continue</button>
    </div>
</div>

<!-- DEBUG CONSOLE -->
<div id="debug-console" style="display:none;">
    <div style="color:#0f0; font-family:monospace; font-size:14px; margin-bottom:5px;">> DEV CONSOLE</div>
    <input type="text" id="console-input" placeholder="Type command..." autocomplete="off">
</div>

<!-- REAL-TIME DEBUG LOG -->
<div id="debug-log-overlay" style="display:none;">
    <!-- Replaced inline style with class 'debug-header' -->
    <div class="debug-header">
        <span>SYSTEM LOG</span>
        <div style="display:flex; align-items:center;">
            <button id="btn-copy-log" onclick="copyDebugLog()">COPY</button>
            <!-- NEW MINIMIZE BUTTON -->
            <button id="btn-min-log" onclick="toggleDebugLog()">_</button>
        </div>
    </div>
    <div id="debug-log-content"></div>
</div>

<!-- STORE MODAL -->
<div id="store-modal" class="modal-overlay">
    <div class="modal-content" style="width: 450px; text-align:center;">
        <div class="close-x" onclick="document.getElementById('store-modal').style.display='none'">Ã—</div>
        <h2 style="color:var(--gold-main); margin-top:20px;">PREMIUM STORE</h2>
        
        <div style="padding: 20px;">
            
<!-- OPTION 1: REMOVE ADS -->
<div class="choice-btn" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; padding:20px; cursor:default; background:#1a202c; border-color:#10b981;">
    <div style="text-align:left;">
        <div style="color:#10b981; font-weight:bold; font-size:1.1rem;">REMOVE ADS</div>
        <div style="font-size:0.8rem; color:#aaa;">Permanently remove all ads</div>
    </div>
    
    <!-- FIXED: Added missing ' after the URL -->
    <button class="auth-btn btn-login" style="width:auto; padding:10px 20px; margin:0; background:#10b981; color:#fff;" 
        onclick="window.open('https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=3NNGM4THBVXPL', '_blank')">
        $3.00
    </button>
</div>

<!-- OPTION 2: SUPPORT / DONATE -->
<div class="choice-btn" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; padding:20px; cursor:default; background:#1a202c; border-color:#f59e0b;">
    <div style="text-align:left;">
        <div style="color:#f59e0b; font-weight:bold; font-size:1.1rem;">SUPPORT DEV</div>
        <div style="font-size:0.8rem; color:#aaa;">Buy the dev a coffee! â˜•</div>
    </div>
    
    <!-- FIXED: Added missing ' after the URL -->
    <button class="auth-btn btn-login" style="width:auto; padding:10px 20px; margin:0;" 
        onclick="window.open('https://ko-fi.com/deathforgegames', '_blank')">
        Donate
    </button>
</div>

            <div style="border-top:1px solid #333; margin-top:15px; padding-top:15px;">
                <p style="font-size:0.8rem; color:#888;">Already purchased?</p>
                <button class="choice-btn" style="width:100%; justify-content:center; padding:10px;" onclick="STORE.restorePurchase()">
                    â†» Restore Purchase / Check Status
                </button>
            </div>

        </div>
    </div>
</div>

        <!-- PayPal Button will appear here -->
        <div id="paypal-button-container" style="margin-top: 10px;"></div>
        
        <div style="font-size:0.7rem; color:#666; margin-top:10px;">One-time purchase of $3.00</div>
    </div>
</div>

<!-- PROFILE MODAL -->
<div id="profile-modal" class="modal-overlay">
    <div class="modal-content" style="width: 500px;">
        <!-- Header / Close / Password -->
        <div class="close-x" onclick="document.getElementById('profile-modal').style.display='none'">Ã—</div>
        <div style="position:absolute; top:15px; left:15px; font-weight:bold; color:var(--gold-main);">PROFILE</div>
        <button style="position:absolute; top:10px; right:50px; background:transparent; border:none; color:#aaa; cursor:pointer;" onclick="PROFILE.changePassword()">âš™ Password</button>
        
        <!-- Main Body -->
        <div style="padding:20px; margin-top:30px;">
            
            <!-- Top Section: Avatar & Details -->
            <div class="profile-layout">
                <!-- Left Column: Avatar Display & Save -->
                <div class="profile-left">
                    <div id="prof-avatar-display" class="profile-avatar-lg"></div>
                    <button class="choice-btn" style="padding:5px; font-size:0.7rem; width:100%;" onclick="PROFILE.save()">Save Profile</button>
                </div>

                <!-- Right Column: Inputs -->
                <div class="profile-right">
                    <!-- Static Account Name (Email) -->
                    <div style="margin-bottom:5px;">
                        <div class="profile-label">Account</div>
                        <div id="prof-username" style="font-weight:bold; font-size:0.9rem; color:#888;">-</div>
                    </div>

                    <!-- NEW: Display Name Field -->
                    <div style="margin-bottom:10px;">
                        <div class="profile-label">Display Name</div>
                        <input type="text" id="prof-display-name" class="auth-input" style="padding:8px; margin:0; border-color:var(--gold-main);" placeholder="Enter Name">
                    </div>

                    <!-- Avatar URL Input -->
                    <div style="margin-bottom:10px;">
                        <div class="profile-label">Avatar URL</div>
                        <input type="text" id="prof-avatar-input" class="auth-input" style="padding:5px; margin:0;" placeholder="https://example.com/image.png">
                    </div>

                    <!-- About Me -->
                    <div>
                        <div class="profile-label">About Me</div>
                        <textarea id="prof-about" class="profile-textarea" placeholder="Tell us your legend..."></textarea>
                    </div>
                </div>
            </div>
            
            <!-- Bottom Section: Friends -->
            <div style="margin-top:20px; border-top:1px solid #444; padding-top:10px;">
                
                <!-- Pending Friend Requests (Hidden by default, shown via JS) -->
                <div id="pending-requests-container" style="display:none; margin-bottom:15px;">
                    <div style="color:var(--gold-glow); font-size:0.8rem; margin-bottom:5px; font-weight:bold;">PENDING REQUESTS</div>
                    <div id="pending-requests-list"></div>
                </div>
                
                <!-- Friends List Header -->
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="color:var(--gold-main);">FRIENDS LIST</span>
                    <button class="choice-btn" style="padding:5px 10px; width:auto; margin:0;" onclick="FRIENDS.showAddModal()">+ Add Friend</button>
                </div>

                <!-- Friends List Container -->
                <div id="profile-friends-list" class="friend-list"></div>
            </div>
        </div>
    </div>
</div>

<!-- ADD FRIEND MODAL -->
<div id="add-friend-modal" class="modal-overlay" style="z-index: 6000;">
    <div class="modal-content" style="width: 300px; text-align:center;">
        <h3>Add Friend</h3>
        <input type="email" id="friend-email-input" class="auth-input" placeholder="Friend's Email">
        <div style="display:flex; gap:10px; justify-content:center;">
            <button class="choice-btn" onclick="FRIENDS.addFriend()">Add</button>
            <button class="choice-btn" style="background:#444;" onclick="document.getElementById('add-friend-modal').style.display='none'">Cancel</button>
        </div>
    </div>
</div>

<!-- INVITE FRIEND MODAL -->
<div id="invite-modal" class="modal-overlay" style="z-index: 6000;">
    <div class="modal-content" style="width: 350px;">
        <div class="close-x" onclick="document.getElementById('invite-modal').style.display='none'">Ã—</div>
        <h3 style="text-align:center; color:var(--gold-main);">Invite Friend</h3>
        <div id="invite-list" class="friend-list" style="height:250px;"></div>
    </div>
</div>

<!-- FRIEND DROPDOWN MENU -->
<div id="friend-context-menu" class="friend-dropdown">
    <div class="ctx-item" onclick="FRIENDS.actionMessage()">Message</div>
    <div class="ctx-item" onclick="FRIENDS.actionSettings()">Friend Settings</div>
    <div class="ctx-item" onclick="FRIENDS.actionRemove()" style="color:#ef4444;">Remove Friend</div>
</div>

<!-- MAP VIEW MODAL -->
<div id="map-modal" class="modal-overlay" onclick="this.style.display='none'" style="z-index: 5000;">
    <div class="modal-content" style="background: transparent; border: none; box-shadow: none; width: 95%; max-width: 800px; pointer-events: none;">
        <img src="https://static.wixstatic.com/media/b16479_5caac3525f59406d8ff175695ef11cb1~mv2.jpg" style="width:100%; border: 3px solid var(--gold-main); border-radius: 12px; pointer-events: auto;">
        <button class="choice-btn" style="margin-top: 10px; pointer-events: auto; justify-content: center;">Close Map</button>
    </div>
</div>

<!-- FRIEND SETTINGS MODAL -->
<div id="friend-settings-modal" class="modal-overlay" style="z-index: 7500;">
    <div class="modal-content" style="width: 350px;">
        <div class="close-x" onclick="document.getElementById('friend-settings-modal').style.display='none'">Ã—</div>
        <h3 style="text-align:center; color:var(--gold-main); margin-top:15px;">Friend Settings</h3>
        <p id="fs-target-name" style="text-align:center; color:#aaa; margin-bottom:15px;"></p>
        
        <div style="padding:10px;">
            <div class="setting-row">
                <label>Block Direct Messages</label>
                <input type="checkbox" id="fs-block-dm" class="toggle-chk">
            </div>
            <div class="setting-row">
                <label>Hide Online Status</label>
                <input type="checkbox" id="fs-hide-status" class="toggle-chk">
            </div>
            <div class="setting-row">
                <label>Block Game Invites</label>
                <input type="checkbox" id="fs-block-invite" class="toggle-chk">
            </div>
        </div>
        
        <div style="padding:15px; text-align:center;">
            <button class="choice-btn" style="width:100%; justify-content:center;" onclick="FRIENDS.saveSettings()">Save Settings</button>
        </div>
    </div>
</div>

<!-- DIRECT MESSAGE WINDOW (Draggable) -->
<div id="dm-window" class="glass-panel gold-border">
    <div class="dm-header">
        <span id="dm-title">Chat</span>
        <span style="cursor:pointer;" onclick="DM.close()">Ã—</span>
    </div>
    <div id="dm-body" class="dm-body"></div>
    <div class="chat-input-row">
        <input type="text" id="dm-input" class="chat-input" placeholder="Message..." onkeydown="if(event.key==='Enter') DM.send()">
        <button class="chat-send" onclick="DM.send()">â†’</button>
    </div>
</div>

<!-- UPDATE: FRIEND DROPDOWN MENU (Add Settings Option) -->
<div id="friend-context-menu" class="friend-dropdown">
    <div class="ctx-item" onclick="FRIENDS.actionMessage()">Message</div>
    <div class="ctx-item" onclick="FRIENDS.actionInvite()">Invite to Game</div>
    <div class="ctx-item" onclick="FRIENDS.actionSettings()">Friend Settings</div>
    <div class="ctx-item" onclick="FRIENDS.actionRemove()" style="color:#ef4444;">Remove Friend</div>
</div>
</div> 

<!-- PayPal SDK -->
<script src="https://www.paypal.com/sdk/js?client-id=YOUR_CLIENT_ID&currency=USD"></script>

<div id="ad-container">
    <div id="google-ad-slot" style="width:100%; height:100%; display:flex; justify-content:center; align-items:center; color:#aaa; font-size:0.8rem;">
        <!-- Google Ad Code Will Go Here -->
        <span><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8171909770069568"
     crossorigin="anonymous"></script>
<!-- Game_Bottom_Bar -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8171909770069568"
     data-ad-slot="5677565528"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></span>
    </div>
</div>

<!-- BUG REPORT MODAL -->
<div id="bug-report-modal" class="modal-overlay">
    <div class="modal-content" style="width: 400px; text-align:center;">
        <div class="close-x" onclick="document.getElementById('bug-report-modal').style.display='none'">Ã—</div>
        <h3 style="color:#ef4444; margin-top:20px;">REPORT A BUG</h3>
        
        <div style="padding:15px; text-align:left;">
            <label style="color:#aaa; font-size:0.8rem;">Describe the issue:</label>
            <textarea id="bug-description" style="width:100%; height:120px; background:rgba(0,0,0,0.5); border:1px solid #444; color:#fff; padding:10px; margin-top:5px; resize:none; border-radius:4px;" placeholder="What happened? What were you doing?"></textarea>
            
            <p style="color:#666; font-size:0.75rem; margin-top:10px;">
                * Pressing send will open your default email client with your User ID attached so we can investigate.
            </p>
        </div>

        <button class="choice-btn" style="width:100%; justify-content:center; border-color:#ef4444;" onclick="BUG_REPORT.send()">
            SEND REPORT
        </button>
    </div>
</div>
<!-- ================================================================
   [06] JAVASCRIPT
   ================================================================ -->
   <script>
   
   // --- FIREBASE CONFIG (PASTE YOURS HERE) ---
const firebaseConfig = {
  apiKey: "AIzaSyBkx1gRLTNqO2kXrqopf0mkLOjzIrV8ftY",
  authDomain: "questopoly-507b9.firebaseapp.com",
  databaseURL: "https://questopoly-507b9-default-rtdb.firebaseio.com",
  projectId: "questopoly-507b9",
  storageBucket: "questopoly-507b9.firebasestorage.app",
  messagingSenderId: "943879074552",
  appId: "1:943879074552:web:5a74588c83cc40a297010d",
  measurementId: "G-H66SGB22EH"
};

// Initialize Firebase
let app, db, auth;
if(firebaseConfig.apiKey) {
    app = firebase.initializeApp(firebaseConfig);
    db = firebase.database();
    auth = firebase.auth();
} else {
    console.error("FIREBASE CONFIG MISSING! Multiplayer will not work.");
}

// --- MULTIPLAYER GLOBALS ---
let isMultiplayer = false;
let myPlayerId = 0; 
let gameId = null;
let currentUser = null;
let currentRoomData = null; // Stores real-time room data
let pendingJoinId = null;
let isAdminMode = false;
let listenersActive = false;

// --- GAME FLOW CONTROL ---
const GAME_FLOW = {
    requestQuit: function(logout) {
        // Close settings
        document.getElementById('settings-modal').style.display = 'none';
        
        // Show confirmation
        const modal = document.getElementById('confirm-modal');
        const btnYes = document.getElementById('btn-confirm-yes');
        const msg = document.getElementById('confirm-msg');
        
        msg.innerText = logout ? "Quit game and Log Out?" : "Quit to Main Menu?";
        
        // Set the Yes button action
        btnYes.onclick = () => this.performQuit(logout);
        
        modal.style.display = 'flex';
    },
    
performQuit: function(logout) {
        document.getElementById('confirm-modal').style.display = 'none';
        
        // 1. Reset Game State
        gameState = 'SETUP';
        players.forEach(p => { if(p.mesh) scene.remove(p.mesh); });
        players = [];
        activeEvent = null;
        
        // 2. Hide Game UI
        document.getElementById('gameroom-screen').style.display = 'none';
        document.getElementById('create-screen').style.display = 'none';
        document.getElementById('game-over-modal').style.display = 'none';
        
        // --- 3. CLEAN UP LISTENERS ---
        if(isMultiplayer && gameId && db) {
            // Detach all listeners for this game ID
            db.ref(`games/${gameId}`).off();
            db.ref(`games/${gameId}/turnIndex`).off();
            db.ref(`games/${gameId}/currentMove`).off();
            db.ref(`games/${gameId}/board`).off();
            db.ref(`games/${gameId}/players`).off();
            
            if(myPlayerId !== 0) {
                 // Remove self if client
                 db.ref(`games/${gameId}/slots/${myPlayerId}`).set({type:'open'});
            }
        }
        
        // RESET FLAG
        listenersActive = false;
        
        // 4. Handle Logout or Return
        if(logout) {
            AUTH.logout();
        } else {
            document.getElementById('splash-screen').style.display = 'flex';
            document.getElementById('splash-screen').style.opacity = '1';
            resetCamera();
            addLog("Returned to Main Menu.");
        }
    }
};

// --- AUTH SYSTEM ---
const AUTH = {
    init: function() {
        if(!auth) return;
        auth.onAuthStateChanged(user => {
            currentUser = user;
            if(user) {
                // 1. INITIALIZE NOTIFICATIONS & SHOW BELL
                if (typeof NOTIFICATIONS !== 'undefined') {
                    NOTIFICATIONS.init();
                    const bell = document.getElementById('global-notify-btn');
                    if(bell) bell.style.display = 'flex'; 
                }

                // 2. PRESENCE SYSTEM (Online/Offline Status)
                const userRef = db.ref(`users/${user.uid}`);
                const amOnline = db.ref('.info/connected');
                
                amOnline.on('value', (snapshot) => {
                    if (snapshot.val() == false) return;
                    
                    userRef.onDisconnect().update({ status: 'offline' }).then(() => {
                        userRef.update({ 
                            status: 'online',
                            name: user.email.split('@')[0], // Default name fallback
                            email: user.email
                        });
                    });
                });

                // 3. LOAD PROFILE BUTTONS (Start Screen & Lobby)
                const profBtn = document.getElementById('start-profile-btn');
                if(profBtn) {
                     profBtn.style.display = 'block'; // Show profile button
                     
                     // Fetch Avatar URL
                     userRef.child('avatar').once('value').then(s => {
                         if(s.val()) {
                             const url = `url('${s.val()}')`;
                             profBtn.style.backgroundImage = url;
                             const lobbyBtn = document.getElementById('lobby-profile-btn');
                             if(lobbyBtn) lobbyBtn.style.backgroundImage = url;
                         }
                     });
                }
                
                // 4. UI TRANSITION
                // Hide login screen
                document.getElementById('auth-screen').style.display = 'none';
                
                // Trigger the main menu animation (Logo fade -> Splash)
                if(window.triggerGameMenu) window.triggerGameMenu();

            } else {
                // --- LOGGED OUT STATE ---
                document.getElementById('auth-screen').style.display = 'flex';
                document.getElementById('logo-screen').style.display = 'none';
                document.getElementById('splash-screen').style.display = 'none';
                
                // Hide Notification Bell
                const bell = document.getElementById('global-notify-btn');
                if(bell) bell.style.display = 'none';
            }
			STORE.checkOnLogin(); 
        });
    },
    login: function() {
        const e = document.getElementById('auth-email').value;
        const p = document.getElementById('auth-pass').value;
        auth.signInWithEmailAndPassword(e, p).catch(err => document.getElementById('auth-msg').innerText = err.message);
    },
    register: function() {
        const e = document.getElementById('auth-email').value;
        const p = document.getElementById('auth-pass').value;
        auth.createUserWithEmailAndPassword(e, p).then(cred => {
            cred.user.sendEmailVerification();
            alert("Account created! Please check your email to verify, then log in.");
            auth.signOut(); 
            location.reload();
        }).catch(err => document.getElementById('auth-msg').innerText = err.message);
    },
    recover: function() {
        const e = document.getElementById('auth-email').value;
        if(!e) { alert("Enter email first."); return; }
        auth.sendPasswordResetEmail(e).then(()=>alert("Reset email sent.")).catch(err=>alert(err.message));
    },
    logout: function() { auth.signOut().then(() => location.reload()); }
};

const STORE = {
    open: function() {
        if (!currentUser) {
            alert("Please log in to access the store.");
            return;
        }
        
        // Check if already premium
        db.ref(`users/${currentUser.uid}/isPremium`).once('value').then(snap => {
            if (snap.val() === true) {
                alert("You already own Premium! Ads are removed.");
            } else {
                document.getElementById('store-modal').style.display = 'flex';
            }
        });
    },

    // This function manually checks the DB again to see if status changed
    restorePurchase: function() {
        if (!currentUser) return;
        
        // Show loading state
        const btn = event.target;
        const originalText = btn.innerText;
        btn.innerText = "Checking...";
        
        db.ref(`users/${currentUser.uid}/isPremium`).once('value').then(snap => {
            if (snap.val() === true) {
                alert("Premium Verified! Ads removed.");
                this.applyPremiumFeatures();
                document.getElementById('store-modal').style.display = 'none';
            } else {
                alert("No premium purchase found yet. If you just paid, please wait a moment or contact support.");
            }
            btn.innerText = originalText;
        });
    },

    applyPremiumFeatures: function() {
        document.body.classList.add('premium-user');
        setTimeout(() => { onWindowResize(); }, 100);
    },
    
    checkOnLogin: function() {
        if (!currentUser) return;
        db.ref(`users/${currentUser.uid}/isPremium`).once('value').then(snap => {
            if (snap.val() === true) this.applyPremiumFeatures();
            else {
                document.body.classList.remove('premium-user');
                onWindowResize();
            }
        });
    }
};

// --- PROFILE SYSTEM ---
const PROFILE = {
    open: function() {
        // 1. Check if user is logged in
        if(!currentUser) {
            // New: Give feedback instead of doing nothing
            alert("Please log in to view your profile.");
            // Optional: Re-open auth screen if they are stuck
            document.getElementById('auth-screen').style.display = 'flex';
            return;
        }

        // 2. Open the modal
        document.getElementById('profile-modal').style.display = 'flex';
        
        // 3. Fetch data from Firebase
        db.ref(`users/${currentUser.uid}`).once('value').then(snap => {
            const data = snap.val() || {};
            
            // Set Username
            const nameLabel = document.getElementById('prof-username');
            if(nameLabel) nameLabel.innerText = data.displayName || data.name || "Hero";

            // Populate Inputs
            const nameInput = document.getElementById('prof-display-name');
            if(nameInput) nameInput.value = data.displayName || "";
            
            const avatarInput = document.getElementById('prof-avatar-input');
            if(avatarInput) avatarInput.value = data.avatar || "";
            
            const aboutInput = document.getElementById('prof-about');
            if(aboutInput) aboutInput.value = data.about || "";

            // Update Avatar Preview
            const avatarDisplay = document.getElementById('prof-avatar-display');
            if(avatarDisplay) {
                avatarDisplay.style.backgroundImage = data.avatar ? `url('${data.avatar}')` : 'none';
                avatarDisplay.style.backgroundColor = data.avatar ? 'transparent' : '#000';
            }
            
            // Load Friends
            FRIENDS.renderList('profile-friends-list');
        });
    },

    save: function() {
        if(!currentUser) return;
        
        // Get values from inputs
        const avatar = document.getElementById('prof-avatar-input').value.trim();
        const about = document.getElementById('prof-about').value.trim();
        const dName = document.getElementById('prof-display-name').value.trim();
        
        // Prepare update object
        const updates = {
            avatar: avatar,
            about: about,
            displayName: dName // Explicitly save display name
        };
        
        // Update Database
        db.ref(`users/${currentUser.uid}`).update(updates).then(() => {
            alert("Profile Saved!");
            
            // Update visual elements immediately
            document.getElementById('prof-avatar-display').style.backgroundImage = avatar ? `url('${avatar}')` : 'none';
            document.getElementById('prof-username').innerText = dName || "Hero";
            
            // Update Floating Buttons
            const floatBtn = document.getElementById('start-profile-btn');
            const lobbyBtn = document.getElementById('lobby-profile-btn');
            if(floatBtn && avatar) floatBtn.style.backgroundImage = `url('${avatar}')`;
            if(lobbyBtn && avatar) lobbyBtn.style.backgroundImage = `url('${avatar}')`;

            // If we are currently in a Multiplayer Game Lobby, update our slot there too
            if(isMultiplayer && gameId && myPlayerId !== null) {
                const nameUpdate = dName || currentUser.email.split('@')[0];
                db.ref(`games/${gameId}/slots/${myPlayerId}`).update({ 
                    name: nameUpdate,
                    color: avatar ? 'transparent' : selColor 
                });
            }
        });
    },

    changePassword: function() {
        const email = currentUser.email;
        if(confirm(`Send password reset email to ${email}?`)) {
            auth.sendPasswordResetEmail(email)
                .then(() => alert(`Reset email sent! Check your inbox.`))
                .catch(e => alert(e.message));
        }
    }
};

// --- FRIENDS SYSTEM ---
let selectedFriendUid = null;

const FRIENDS = {
    showAddModal: function() {
        document.getElementById('add-friend-modal').style.display = 'flex';
    },

    addFriend: function() {
        const email = document.getElementById('friend-email-input').value.trim();
        if(!email) return;
        
        db.ref('users').orderByChild('email').equalTo(email).once('value').then(snap => {
            if(snap.exists()) {
                const targetUid = Object.keys(snap.val())[0];
                if(targetUid === currentUser.uid) { alert("You cannot add yourself."); return; }
                
                db.ref(`users/${currentUser.uid}/friends/${targetUid}`).once('value').then(fSnap => {
                    if(fSnap.exists()) {
                        alert("Already friends!");
                    } else {
                        const myName = currentUser.email.split('@')[0];
                        db.ref(`users/${targetUid}/friend_requests/${currentUser.uid}`).set({
                            name: myName,
                            email: currentUser.email
                        });
                        alert("Friend Request Sent!");
                        document.getElementById('add-friend-modal').style.display = 'none';
                    }
                });
            } else {
                alert("User not found.");
            }
        });
    },

    renderList: function(containerId, isInviteMode = false) {
        const list = document.getElementById(containerId);
        list.innerHTML = 'Loading...';
        
        if(!isInviteMode) this.renderRequests();

        db.ref(`users/${currentUser.uid}/friends`).once('value').then(snap => {
            const friends = snap.val();
            list.innerHTML = '';
            
            if(!friends) { list.innerHTML = '<div style="padding:10px; color:#666;">No friends yet.</div>'; return; }
            
            Object.keys(friends).forEach(uid => {
                db.ref(`users/${uid}`).once('value').then(uSnap => {
                    const uData = uSnap.val();
                    if(!uData) return;
                    
                    // --- PRIVACY CHECK (Online Status) ---
                    // Check if *THEY* have hidden their status from *ME*
                    // Path: users/{THEIR_ID}/relationships/{MY_ID}/hideStatus
                    db.ref(`users/${uid}/relationships/${currentUser.uid}/hideStatus`).once('value').then(permSnap => {
                        const isHidden = permSnap.val() === true;
                        
                        // If hidden, force offline. If not hidden, use real status.
                        const isOnline = !isHidden && (uData.status === 'online');
                        
                        const div = document.createElement('div');
                        div.className = 'friend-item';
                        
                        let avatarStyle = uData.avatar ? `background-image:url('${uData.avatar}')` : `background-color:#444`;
                        const dName = uData.displayName || uData.name || "Unknown";
                        
                        div.innerHTML = `
                            <div class="friend-info">
                                <div class="friend-avatar" style="${avatarStyle}"></div>
                                <div>
                                    <div style="font-weight:bold; color:var(--gold-main)">${dName}</div>
                                    <div style="font-size:0.7rem; color:#aaa;">${isOnline ? 'Online' : 'Offline'}</div>
                                </div>
                            </div>
                            <div class="online-dot ${isOnline ? 'online' : ''}"></div>
                        `;
                        
                        if(isInviteMode) {
                            div.onclick = () => {
                                // Check if they blocked invites
                                db.ref(`users/${uid}/relationships/${currentUser.uid}/blockInvite`).once('value').then(bSnap => {
                                    if(bSnap.val() === true) {
                                        alert("This user is not accepting invites from you.");
                                    } else {
                                        ROOM.sendInvite(uid, dName);
                                        document.getElementById('invite-modal').style.display='none';
                                    }
                                });
                            };
                        } else {
                            // CONTEXT MENU LOGIC
                            const handleMenu = (e) => {
                                e.preventDefault(); 
                                this.openMenu(e, uid, dName);
                            };
                            
                            div.oncontextmenu = handleMenu;
                            
                            // Mobile Long Press
                            let pressTimer;
                            div.ontouchstart = (e) => {
                                pressTimer = setTimeout(() => handleMenu(e.touches[0]), 600);
                            };
                            div.ontouchend = () => clearTimeout(pressTimer);
                            div.ontouchmove = () => clearTimeout(pressTimer);

                            // Left click -> Message
                            div.onclick = () => DM.open(uid, dName);
                        }
                        
                        list.appendChild(div);
                    });
                });
            });
        });
    },

    renderRequests: function() {
        const container = document.getElementById('pending-requests-container');
        const list = document.getElementById('pending-requests-list');
        
        db.ref(`users/${currentUser.uid}/friend_requests`).once('value').then(snap => {
            if(!snap.exists()) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';
            list.innerHTML = '';
            
            const reqs = snap.val();
            Object.keys(reqs).forEach(uid => {
                const req = reqs[uid];
                const div = document.createElement('div');
                div.className = 'request-item';
                div.innerHTML = `
                    <span>${req.name}</span>
                    <div class="req-actions">
                        <button class="req-btn" style="background:#10b981; color:#fff;" onclick="FRIENDS.acceptRequest('${uid}')">âœ”</button>
                        <button class="req-btn" style="background:#ef4444; color:#fff;" onclick="FRIENDS.denyRequest('${uid}')">âœ–</button>
                    </div>
                `;
                list.appendChild(div);
            });
        });
    },

    acceptRequest: function(uid) {
        db.ref(`users/${currentUser.uid}/friends/${uid}`).set(true);
        db.ref(`users/${uid}/friends/${currentUser.uid}`).set(true);
        this.denyRequest(uid); 
    },

    denyRequest: function(uid) {
        db.ref(`users/${currentUser.uid}/friend_requests/${uid}`).remove().then(() => {
            this.renderList('profile-friends-list'); 
            this.checkNotifications();
        });
    },

    checkNotifications: function() {
        if(!currentUser) return;
        db.ref(`users/${currentUser.uid}/friend_requests`).on('value', snap => {
            const count = snap.numChildren();
            const profBtns = [document.getElementById('start-profile-btn'), document.getElementById('lobby-profile-btn')];
            profBtns.forEach(btn => {
                if(!btn) return;
                let b = btn.querySelector('.notify-badge');
                if(count > 0) {
                    if(!b) {
                        b = document.createElement('div');
                        b.className = 'notify-badge';
                        btn.appendChild(b);
                    }
                    b.innerText = count;
                    b.style.display = 'flex';
                } else {
                    if(b) b.style.display = 'none';
                }
            });
        });
    },

    openMenu: function(e, uid, name) {
        selectedFriendUid = uid;
        document.getElementById('fs-target-name').innerText = name; 
        
        const menu = document.getElementById('friend-context-menu');
        let x = e.clientX;
        let y = e.clientY;
        if(x + 150 > window.innerWidth) x = window.innerWidth - 160;
        
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.style.display = 'flex';
        setTimeout(() => document.addEventListener('click', () => menu.style.display='none', {once:true}), 100);
    },
    
    // --- ACTIONS ---
    actionMessage: function() {
        const name = document.getElementById('fs-target-name').innerText;
        DM.open(selectedFriendUid, name);
    },
    
    actionSettings: function() {
        const modal = document.getElementById('friend-settings-modal');
        modal.style.display = 'flex';
        
        // Load current settings from DB
        // Path: users/{MY_ID}/relationships/{FRIEND_ID}
        // This stores "My rules regarding this friend"
        db.ref(`users/${currentUser.uid}/relationships/${selectedFriendUid}`).once('value').then(snap => {
            const data = snap.val() || {};
            document.getElementById('fs-block-dm').checked = data.blockDM || false;
            document.getElementById('fs-hide-status').checked = data.hideStatus || false;
            document.getElementById('fs-block-invite').checked = data.blockInvite || false;
        });
    },
    
    saveSettings: function() {
        const data = {
            blockDM: document.getElementById('fs-block-dm').checked,
            hideStatus: document.getElementById('fs-hide-status').checked,
            blockInvite: document.getElementById('fs-block-invite').checked
        };
        
        // Save to DB
        db.ref(`users/${currentUser.uid}/relationships/${selectedFriendUid}`).update(data).then(() => {
            alert("Settings Updated");
            document.getElementById('friend-settings-modal').style.display = 'none';
        });
    },

    actionRemove: function() {
        if(selectedFriendUid) this.removeFriend(selectedFriendUid);
    },
    
    removeFriend: function(uid) {
        if(confirm("Remove this friend?")) {
            db.ref(`users/${currentUser.uid}/friends/${uid}`).remove();
            db.ref(`users/${uid}/friends/${currentUser.uid}`).remove();
            
            // Optional: Also remove settings logic if you want reset
            db.ref(`users/${currentUser.uid}/relationships/${uid}`).remove();
            db.ref(`users/${uid}/relationships/${currentUser.uid}`).remove();

            setTimeout(() => this.renderList('profile-friends-list'), 500);
        }
    }
};

// --- DIRECT MESSAGING SYSTEM ---
const DM = {
    activeChatUid: null,
    listener: null,

    open: function(uid, name) {
        this.activeChatUid = uid;
        const win = document.getElementById('dm-window');
        document.getElementById('dm-title').innerText = "Chat: " + name;
        document.getElementById('dm-body').innerHTML = '';
        win.style.display = 'flex';
        
        // Generate Chat ID (Alphabetical sort to ensure same ID for both users)
        const chatId = [currentUser.uid, uid].sort().join('_');
        
        if(this.listener) db.ref(this.listener).off();
        
        // Listen for messages
        this.listener = `dms/${chatId}`;
        db.ref(this.listener).limitToLast(50).on('child_added', snap => {
            const msg = snap.val();
            const d = document.createElement('div');
            d.className = 'dm-msg ' + (msg.sender === currentUser.uid ? 'me' : 'them');
            d.innerText = msg.text;
            
            const body = document.getElementById('dm-body');
            body.appendChild(d);
            body.scrollTop = body.scrollHeight;
        });
    },
    
send: function() {
        const input = document.getElementById('dm-input');
        const text = input.value.trim();
        if(!text || !this.activeChatUid) return;
        
        const targetUid = this.activeChatUid;
        
        // CHECK IF BLOCKED
        db.ref(`users/${targetUid}/relationships/${currentUser.uid}/blockDM`).once('value').then(snap => {
            if(snap.val() === true) {
                // Blocked - Show error only to me
                const d = document.createElement('div');
                d.className = 'dm-msg';
                d.style.background = '#ef4444'; 
                d.innerText = "Message not delivered (Blocked).";
                document.getElementById('dm-body').appendChild(d);
                input.value = '';
            } else {
                // 1. Save to Chat History (Standard)
                const chatId = [currentUser.uid, targetUid].sort().join('_');
                db.ref(`dms/${chatId}`).push({
                    sender: currentUser.uid,
                    text: text,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                // 2. NEW: Push to Recipient's Inbox (For Notifications)
                // We use getMyDisplayName to ensure the name is accurate
                getMyDisplayName((myName) => {
                    db.ref(`users/${targetUid}/inbox`).push({
                        type: 'dm',
                        senderUid: currentUser.uid,
                        senderName: myName,
                        text: text,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                });

                input.value = '';
            }
        });
    },
    
    close: function() {
        document.getElementById('dm-window').style.display = 'none';
        if(this.listener) db.ref(this.listener).off();
        this.activeChatUid = null;
    }
};


const BUG_REPORT = {
    open: function() {
        document.getElementById('bug-report-modal').style.display = 'flex';
        document.getElementById('bug-description').value = ""; // Clear previous text
    },

    send: function() {
        const desc = document.getElementById('bug-description').value;
        if (!desc.trim()) {
            alert("Please describe the bug first.");
            return;
        }

        // Gather Debug Info
        const uid = currentUser ? currentUser.uid : "Not Logged In";
        const email = currentUser ? currentUser.email : "N/A";
        const time = new Date().toLocaleString();
        
        // Construct Email Body
        const subject = encodeURIComponent("Bug Report: Questopoly Legends");
        const bodyContent = `BUG DESCRIPTION:\n${desc}\n\n----------------\nTECHNICAL INFO:\nUser: ${email}\nUID: ${uid}\nTime: ${time}\nPlatform: ${navigator.userAgent}`;
        const body = encodeURIComponent(bodyContent);

        // Open Email Client
        window.location.href = `mailto:beginmegaquest@gmail.com?subject=${subject}&body=${body}`;
        
        // Close Modal
        document.getElementById('bug-report-modal').style.display = 'none';
    }
};

// Helper to get current user's display name
function getMyDisplayName(callback) {
    if(!currentUser) return callback("Unknown");
    db.ref(`users/${currentUser.uid}/displayName`).once('value').then(snap => {
        const val = snap.val();
        callback(val ? val : currentUser.email.split('@')[0]);
    });
}

// --- LOBBY SYSTEM ---
const LOBBY = {
    enter: function() {
        document.getElementById('splash-screen').style.display = 'none';
        document.getElementById('lobby-screen').style.display = 'flex';
        this.refreshList();
        this.initGlobalChat();
    },
    exit: function() {
        document.getElementById('lobby-screen').style.display = 'none';
        document.getElementById('splash-screen').style.display = 'flex';
        if(this.chatListener) db.ref('chat/global').off();
    },
    initGlobalChat: function() {
        const chatBox = document.getElementById('global-chat-box');
        if (this.chatListener) db.ref('chat/global').off(); 
        
        chatBox.innerHTML = '';
        this.chatListener = db.ref('chat/global').limitToLast(50).on('child_added', snap => {
            const msg = snap.val();
            const d = document.createElement('div'); d.className='chat-msg';
            d.innerHTML = `<span class="name">[${msg.name}]:</span> ${msg.text}`;
            chatBox.appendChild(d);
            chatBox.scrollTop = chatBox.scrollHeight;
        });
    },
    sendChat: function() {
        const input = document.getElementById('global-chat-input');
        const text = input.value.trim();
        if(text && currentUser) {
            db.ref('chat/global').push({
                name: currentUser.email.split('@')[0],
                text: text,
                time: firebase.database.ServerValue.TIMESTAMP
            });
            input.value = '';
        }
    },
    refreshList: function() {
        if(!db) return;
        const list = document.getElementById('lobby-list');
        const searchVal = document.getElementById('lobby-search').value.toLowerCase();
        
        list.innerHTML = '<div style="padding:20px; text-align:center;">Loading...</div>';
        
        db.ref('games').once('value').then(snap => {
            list.innerHTML = '';
            const games = snap.val();
            
            if(!games) { 
                list.innerHTML = '<div style="padding:20px; text-align:center;">No games found.</div>'; 
                return; 
            }
            
            Object.keys(games).forEach(k => {
                const g = games[k];
                if(g.status === 'waiting') {
                    if(searchVal && !g.hostName.toLowerCase().includes(searchVal)) return;

                    const playerCount = g.players ? Object.keys(g.players).length : 1;
                    const locked = g.password ? 'ðŸ”’ ' : '';
                    const isMine = (g.host === currentUser.uid);

                    const div = document.createElement('div');
                    div.className = 'lobby-item';
                    
                    let deleteBtn = '';
                    if (isAdminMode || isMine) {
                        deleteBtn = `<button style="background:transparent; border:none; color:#ef4444; font-weight:bold; cursor:pointer; margin-left:10px; font-size:1.2rem;" onclick="event.stopPropagation(); LOBBY.deleteGame('${k}', ${isMine})" title="Delete Game">Ã—</button>`;
                    }

                    div.innerHTML = `
                        <div style="flex-grow:1; display:flex; justify-content:space-between;" onclick="LOBBY.attemptJoin('${k}', '${g.password}')">
                            <span>${locked}${g.hostName}'s Game</span>
                            <span>${playerCount}/4</span>
                        </div>
                        ${deleteBtn}
                    `;
                    list.appendChild(div);
                }
            });
        });
    },
    
    deleteGame: function(gid, isMine) {
        const msg = isMine ? "Delete your game room?" : "Delete this game room? (Admin Action)";
        if(confirm(msg)) {
            db.ref(`games/${gid}`).remove().then(() => this.refreshList());
        }
    },

    attemptJoin: function(gid, hasPass) {
        pendingJoinId = gid;
        if(hasPass) {
            document.getElementById('password-modal').style.display = 'flex';
        } else {
            this.joinGame(gid);
        }
    },
    submitPassword: function() {
        const pass = document.getElementById('join-pass').value;
        db.ref(`games/${pendingJoinId}/password`).once('value').then(snap => {
            if(snap.val() === pass) {
                document.getElementById('password-modal').style.display = 'none';
                this.joinGame(pendingJoinId);
            } else {
                alert("Incorrect Password");
            }
        });
    },
    
    // --- UPDATED JOIN LOGIC ---
joinGame: function(gid) {
        if(!db) return;
        
        // 1. Get Current User directly from Auth to be safe
        const user = firebase.auth().currentUser;
        if(!user) { 
            alert("You must be logged in to join."); 
            return; 
        }

        gameId = gid;
        isMultiplayer = true;
        const myUid = user.uid;
        // Fallback name if display name isn't fetched yet
        const myName = user.email ? user.email.split('@')[0] : "Player"; 

        const gameRef = db.ref(`games/${gid}`);

        // 2. Fetch Game Data Once
        gameRef.once('value').then(snap => {
            const g = snap.val();
            
            if(!g) { alert("Game not found."); return; }
            if(g.status !== 'waiting') { alert("Game has already started."); return; }

            // 3. Logic: Find Slot
            let targetSlot = -1;
            
            // A. Check if I am ALREADY in this game (Re-joining)
            for(let i=0; i<4; i++) {
                // Check safely if slot exists and matches UID
                if(g.slots && g.slots[i] && g.slots[i].uid === myUid) {
                    myPlayerId = i;
                    ROOM.enter(g);
                    return; // Enter immediately
                }
            }
            
            // B. Check for Specific Invite (Invited slots reserve spot for UID)
            for(let i=0; i<4; i++) {
                if(g.slots && g.slots[i] && g.slots[i].type === 'invited' && g.slots[i].uid === myUid) {
                    targetSlot = i; 
                    break;
                }
            }
            
            // C. If no invite found, find first OPEN slot
            if(targetSlot === -1) {
                for(let i=0; i<4; i++) {
                    // Slot is open if:
                    // 1. It doesn't exist in DB yet (!g.slots or !g.slots[i])
                    // 2. OR it exists and type is explicitly 'open'
                    if(!g.slots || !g.slots[i] || g.slots[i].type === 'open') {
                        targetSlot = i; 
                        break;
                    }
                }
            }

            // 4. Update Database if slot found
            if(targetSlot !== -1) {
                myPlayerId = targetSlot;

                const updates = {};
                
                // Update Slot Visuals
                updates[`slots/${targetSlot}`] = {
                    type: 'human',
                    uid: myUid,
                    name: myName, // Will update to display name below
                    ready: false,
                    color: PLAYER_COLORS[targetSlot]
                };
                
                // Update Game Logic Player Data (Legacy support)
                updates[`players/${targetSlot}`] = {
                    id: targetSlot,
                    uid: myUid
                };

                // Perform Update
                gameRef.update(updates).then(() => {
                    // Success!
                    
                    // Attempt to fetch real Display Name and update record
                    getMyDisplayName((dName) => {
                        if(dName && dName !== "Unknown") {
                            db.ref(`games/${gid}/slots/${targetSlot}/name`).set(dName);
                        }
                    });

                    // Enter Room (Fetch fresh data to ensure UI sync)
                    gameRef.once('value').then(newSnap => {
                        ROOM.enter(newSnap.val());
                    });

                }).catch(err => {
                    console.error(err);
                    alert("Failed to join game: " + err.message);
                });

            } else {
                alert("Game is full.");
            }
        });
    }
};

// --- HELPER FOR CREATE MODAL ---
function showCreateModal() {
    const pass = prompt("Enter a password (leave blank for public):");
    createGameLogic(pass);
}

function createGameLogic() {
    if(!db) return;
    
    getMyDisplayName((myName) => {
        const ref = db.ref('games').push();
        gameId = ref.key;
        myPlayerId = 0; // Host
        isMultiplayer = true;

        const slots = {
            0: { type: 'human', uid: currentUser.uid, name: myName, ready: false, color: PLAYER_COLORS[0] },
            1: { type: 'open' },
            2: { type: 'open' },
            3: { type: 'open' }
        };

        ref.set({
            host: currentUser.uid,
            hostName: myName,
            password: "",
            status: 'waiting',
            turnIndex: 0,
            slots: slots,
            players: { 0: { id:0, uid: currentUser.uid } }
        }).then(() => {
            ref.once('value').then(snap => ROOM.enter(snap.val()));
        });
    });
}


// --- ROOM SYSTEM (StarCraft Lobby) ---
const ROOM = {
    activeInviteSlot: null, 

		enter: function(gameData) {
        document.getElementById('lobby-screen').style.display = 'none';
        document.getElementById('gameroom-screen').style.display = 'flex';
        currentRoomData = gameData;
        
        // Listen to Room Updates
        db.ref(`games/${gameId}`).on('value', snap => {
            currentRoomData = snap.val();
            
            // 1. Game Deleted Check (Host left)
            if(!currentRoomData) { 
                if(myPlayerId !== 0) alert("The Host has closed the lobby.");
                this.leaveUI(); 
                return; 
            } 
            
            // 2. Kicked Check (NEW LOGIC)
            // If I am not the host, check if my slot is still mine
            if (myPlayerId !== 0 && currentRoomData.slots) {
                const mySlot = currentRoomData.slots[myPlayerId];
                
                // If slot is null, or type is 'open', or the UID doesn't match my UID
                if (!mySlot || mySlot.type === 'open' || (mySlot.uid && mySlot.uid !== currentUser.uid)) {
                    // Stop listening immediately so the alert doesn't fire multiple times
                    db.ref(`games/${gameId}`).off(); 
                    
                    alert("You have been kicked from the lobby.");
                    this.leaveUI();
                    return;
                }
            }

            // 3. Game Started Check
            if(currentRoomData.status === 'playing') {
                document.getElementById('gameroom-screen').style.display = 'none';
                db.ref(`games/${gameId}`).off(); 
                startGame(); 
                return;
            }
            
            this.renderSlots();
        });
        
        // Listen to Chat
        const chatBox = document.getElementById('room-chat-box');
        chatBox.innerHTML = '';
        db.ref(`games/${gameId}/chat`).limitToLast(50).on('child_added', snap => {
            const msg = snap.val();
            const d = document.createElement('div'); d.className='chat-msg';
            const col = PLAYER_COLORS[msg.slot] || '#fff';
            d.innerHTML = `<span class="name" style="color:${col}">[${msg.name}]:</span> ${msg.text}`;
            chatBox.appendChild(d);
            chatBox.scrollTop = chatBox.scrollHeight;
        });
    },

    renderSlots: function() {
        if (!currentRoomData || !currentRoomData.slots) return;

        const isHost = (myPlayerId === 0);
        const startBtn = document.getElementById('btn-room-start');
        
        let humanReadyCount = 0;
        let humanCount = 0;
        let aiCount = 0;
        let openCount = 0;

        // 1. Host Settings
        const settingsArea = document.getElementById('host-settings-area');
        if(isHost) {
            settingsArea.style.display = 'block';
            const passInput = settingsArea.querySelector('input');
            if (document.activeElement !== passInput) passInput.value = currentRoomData.password || "";
        } else {
            settingsArea.style.display = 'none';
        }

        // 2. Render Slots
        for(let i=0; i<4; i++) {
            const slotEl = document.getElementById(`slot-${i}`);
            const data = currentRoomData.slots[i];
            
            slotEl.innerHTML = '';
            slotEl.className = 'player-slot';
            
            // --- HUMAN ---
            if (data.type === 'human') {
                humanCount++;
                let isMe = (i === myPlayerId);
                
                if(data.ready) {
                    slotEl.classList.add('ready');
                    humanReadyCount++;
                }

                let desc = "Selecting Character...";
                if(data.charData) {
                     desc = `<span style="color:${data.color}">Lvl 1 ${data.charData.race.name} ${data.charData.class.name}</span>`;
                }

                let actionBtn = '';
                if(isMe) {
                    if(data.ready) {
                        actionBtn = `<button class="slot-action-btn edit" onclick="ROOM.editCharacter()">Edit Character</button>`;
                    } else {
                        actionBtn = `<button class="slot-action-btn" onclick="ROOM.editCharacter()">Create Character</button>`;
                    }
                } else if (isHost && i !== 0) {
                    actionBtn = `<button style="background:#ef4444; color:#fff; border:none; cursor:pointer; padding:5px 10px; border-radius:4px;" onclick="ROOM.kick(${i})">KICK</button>`;
                }

                slotEl.innerHTML = `
                    <div class="slot-left-group">
                        <div class="slot-avatar" style="background-color:${data.color}; ${data.ready ? 'border-color:var(--accent-green);' : ''}"></div>
                        <div class="slot-info">
                            <div class="slot-name">${data.name}</div>
                            <div class="slot-meta">${desc}</div>
                        </div>
                    </div>
                    <div>${actionBtn}</div>
                `;

            } 
            // --- OPEN ---
            else if (data.type === 'open') {
                openCount++;
                slotEl.classList.add('open');
                if (isHost) {
                    slotEl.innerHTML = `
                        <div style="color:#666; font-style:italic;">Empty Seat</div>
                        <select class="slot-select" onchange="ROOM.handleSlotSelect(${i}, this.value)">
                            <option value="open" selected>Open</option>
                            <option value="ai">Add AI Bot</option>
                            <option value="invite">Invite Friend</option>
                            <option value="closed">Close Slot</option>
                        </select>
                    `;
                } else {
                    slotEl.innerHTML = `<div style="color:#666; width:100%; text-align:center;">Waiting for player...</div>`;
                }
            } 
            // --- AI ---
            else if (data.type === 'ai') {
                 aiCount++;
                 slotEl.innerHTML = `
                    <div class="slot-left-group">
                        <div class="slot-avatar" style="background-color:#555; display:flex; align-items:center; justify-content:center; font-size:2rem;">ðŸ¤–</div>
                        <div class="slot-info">
                            <div class="slot-name" style="color:#aaa;">${data.name}</div>
                            <div class="slot-meta">Easy Difficulty</div>
                        </div>
                    </div>
                `;
                if(isHost) {
                     slotEl.innerHTML += `<button style="background:#ef4444; color:#fff; border:none; cursor:pointer; padding:5px 10px; border-radius:4px;" onclick="ROOM.setSlot(${i}, 'open')">Remove</button>`;
                }
            } 
            // --- INVITED / CLOSED ---
            else {
                let statusText = (data.type === 'closed') ? "Closed" : `Invited: ${data.name}`;
                slotEl.innerHTML = `<div style="color:#666;">${statusText}</div>`;
                if(isHost) slotEl.innerHTML += `<button style="background:#444; color:#fff; border:none; cursor:pointer; padding:5px;" onclick="ROOM.setSlot(${i}, 'open')">Open</button>`;
            }
        }

        // 3. Start Button Logic
        const allSlotsFilled = (openCount === 0);
        const allHumansReady = (humanReadyCount === humanCount);
        const pendingInvites = Object.values(currentRoomData.slots).some(s => s.type === 'invited');
        const totalActive = humanCount + aiCount;

        if (isHost) {
            if (allSlotsFilled && allHumansReady && !pendingInvites && totalActive > 1) {
                startBtn.disabled = false;
                startBtn.innerText = "START GAME";
                startBtn.style.background = "var(--gold-main)";
                startBtn.style.color = "#000";
            } else {
                startBtn.disabled = true;
                startBtn.style.background = "#333";
                startBtn.style.color = "#888";
                
                if (totalActive < 2) startBtn.innerText = "NEED 2+ PLAYERS";
                else if (openCount > 0) startBtn.innerText = "FILL ALL SLOTS";
                else if (pendingInvites) startBtn.innerText = "WAITING FOR INVITE";
                else if (!allHumansReady) startBtn.innerText = "PLAYERS NOT READY";
            }
        } else {
            startBtn.style.display = 'none';
        }
    },

    handleSlotSelect: function(slotIdx, value) {
        if(value === 'invite') {
            this.activeInviteSlot = slotIdx;
            document.getElementById('invite-modal').style.display = 'flex';
            FRIENDS.renderList('invite-list', true); 
        } else {
            this.setSlot(slotIdx, value);
        }
    },

// INSIDE ROOM CONSTANT
setSlot: function(slotIdx, type) {
    let update = { type: type };
    
    // Clean up old player data if removing/opening
    if (type === 'open' || type === 'closed') {
         db.ref(`games/${gameId}/players/${slotIdx}`).remove();
    }
    
    // AI Logic: Generate Stats/Race/Class NOW and save to DB
    if(type === 'ai') {
        // Find unused color
        const usedColors = [];
        if(currentRoomData && currentRoomData.slots) {
            for(let i=0; i<4; i++) {
                if(currentRoomData.slots[i] && currentRoomData.slots[i].color) {
                    usedColors.push(currentRoomData.slots[i].color);
                }
            }
        }
        const availableColors = PLAYER_COLORS.filter(c => !usedColors.includes(c));
        const aiColor = availableColors.length > 0 ? availableColors[0] : '#888';
        const aiName = NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)];

        // GENERATE FIXED AI DATA
        const r = RACES[Math.floor(Math.random()*RACES.length)];
        const c = CLASSES[Math.floor(Math.random()*CLASSES.length)];
        
        // Save this to the slot so all clients see the same bot
        update = { 
            type: 'ai', 
            name: aiName, 
            color: aiColor, 
            ready: true,
            charData: {
                race: r,
                class: c,
                active: c.actives[0], // Default first skill
                passive: c.passives[0]
            }
        };
        
        // Initialize Player Object in DB
        db.ref(`games/${gameId}/players/${slotIdx}`).set({ 
            id: slotIdx, 
            uid: 'AI_'+slotIdx,
            gold: 1000 // Ensure starting gold is synced
        }); 
    } 

    db.ref(`games/${gameId}/slots/${slotIdx}`).set(update);
},

    sendInvite: function(uid, name) {
        const slotIdx = this.activeInviteSlot;
        if(slotIdx !== undefined && slotIdx !== null) {
             db.ref(`games/${gameId}/slots/${slotIdx}`).set({
                 type: 'invited',
                 uid: uid,
                 name: name,
                 ready: false,
                 color: '#444'
             });
             this.sendChat(`Invited ${name} to Slot ${slotIdx + 1}`);
        }
    },

    setPassword: function(pass) {
        if(myPlayerId === 0) {
            db.ref(`games/${gameId}`).update({ password: pass });
        }
    },

    kick: function(slotIdx) {
        this.setSlot(slotIdx, 'open');
    },

    editCharacter: function() {
        document.getElementById('gameroom-screen').style.display = 'none';
        enterCreation(true);
        const btn = document.getElementById('btn-start-game');
        btn.innerText = "Ready";
        btn.onclick = () => this.saveCharacter();
    },

    saveCharacter: function() {
        const name = document.getElementById('char-name-input').value || "Hero";
        const charData = { race: selRace, class: selClass, active: selActiveId, passive: selPassiveId };
        
        db.ref(`games/${gameId}/slots/${myPlayerId}`).update({
            name: name,
            color: selColor,
            charData: charData,
            ready: true
        });
        
        const pData = {
            id: myPlayerId, name: name, race: selRace, class: selClass,
            activeSkillId: selActiveId, passiveSkillId: selPassiveId, color: selColor,
            ready: true
        };
        db.ref(`games/${gameId}/players/${myPlayerId}`).update(pData);

        document.getElementById('create-screen').style.display = 'none';
        document.getElementById('gameroom-screen').style.display = 'flex';
    },

    sendChat: function() {
        const input = document.getElementById('room-chat-input');
        const text = input.value.trim();
        if(text) {
            const name = (currentRoomData.slots[myPlayerId]) ? currentRoomData.slots[myPlayerId].name : "Unknown";
            db.ref(`games/${gameId}/chat`).push({
                name: name,
                slot: myPlayerId,
                text: text
            });
            input.value = '';
        }
    },

    startGame: function() {
        db.ref(`games/${gameId}`).update({ status: 'playing' });
    },

    leave: function() {
        if(myPlayerId === 0) {
            if(confirm("You are the host. Leaving will close the game room for everyone. Continue?")) {
                db.ref(`games/${gameId}`).remove();
                this.leaveUI(); 
            }
        } else {
            this.setSlot(myPlayerId, 'open');
            this.leaveUI();
        }
    },

    leaveUI: function() {
        document.getElementById('gameroom-screen').style.display = 'none';
        if(db) db.ref(`games/${gameId}`).off(); 
        currentRoomData = null;
        gameId = null;
        LOBBY.enter();
    },

    copyLink: function() {
        const url = window.location.origin + window.location.pathname + '?join=' + gameId;
        navigator.clipboard.writeText(url).then(() => alert("Link copied to clipboard!"));
    }
};
   
// --- REGION 1: GLOBALS & INIT ---
let scene, camera, renderer;
let tiles=[], players=[], turnIndex=0, gameState='SETUP', treasuryGold=0;
let normalDeck, skirmishDeck, treasureDeck;
let turnCount = 0, isNight = false;
let selRace=null, selClass=null, selColor="#ef4444", selActiveId=null, selPassiveId=null;
let nightBoard = null; 
let fogGroup = null;
let turnProcessing = false;
let lastMoveTimestamp = 0; // Tracks the last processed move ID

// --- GUARD & ANIMATION GLOBALS ---
let activeGuards = []; // Tracks all guard objects for animation

// Call this inside your main animate() loop
function updateGuards() {
    const time = Date.now() * 0.001;
    activeGuards.forEach(g => {
        if (!g.mesh) return;

        // Logic: Move towards target
        const speed = 0.02;
        const dx = g.target.x - g.mesh.position.x;
        const dz = g.target.z - g.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);

        if (dist < 0.1) {
            // Pick new random target within the tile limits, avoiding the center (Tavern)
            // Tile is approx 3.8x3.8. Local coords: -1.5 to 1.5. Tavern radius approx 0.8
            let valid = false;
            let tries = 0;
            while (!valid && tries < 10) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.0 + Math.random() * 0.6; // Keep away from center
                g.target.x = Math.cos(angle) * radius;
                g.target.z = Math.sin(angle) * radius;
                valid = true;
                tries++;
            }
            // Face new target
            g.mesh.lookAt(g.target.x, g.mesh.position.y, g.target.z);
        } else {
            // Move
            g.mesh.position.x += (dx / dist) * speed;
            g.mesh.position.z += (dz / dist) * speed;
            
            // Bobbing animation
            g.mesh.position.y = 0.2 + Math.abs(Math.sin(time * 5)) * 0.1;
        }
    });
}

// --- CAMERA & ANIMATION GLOBALS ---
let isZoomed = false;
let cameraTarget = null;

const PLAYER_COLORS = ["#ef4444", "#3b82f6", "#10b981", "#f59e0b", "#8b5cf6", "#FFFFFF"];
const EQUIP_ORDER = ['head', 'body', 'main', 'off'];

// --- REGION 2: DATA (Names, Races, Classes) ---
const NPC_NAMES = [
    "Aaelin", "Adran", "Aelar", "Aeron", "Alaric", "Aldric", "Amara", "Arin", "Asher", "Astrid", 
    "Balthazar", "Bard", "Bran", "Caelum", "Caius", "Caspian", "Cedric", "Corin", "Cyrus", "Darian", 
    "Eamon", "Elander", "Elara", "Eldrin", "Elric", "Emrys", "Faen", "Fenris", "Finn", "Galen", 
    "Gideon", "Gorim", "Griffin", "Hadrian", "Haldor", "Ignis", "Imara", "Ion", "Jareth", "Jax", 
    "Kael", "Kaiden", "Kian", "Kyra", "Leander", "Leo", "Lucian", "Magnus", "Marek", "Mathis",
    "Nael", "Nyx", "Orion", "Orin", "Osric", "Perrin", "Quinn", "Raen", "Ragnar", "Ravyn", 
    "Remus", "Rian", "Roan", "Rurik", "Ryker", "Silas", "Soren", "Stig", "Storm", "Talis", 
    "Thorne", "Torin", "Tristan", "Tybalt", "Uric", "Valen", "Varis", "Vesper", "Xander", "Zane"
];

const RACES = [ 
    {id:'human', name:'Human', stats:{str:2, dex:2, int:2}}, 
    {id:'elf', name:'Elf', stats:{str:1, dex:3, int:2}}, 
    {id:'dwarf', name:'Dwarf', stats:{str:3, dex:1, int:2}}, 
    {id:'orc', name:'Orc', stats:{str:4, dex:1, int:1}}, 
    {id:'gnome', name:'Gnome', stats:{str:1, dex:2, int:3}}, 
    {id:'tiefling', name:'Tiefling', stats:{str:1, dex:1, int:4}}, 
    {id:'dragonborn', name:'Dragonborn', stats:{str:3, dex:2, int:1}}, 
    {id:'halfling', name:'Halfling', stats:{str:1, dex:4, int:1}} 
];

const CLASSES = [
    { id: 'fighter', name: 'Fighter', color: 0x8B0000, 
      actives: ['power_strike', 'intimidate', 'second_wind', 'shield_bash', 'rally', 'siege_breaker'], 
      passives: ['veteran', 'iron_skin', 'executioner', 'conqueror', 'heavy_armor', 'vanguard'] },
      
    { id: 'wizard', name: 'Wizard', color: 0x4B0082, 
      actives: ['fireball', 'transmute_gold', 'blink', 'time_warp', 'polymorph', 'arcane_eye'], 
      passives: ['scholar', 'court_mage', 'alchemist_pas', 'mana_shield', 'leyline', 'elemental_attune'] }, 
      
    { id: 'rogue', name: 'Rogue', color: 0x2F4F4F, 
      actives: ['pickpocket', 'sprint_act', 'smoke_bomb_act', 'sabotage', 'gamble_act', 'shadow_strike'], 
      passives: ['shadow_step', 'greedy', 'fence', 'skeleton_key', 'cutpurse', 'ambush_pas'] },
      
    { id: 'cleric', name: 'Cleric', color: 0xFFD700, 
      actives: ['heal_spell', 'smite', 'bless', 'divine_intervention', 'sanctuary', 'exorcism'], 
      passives: ['devotion', 'medic', 'holy_aura', 'spirit_tithe', 'pacifist', 'resurrection'] }
];

const CHAR_PORTRAITS = {
    human_fighter: "https://static.wixstatic.com/media/b16479_85518cf9c4d646c2994697b826b54bff~mv2.jpg",
    human_wizard: "https://static.wixstatic.com/media/b16479_67634ea082d04f388af02accc2e0a2bc~mv2.jpg",
    human_rogue: "https://static.wixstatic.com/media/b16479_7f27982f60994088b1740631284815b3~mv2.jpg",
    human_cleric: "https://static.wixstatic.com/media/b16479_0293976216c3443187ebcc00fcb1e071~mv2.jpg",
    elf_fighter: "https://static.wixstatic.com/media/b16479_97dd792642d444f59cb3b21842131c6a~mv2.jpg",
    elf_wizard: "https://static.wixstatic.com/media/b16479_19a126df94694355b2381756b2ad35da~mv2.jpg",
    elf_rogue: "https://static.wixstatic.com/media/b16479_ffdbe8eb72214036a2f95e2f5a9e6f48~mv2.jpg",
    elf_cleric: "https://static.wixstatic.com/media/b16479_82514ff810324b4ca9c6218b6d4e2da6~mv2.jpg",
    dwarf_fighter: "https://static.wixstatic.com/media/b16479_15e678031c824dfaa6ff4b851c470c39~mv2.jpg",
    dwarf_wizard: "https://static.wixstatic.com/media/b16479_f84ec5deac214cd3b570517773edd83e~mv2.jpg",
    dwarf_rogue: "https://static.wixstatic.com/media/b16479_81d5ee7fd64c4d1a911252797b8b34bd~mv2.jpg",
    dwarf_cleric: "https://static.wixstatic.com/media/b16479_67a5b13eb3654884b520fcff34f7af0e~mv2.jpg",
    orc_fighter: "https://static.wixstatic.com/media/b16479_733a0e4ffb554734a58229af907bb5e5~mv2.jpg",
    orc_wizard: "https://static.wixstatic.com/media/b16479_a99213a85fa74dc7925dc1fb2d26987f~mv2.jpg",
    orc_rogue: "https://static.wixstatic.com/media/b16479_a0df2ed1b7b3412ba4694f474bf0846b~mv2.jpg",
    orc_cleric: "https://static.wixstatic.com/media/b16479_881698035b3b41c6932393d2b0975359~mv2.jpg",
    gnome_fighter: "https://static.wixstatic.com/media/b16479_7d856dc2c71e4b60aff24ef59172897b~mv2.jpg",
    gnome_wizard: "https://static.wixstatic.com/media/b16479_7466d1b684c04c459bb588da3225158d~mv2.jpg",
    gnome_rogue: "https://static.wixstatic.com/media/b16479_3c67ae62970347d5a96a83248d7680f2~mv2.jpg",
    gnome_cleric: "https://static.wixstatic.com/media/b16479_36767d44051346c49f9e4c0995ece904~mv2.jpg",
    tiefling_fighter: "https://static.wixstatic.com/media/b16479_a5e3e133b61f463a8bcc0ce93b582d25~mv2.jpg",
    tiefling_wizard: "https://static.wixstatic.com/media/b16479_afd36e1dcbc2485cac93ae49155eae58~mv2.jpg",
    tiefling_rogue: "https://static.wixstatic.com/media/b16479_9168e6f8da2e48659f4ced1d8c7aad8c~mv2.jpg",
    tiefling_cleric: "https://static.wixstatic.com/media/b16479_689c4a94dbb6418681634d65878c8022~mv2.jpg",
    dragonborn_fighter: "https://static.wixstatic.com/media/b16479_d5e785f4d11e4d8288a3e963c6902b2c~mv2.jpg",
    dragonborn_wizard: "https://static.wixstatic.com/media/b16479_8e63663f55f142fa81a3958b3a2b0d7b~mv2.jpg",
    dragonborn_rogue: "https://static.wixstatic.com/media/b16479_d4f401dc822b421ca753799e82879c99~mv2.jpg",
    dragonborn_cleric: "https://static.wixstatic.com/media/b16479_dab195d558d94074a19bb86b45972311~mv2.jpg",
    halfling_fighter: "https://static.wixstatic.com/media/b16479_1692c0cb049249a1b5d49ac4f8901b97~mv2.jpg",
    halfling_wizard: "https://static.wixstatic.com/media/b16479_0dcf3d49ab0b4dd7b0ca03d0ed6c09f8~mv2.jpg",
    halfling_rogue: "https://static.wixstatic.com/media/b16479_b031efc88dfe49899f2e2b4f619c788e~mv2.jpg",
    halfling_cleric: "https://static.wixstatic.com/media/b16479_ffa702bd84c141fca8fa7cbfd86f581d~mv2.jpg"
};

// ==========================================
//   POLYMORPH / SHEEP MECHANICS
// ==========================================

function createSheepMesh() {
    const g = new THREE.Group();
    const woolMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1 });
    const skinMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); 

    const body = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6), woolMat);
    body.position.y = 0.6;
    body.castShadow = true;
    g.add(body);

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.4), skinMat);
    head.position.set(0, 0.9, 0.4);
    g.add(head);

    const legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5);
    const fl = new THREE.Mesh(legGeo, skinMat); fl.position.set(-0.25, 0.25, 0.25);
    const fr = new THREE.Mesh(legGeo, skinMat); fr.position.set(0.25, 0.25, 0.25);
    const bl = new THREE.Mesh(legGeo, skinMat); bl.position.set(-0.25, 0.25, -0.25);
    const br = new THREE.Mesh(legGeo, skinMat); br.position.set(0.25, 0.25, -0.25);
    g.add(fl, fr, bl, br);
    
    g.position.y = 0;
    return g;
}

function makeSheep(p) {
    // Prevent double-sheeping logic which causes mesh loss
    if (p.isPolymorphed && p.mesh && p.mesh.userData && p.mesh.userData.isSheep) return;

    p.isPolymorphed = true;
    
    // Save the current human mesh if we haven't already
    // IMPORTANT: In MP, p.mesh might already be the sheep if lag occurred, so we check userData
    if (!p.mesh.userData.isSheep) {
        p.originalMesh = p.mesh;
    }

    const sheep = createSheepMesh();
    sheep.userData.isSheep = true; // Mark this mesh as a sheep
    
    sheep.position.copy(p.mesh.position);
    sheep.rotation.copy(p.mesh.rotation);
    
    scene.remove(p.mesh);
    scene.add(sheep);
    
    p.mesh = sheep; 

    // Play sound only if meaningful to user
    if(p.id === myPlayerId || isZoomed) AUDIO.playSound('sfx_transition'); 
}

function cureSheep(p) {
    // 1. Remove Sheep Mesh if it exists
    if (p.mesh && p.mesh.userData && p.mesh.userData.isSheep) {
        scene.remove(p.mesh);
        // dispose geometry if needed
    }

    // 2. Restore Human Mesh
    if (p.originalMesh) {
        p.mesh = p.originalMesh;
        scene.add(p.mesh);
    } else {
        // FALLBACK: Rebuild mesh if original is missing/undefined
        console.log(`Rebuilding mesh for ${p.name}`);
        const newGroup = createPlayerMesh(p.race, p.class, p.color);
        scene.add(newGroup);
        p.mesh = newGroup;
        // Save as new original
        p.originalMesh = newGroup;
    }

    // 3. Snap Position to current tile
    if(tiles[p.pos]) {
        p.mesh.position.copy(tiles[p.pos].position); 
        p.mesh.position.y = 0; 
    }

    // 4. Update Camera Target if needed
    if (cameraTarget && cameraTarget.userData && cameraTarget.userData.isSheep) {
        cameraTarget = p.mesh;
    }

    p.isPolymorphed = false;
    addLog(`${p.name} returns to normal form.`, "log-success");
    
    // Note: DB Sync is handled by the Host in END_TURN, so we don't write here to avoid loops
    updateHUD();
}

function makeSheep(p) {
    // Safety: If already a sheep, stop.
    if (p.mesh && p.mesh.userData && p.mesh.userData.isSheep) return;

    p.isPolymorphed = true;
    
    // 1. Save Original Mesh (Crucial for revert)
    if (!p.mesh.userData.isSheep) {
        p.originalMesh = p.mesh;
    }

    // 2. Create Sheep
    const sheep = createSheepMesh();
    sheep.userData.isSheep = true; 
    
    // Match position/rotation
    sheep.position.copy(p.mesh.position);
    sheep.rotation.copy(p.mesh.rotation);
    
    // 3. Swap in Scene
    scene.remove(p.mesh);
    scene.add(sheep);
    
    p.mesh = sheep; 

    // 4. Update Camera Target
    // If we are currently zooming on this player, update target to new mesh
    if (isZoomed && cameraTarget === p.originalMesh) {
        cameraTarget = sheep;
    }

    if (p.id === myPlayerId || isZoomed) AUDIO.playSound('sfx_transition'); 
}

function cureSheep(p) {
    // If not polymorphic locally, do nothing
    if (!p.isPolymorphed) return;

    // 1. Remove the Sheep Mesh
    if (p.mesh && p.mesh !== p.originalMesh) {
        scene.remove(p.mesh);
        // Clean up geometry memory if possible, optional
    }

    // 2. Restore Original Mesh
    if (p.originalMesh) {
        p.mesh = p.originalMesh;
        scene.add(p.mesh);
        if(tiles[p.pos]) {
            p.mesh.position.copy(tiles[p.pos].position); 
            p.mesh.position.y = 0; 
        }
    }

    // 3. Reset Local Flag
    p.isPolymorphed = false;
    addLog(`${p.name} returns to normal form.`, "log-success");
    
    // 4. SYNC TO DB (Clear Flag)
    if (isMultiplayer && db && gameId) {
        // Only the owner of the turn (who calls endTurn -> cureSheep) or Host can clear it
        // Since endTurn logic handles cleanup, we write to DB here.
        db.ref(`games/${gameId}/players/${p.id}`).update({ isPolymorphed: false });
    }
    
    if(typeof updateHUD === 'function') updateHUD();
}

const ABILITY_LIBRARY = {
    // ================= FIGHTER SKILLS =================
    power_strike: { name: "Power Strike", desc: "Gain +5 STR for this turn only.", fn: (p) => { p.stats.str+=5; addLog("Power Strike: STR boosted!", "log-success"); updateHUD(); return true; }, img: "https://static.wixstatic.com/media/b16479_3599509de5064815a86ecbae3f9979da~mv2.jpeg" },
    intimidate: { name: "Intimidate", desc: "Force a random player to pay you 50G.", fn: (p) => { const targets=players.filter(t=>t.id!==p.id&&!t.isDead); if(targets.length>0){const t=targets[Math.floor(Math.random()*targets.length)]; addLog(`${p.name} intimidates ${t.name}!`, "log-accent"); pay(t,50,p); return true;} return false; }, img: "https://static.wixstatic.com/media/b16479_29cbfcb090ef4fc782dcf43faa34fcc4~mv2.jpeg" },
    second_wind: { name: "Second Wind", desc: "Gain 150 Gold immediately.", fn: (p) => { p.gold+=150; addLog("Second Wind: +150G", "log-gold"); updateHUD(); return true; }, img: "https://static.wixstatic.com/media/b16479_3a036a923c5945778d3b8393634892b1~mv2.jpeg" },
    shield_bash: { 
        name: "Shield Bash", 
        desc: "Stun a random enemy (Skip Next Turn).", 
        fn: (p) => { 
            const targets = players.filter(t=>t.id!==p.id&&!t.isDead); 
            if(targets.length){
                const t=targets[Math.floor(Math.random()*targets.length)]; 
                t.isSkipping=true; 
                addLog(`Shield Bash stunned ${t.name}!`, "log-epic"); 
                
                // SYNC TO DB
                if (isMultiplayer && db && gameId) {
                    db.ref(`games/${gameId}/players/${t.id}`).update({ isSkipping: true });
                }
                return true;
            } 
            return false; 
        }, 
        img: "https://static.wixstatic.com/media/b16479_d1f5ad06cfd64c688e68edd726ff65ae~mv2.jpg" 
    },
    rally: { name: "Rally", desc: "Gain +2 to all Stats for this turn.", fn: (p) => { p.stats.str+=2; p.stats.dex+=2; p.stats.int+=2; addLog("Rally: All stats boosted!", "log-success"); updateHUD(); return true; }, img: "https://static.wixstatic.com/media/b16479_362057d2967143caacaea96b6def582f~mv2.jpg" },
    // Inside ABILITY_LIBRARY -> FIGHTER SKILLS
    siege_breaker: { 
        name: "Siege Breaker", 
        desc: "Enemy Land: Roll 1d6 to kill Guards/Downgrade/Destroy. If destroyed, trigger Encounter.", 
        // Logic handled in showEncounter, but we keep a dummy fn here to prevent crashes if clicked from bar
        fn: (p) => { addLog("Use this skill when landing on Enemy Land.", "log-rare"); return false; }, 
        img: "https://static.wixstatic.com/media/b16479_c9d827929fe5405d869c8cc75834b5dd~mv2.jpg" 
    },
    veteran: { 
        name: "Veteran", 
        desc: "Permanent +1 STR. 20% Discount at Merchants.", 
        type: 'passive', 
        effect: (s) => { s.str += 1; }, 
        img: "https://static.wixstatic.com/media/b16479_9418e25969754a69a13b825cc2e70bbf~mv2.jpeg" 
    },
    iron_skin: { name: "Iron Skin", desc: "Reduce all gold penalties by 20G.", type:'passive', img: "https://static.wixstatic.com/media/b16479_c3d88e0d6986494d914fd12047d258ca~mv2.jpeg" },
    executioner: { name: "Executioner", desc: "Rolling a 6 in combat counts as 2 Successes.", type:'passive', img: "https://static.wixstatic.com/media/b16479_cee24d678cfa47568f5f632c40743626~mv2.jpeg" },
    conqueror: { name: "Conqueror", desc: "Gain 20G every time you capture a location.", type:'passive', onCapture:(p)=>{p.gold+=20; addLog("Conqueror: +20G", "log-gold");}, img: "https://static.wixstatic.com/media/b16479_9df1c28aa03e4660ab1943532691d406~mv2.jpg" },
    heavy_armor: { name: "Heavy Armor", desc: "You cannot be moved by enemy spells (Swap/Teleport).", type:'passive', img: "https://static.wixstatic.com/media/b16479_8fd52084407e44d7b5d966aa2791e22e~mv2.jpg" },
    // **VANGUARD (LOGIC IN SPAWNPLAYER)**
    vanguard: { name: "Vanguard", desc: "Start the game with a Rare Sword.", type:'passive', img: "https://static.wixstatic.com/media/b16479_de9b64e80d6745c2924fb58325d158e7~mv2.jpg" },

    // ================= WIZARD SKILLS =================
    fireball: { name: "Fireball", desc: "Pay 100G: Burn a random enemy property (Downgrade).", fn: (p) => { if(p.gold<100)return false; const ts=tiles.filter(t=>t.userData.owner!==null&&t.userData.owner!==p.id); if(ts.length){ p.gold-=100; const t=ts[Math.floor(Math.random()*ts.length)]; if(t.userData.buildingLevel>1)t.userData.buildingLevel=1; else {t.userData.owner=null; if(t.userData.prop)t.remove(t.userData.prop);} addLog(`Fireball hit ${t.userData.info.name}!`, "log-epic"); return true;} return false;}, img: "https://static.wixstatic.com/media/b16479_29ff412f99834658ac8d32d32e16849a~mv2.jpg" },
    transmute_gold: { name: "Transmute", desc: "Pay 50G: Destroy item -> Draw Treasure.", fn: (p) => { if(p.inventory.length>0 && p.gold>=50){p.gold-=50; p.inventory.splice(0,1); const c=DECK_TREASURE[Math.floor(Math.random()*DECK_TREASURE.length)]; p.inventory.push(createItemInstance(c)); addLog("Transmuted item!", "log-gold"); return true;} return false; }, img: "https://static.wixstatic.com/media/b16479_765369c1c1bd4a8abb1b752a2245f56c~mv2.jpg" },
    blink: { name: "Blink", desc: "Move 1-6 spaces immediately.", fn: (p) => { const d=Math.floor(Math.random()*6)+1; addLog(`Blinked ${d} spaces!`, "log-rare"); animateMove(p,d); return true; }, img: "https://static.wixstatic.com/media/b16479_ead02548bf264a2eb097464789b65b11~mv2.jpg" },
    time_warp: { 
        name: "Time Warp", 
        desc: "Roll 1d6. On 5-6, take another turn immediately.", 
        fn: (p) => { 
            const r = Math.floor(Math.random() * 6) + 1; 
            if (r > 4) {
                addLog(`Time Warp [${r}]: SUCCESS! Extra turn queued.`, "log-epic"); 
                p.extraTurn = true; // Set the flag
                if(typeof AUDIO !== 'undefined') AUDIO.playSound('sfx_win');
            } else {
                addLog(`Time Warp [${r}]: Failed.`, "log-fail"); 
                if(typeof AUDIO !== 'undefined') AUDIO.playSound('sfx_fail');
            }
            // Always return true to deplete the skill (it was used)
            return true; 
        },
		img: "https://static.wixstatic.com/media/b16479_8dc7a78f86354f4b8c7617155971f54d~mv2.jpg" 
		},
    polymorph: { 
        name: "Polymorph", 
        desc: "Turn enemy into a Sheep (1 Turn). Stats=1, Slow Move.", 
        fn: (p) => { 
            const targets = players.filter(x => x.id !== p.id && !x.isDead && !x.isBoss && !x.isEventEntity); 
            if(targets.length > 0) { 
                const t = targets[Math.floor(Math.random() * targets.length)]; 
                
                // Local Visual (Immediate)
                makeSheep(t); 
                addLog(`${p.name} turned ${t.name} into a sheep!`, "log-epic"); 
                
                // SYNC TO DB
                if (isMultiplayer && db && gameId) {
                    db.ref(`games/${gameId}/players/${t.id}`).update({ isPolymorphed: true });
                }
                return true; 
            } 
            addLog("No valid targets.", "log-fail"); 
            return false; 
        }, 
        img: "https://static.wixstatic.com/media/b16479_fbec81995dd34d0ebeb4b837d2e26b8d~mv2.jpg" 
    },
    arcane_eye: { name: "Arcane Eye", desc: "Teleport to the nearest Chest.", fn: (p) => { 
        const chest = tiles.find(t => t.userData.info.type === 'chest'); 
        if(chest) {
            addLog("Arcane Eye reveals treasure!", "log-rare"); 
            // Fix: Update position BEFORE animation logic triggers
            p.pos = chest.userData.id; 
            gameState = 'MOVING';
            animateTeleport(p, chest, () => { resolveLanding(p); }); 
            return true;
        } 
        return false; 
    }, img: "https://static.wixstatic.com/media/b16479_2605208fcc3946a5b0373ea5fabeacc4~mv2.jpg" },

    scholar: { name: "Scholar", desc: "Permanent +1 INT.", type:'passive', effect:(s)=>{s.int+=1;}, img: "https://static.wixstatic.com/media/b16479_dde7a886c214487e9142449b77ae86f0~mv2.jpg" },
    court_mage: { name: "Court Mage", desc: "Immune to Tax. Gain 10G when others pay Tax.", type:'passive', img: "https://static.wixstatic.com/media/b16479_60838e488fae4e7e896c8cfe64f5bc03~mv2.jpg" },
    alchemist_pas: { name: "Alchemist", desc: "Pouch of Gold creates extra treasure.", type:'passive', img: "https://static.wixstatic.com/media/b16479_e0bd1a01c0b344f086778fea802be2ca~mv2.jpg" },
    mana_shield: { name: "Mana Shield", desc: "If you would go bankrupt, lose 1 Item instead.", type:'passive', img: "https://static.wixstatic.com/media/b16479_bf689c6c7bd640c9910b56a8c1d7eeba~mv2.jpg" },
    leyline: { name: "Leyline Walker", desc: "Start at Mana Well. Gain 200G passing it.", type:'passive', img: "https://static.wixstatic.com/media/b16479_2fabcde5520b41899bf6b28a8824d4f3~mv2.jpg" },
    elemental_attune: { name: "Attunement", desc: "+1 INT for every 500G you hold.", type:'passive', effect: (s) => { const bonus = Math.floor(s.gold / 500); if(bonus > 0) s.int += bonus; }, img: "https://static.wixstatic.com/media/b16479_54c9849377094313a2bc102fe77c038b~mv2.jpg" },

    // ================= ROGUE SKILLS =================
    pickpocket: { name: "Pickpocket", desc: "Steal 10G per property from random foe.", fn: (p) => { const ts=players.filter(x=>x.id!==p.id&&!x.isDead); if(ts.length){const t=ts[Math.floor(Math.random()*ts.length)]; const amt=Math.min(t.gold, tiles.filter(l=>l.userData.owner===t.id).length*10); t.gold-=amt; p.gold+=amt; addLog(`Pickpocketed ${amt}G from ${t.name}`, "log-gold"); return true;} return false; }, img: "https://static.wixstatic.com/media/b16479_13ee3ae3151c40f58f7152857c4d97ff~mv2.jpg" },
    sprint_act: { name: "Sprint", desc: "Move 3 spaces.", fn: (p) => { animateMove(p,3); return true; }, img: "https://static.wixstatic.com/media/b16479_2a97d38d75f14a7c96eb980178f1bdf6~mv2.jpg" },
    smoke_bomb_act: { name: "Smoke Bomb", desc: "Teleport to random space (Escape).", fn: (p) => { const r=Math.floor(Math.random()*40); animateTeleport(p, tiles[r], ()=>{resolveLanding(p)}); addLog("Vanished in smoke!", "log-rare"); return true; }, img: "https://static.wixstatic.com/media/b16479_6c7a5d29595e42cdbc625397ad4a9a7d~mv2.jpeg" },
    sabotage: { name: "Sabotage", desc: "Target Tavern becomes a Camp.", fn: (p) => { const ts=tiles.filter(t=>t.userData.buildingLevel===2 && t.userData.owner!==p.id); if(ts.length){const t=ts[Math.floor(Math.random()*ts.length)]; t.userData.buildingLevel=1; addLog(`Sabotaged tavern at ${t.userData.info.name}!`, "log-fail"); return true;} return false; }, img: "https://static.wixstatic.com/media/b16479_6364e428d9504a139a2c56e1e168eb3d~mv2.jpg" },
    gamble_act: { name: "Gamble", desc: "Pay 50G. 50% chance to win 200G.", fn: (p) => { if(p.gold<50)return false; p.gold-=50; if(Math.random()>0.5){p.gold+=200; addLog("Gamble won: +200G!", "log-gold");}else{addLog("Gamble lost.", "log-fail");} updateHUD(); return true; }, img: "https://static.wixstatic.com/media/b16479_613c6b72c1984c8d93398e7f00ae2ee0~mv2.jpeg" },
    
    // **CHANGED: SHADOW STRIKE (Teleport & Steal)**
    shadow_strike: { 
        name: "Shadow Strike", 
        desc: "Teleport to target, Steal 100G. -1 Stats until recharge.", 
        fn: (p) => { 
            const enemies = players.filter(x => x.id !== p.id && !x.isDead && !x.isEventEntity);
            if (enemies.length === 0) return false;
            
            showPlayerPicker("Shadow Strike Target", enemies, (target) => {
                const amt = Math.min(100, target.gold);
                target.gold -= amt;
                p.gold += amt;
                
                // Set debuff
                p.shadowStrikeDebuff = true;
                
                // Teleport
                p.pos = target.pos;
                gameState = 'MOVING';
                addLog(`${p.name} Shadow Strikes ${target.name}! Stole ${amt}G.`, "log-epic");
                animateTeleport(p, tiles[target.pos], () => { resolveLanding(p); });
                
                // Mark class skill used
                p.classSkillDepleted = true; 
                updateHUD();
            });
            return true; // Assume success (UI will handle cancel)
        }, 
        img: "https://static.wixstatic.com/media/b16479_0b4efd14bb7c4103bbe7d434d6de7ff2~mv2.jpg" 
    },

    shadow_step: { name: "Shadow Step", desc: "Permanent +1 DEX.", type:'passive', effect:(s)=>{s.dex+=1;}, img: "https://static.wixstatic.com/media/b16479_923e7271de194ba69a6d2243650e2c41~mv2.jpg" },
    greedy: { name: "Greedy", desc: "Start with +200G.", type:'passive', effect:(s)=>{s.gold+=200;}, img: "https://static.wixstatic.com/media/b16479_9555d2fe87f74320a96619cdb7f057a4~mv2.jpg" },
    fence: { name: "Fence", desc: "Sell items for 80% value.", type:'passive', img: "https://static.wixstatic.com/media/b16479_7f7f664290b14d51a9aa304396c46d67~mv2.jpg" },
    skeleton_key: { name: "Skeleton Key", desc: "Immune to Dungeon. (Trap: Steal 50G).", type:'passive', onEnemyLanding:(v,o)=>{if(v.gold>=50){v.gold-=50;o.gold+=50;addLog("Skeleton Key Trap: +50G", "log-accent");}}, img: "https://static.wixstatic.com/media/b16479_6c10e5ce01164b79bb957d07613143ae~mv2.jpg" },
    cutpurse: { name: "Cutpurse", desc: "Steal 5G passing. Steal 20G landing.", type: 'passive', img: "https://static.wixstatic.com/media/b16479_ebce90cafeb5404b96e00cb557ce20b1~mv2.jpg", onLanding: (p) => { /* Logic in resolveLanding */ } },
    ambush_pas: { name: "Ambush", desc: "When attacking Enemy space, gain +1 Success.", type:'passive', img: "https://static.wixstatic.com/media/b16479_6274cb33103f496d958019147a605599~mv2.jpeg" },

    // ================= CLERIC SKILLS =================
    heal_spell: { name: "Heal", desc: "Clear negative status (Jail/Stun).", fn: (p) => { if(p.isSkipping){p.isSkipping=false; addLog("Healed status!", "log-success"); return true;} addLog("No status to heal.", "log-fail"); return false; }, img: "https://static.wixstatic.com/media/b16479_6fbb98ea84a9479b98dd0441fd7152b6~mv2.jpg" },
    smite: { name: "Smite", desc: "Instant Capture/Upgrade current tile.", fn: (p) => { const t=tiles[p.pos]; if(t.userData.info.cost>0){capture(t,p,1); addLog("Smite: Land Conquered!", "log-epic"); return true;} return false; }, img: "https://static.wixstatic.com/media/b16479_de48e0494048408dbd67d6c2008aee28~mv2.jpg" },
    bless: { name: "Bless", desc: "Gain +5 INT for this turn.", fn: (p) => { p.stats.int+=5; addLog("Blessed!", "log-success"); updateHUD(); return true; }, img: "https://static.wixstatic.com/media/b16479_75752aecbee444ada136a1d9c923b8f8~mv2.jpg" },
    divine_intervention: { name: "Intervention", desc: "Roll 1d6. On 6, Gain 500G.", fn: (p) => { if(Math.floor(Math.random()*6)+1===6){p.gold+=500; addLog("Divine Gift: +500G!", "log-epic"); updateHUD(); return true;} addLog("Prayers unanswered.", "log-fail"); return true; }, img: "https://static.wixstatic.com/media/b16479_17b9cb42fac041e6ab622b3a45d6b3f0~mv2.jpg" },
    
    // **CHANGED: SANCTUARY (Shrine + Teleport)**
    sanctuary: { 
        name: "Sanctuary", 
        desc: "Place Shrine. If Shrine exists, Teleport to it.", 
        fn: (p) => { 
            // 1. Check if Shrine exists
            if (p.sanctuaryPos !== undefined && p.sanctuaryPos !== null) {
                // Teleport Logic
                const target = tiles[p.sanctuaryPos];
                p.pos = p.sanctuaryPos;
                gameState = 'MOVING';
                animateTeleport(p, target, () => { 
                    resolveLanding(p);
                    // Remove Shrine
                    if (p.sanctuaryMesh) { scene.remove(p.sanctuaryMesh); p.sanctuaryMesh = null; }
                    p.sanctuaryPos = null;
                    addLog("Returned to Sanctuary.", "log-success");
                });
                
                // Consumes Skill
                p.classSkillDepleted = true; 
                updateHUD();
                return true;
            } 
            // 2. Place Shrine
            else {
                p.sanctuaryPos = p.pos;
                p.sanctuaryMesh = createShrineMesh();
                p.sanctuaryMesh.position.copy(tiles[p.pos].position);
                scene.add(p.sanctuaryMesh);
                addLog("Sanctuary established!", "log-epic");
                
                // DOES NOT CONSUME SKILL
                return false; 
            }
        }, 
        img: "https://static.wixstatic.com/media/b16479_f33f291487d64a468e9a05b3811a0a3d~mv2.jpg" 
    },
    
    // **CHANGED: EXORCISM (Destroy Equip or Gold)**
    exorcism: { 
        name: "Exorcism", 
        desc: "Destroy random enemy equipment (or -20G).", 
        fn: (p) => { 
            const enemies = players.filter(x => x.id !== p.id && !x.isDead && !x.isEventEntity);
            if (enemies.length === 0) return false;

            showPlayerPicker("Exorcism Target", enemies, (target) => {
                // Check items
                const slots = ['head', 'body', 'main', 'off'].filter(s => target.equipment[s]);
                
                if (slots.length > 0) {
                    const slot = slots[Math.floor(Math.random() * slots.length)];
                    const item = target.equipment[slot];
                    target.equipment[slot] = null; // Destroy
                    addLog(`Exorcised ${item.name} from ${target.name}!`, "log-epic");
                } else {
                    target.gold = Math.max(0, target.gold - 20);
                    addLog(`${target.name} has no gear. Lost 20G.`, "log-fail");
                }
                
                p.classSkillDepleted = true;
                updateHUD();
            });
            return true; 
        }, 
        img: "https://static.wixstatic.com/media/b16479_fa1402ef5d59495c93b503d0284a6ee8~mv2.jpg" 
    },

    devotion: { name: "Devotion", desc: "Permanent +1 INT.", type:'passive', effect:(s)=>{s.int+=1;}, img: "https://static.wixstatic.com/media/b16479_4ad91e74342448b08fd19799f492d69b~mv2.jpg" },
    medic: { name: "Medic", desc: "Permanent +1 STR.", type:'passive', effect:(s)=>{s.str+=1;}, img: "https://static.wixstatic.com/media/b16479_e222db131e6e4e2180c5bd4dcd0dd6f4~mv2.jpg" },
    holy_aura: { name: "Holy Aura", desc: "Gain 20G when landing on another hero.", type:'passive', onLanding:(p)=>{const hit=players.some(x=>x.id!==p.id&&x.pos===p.pos); if(hit)p.gold+=20;}, img: "https://static.wixstatic.com/media/b16479_967b2ee34245413a8b04aa43b0fe04b8~mv2.jpg" },
    spirit_tithe: { name: "Spirit Tithe", desc: "Gain 5G on enemy land, 10G on own land.", type:'passive', onLanding:(p)=>{const t=tiles[p.pos]; if(t.userData.owner===p.id)p.gold+=10; else if(t.userData.owner!==null)p.gold+=5;}, img: "https://static.wixstatic.com/media/b16479_73cb0754c25246689fbe4db244b98da1~mv2.jpg" },
    
    // **CHANGED: PACIFIST (Buff + Logic)**
    pacifist: { name: "Pacifist", desc: "Fleeing gives +30G and +1 All Stats (Temp).", type:'passive', img: "https://static.wixstatic.com/media/b16479_203666cbf52f4677ad7eb5a9ab696105~mv2.jpg" },
    
    // **CHANGED: RESURRECTION (Bankrupt Trigger)**
    resurrection: { name: "Resurrection", desc: "Survive Bankruptcy once (+500G, -1 Stats).", type:'passive', img: "https://static.wixstatic.com/media/b16479_0da06ce557fe4487a6d48a0a174bee56~mv2.jpg" },
    
    // --- GENERIC/ITEM ABILITIES ---
    dash: { name: "Dash", desc: "Move 3 spaces.", fn: (p) => { animateMove(p,3); return true; }, img: "https://static.wixstatic.com/media/b16479_41cfe447b8eb4376a3b8d87b7adc1fbe~mv2.jpeg" },
    teleport: { name: "Teleport", desc: "Warp to Inn.", fn: (p) => { p.pos=0; animateTeleport(p,tiles[0],()=>{resolveLanding(p)}); return true; }, img: "https://static.wixstatic.com/media/b16479_e2653f032408459ea8d64eb87faf86fb~mv2.jpeg" },
    heal: { name: "Heal Potion", desc: "Cure status.", fn: (p) => { p.isSkipping=false; addLog("Healed!", "log-success"); return true; }, img: "https://static.wixstatic.com/media/b16479_6fbb98ea84a9479b98dd0441fd7152b6~mv2.jpg" },
    transmute: { name: "Transmute", desc: "Item to Gold.", fn: (p) => { if(p.inventory.length){p.gold+=300; p.inventory.shift(); return true;} return false; }, img: "https://static.wixstatic.com/media/b16479_6c7a5d29595e42cdbc625397ad4a9a7d~mv2.jpeg" },

    // --- GENERIC ITEM TRAITS (Replace from here down) ---
    midas: { name: "Midas Touch", desc: "Double Gold from 'Pouch of Gold' and 'Lucky Coin'.", type:'passive', img: "https://static.wixstatic.com/media/b16479_869668d07a5f47fe804e17ab6c6306e1~mv2.jpg" },
    well_made: { name: "Well Made", desc: "This item sells for 3x its normal value.", type:'passive', img: "https://static.wixstatic.com/media/b16479_6fbb98ea84a9479b98dd0441fd7152b6~mv2.jpg" },
    freeze: { 
        name: "Ice Blast", 
        desc: "A random player skips their next turn.", 
        fn: (p) => { 
            const ts=players.filter(t=>t.id!==p.id&&!t.isDead); 
            if(ts.length){
                const t=ts[Math.floor(Math.random()*ts.length)]; 
                t.isSkipping=true; 
                addLog(`Ice Blast froze ${t.name}!`, "log-epic"); 
                
                // SYNC TO DB
                if (isMultiplayer && db && gameId) {
                    db.ref(`games/${gameId}/players/${t.id}`).update({ isSkipping: true });
                }
                return true;
            } 
            return false; 
        }, 
        img: "https://static.wixstatic.com/media/b16479_4449fff43db746d2962beedde6da3ba6~mv2.jpg" 
    },
    scavenge: { name: "Scavenge", desc: "Gain 10G when capturing enemy space.", type:'passive', onCapture:(p)=>{p.gold+=10; addLog("Scavenge: +10G", "log-gold");}, img: "https://static.wixstatic.com/media/b16479_4d3e9a05134247fab12617463bdca1ef~mv2.jpg" },
    haggler: { name: "Haggler", desc: "All Shop items cost 25% less.", type:'passive', img: "https://static.wixstatic.com/media/b16479_2ba70fe3c905462aba90a1c434163f08~mv2.jpeg" },
    gold_rush: { name: "Gold Rush", desc: "Gain +50G when landing on a Chest.", type:'passive', onLanding: (p) => { if(tiles[p.pos].userData.info.type === 'chest') { p.gold += 50; addLog("Gold Rush: +50G!", "log-gold"); updateHUD(); } }, img: "https://static.wixstatic.com/media/b16479_a16b936431f54cb9b0c14fc110db0363~mv2.jpeg" },
    escape_artist: { name: "Escape Artist", desc: "Fleeing awards gold reward without fighting.", type:'passive', img: "https://static.wixstatic.com/media/b16479_6c7a5d29595e42cdbc625397ad4a9a7d~mv2.jpeg" },
    divine_shield: { name: "Divine Shield", desc: "Ignore the next penalty/damage.", fn: (p) => { addLog("Divine Shield activated!", "log-epic"); return true; }, img: "https://static.wixstatic.com/media/b16479_c8fb1f2502ce472bb9fb6d19d463285c~mv2.jpeg" },
    landlord: { name: "Landlord", desc: "Enemies pay +20% Rent on your properties.", type:'passive', img: "https://static.wixstatic.com/media/b16479_8d16ceb9c83448528c0309942f785c8a~mv2.jpeg" },
    vampirism: { name: "Vampirism", desc: "Gain 10G for every successful die roll in combat.", type:'passive', img: "https://static.wixstatic.com/media/b16479_6a42b45b920a4bc6bd8f92bc8fc51ad1~mv2.jpeg" },
    gamblers_luck: { name: "Gambler's Luck", desc: "Prompt to reroll 1s.", type: 'active', fn: (p) => { return false; }, img: "https://static.wixstatic.com/media/b16479_613c6b72c1984c8d93398e7f00ae2ee0~mv2.jpeg" },
    ambush_master: { name: "Ambush", desc: "Start combat with 1 automatic Success.", type:'passive', img: "https://static.wixstatic.com/media/b16479_6274cb33103f496d958019147a605599~mv2.jpeg" },
    might: { name: "Giant's Str", desc: "Gain +5 STR until end of turn.", fn: (p) => { p.stats.str += 5; addLog("Strength surged!", "log-success"); updateHUD(); return true; }, img: "https://static.wixstatic.com/media/b16479_966a061562c2433bbcefaec1ecf83776~mv2.jpeg" },
    focus: { name: "Mind's Eye", desc: "Gain +5 INT until end of turn.", fn: (p) => { p.stats.int += 5; addLog("Focus sharpened!", "log-success"); updateHUD(); return true; }, img: "https://static.wixstatic.com/media/b16479_1066eb1edb9b4611b0513793cbbfacbf~mv2.jpeg" },
    agility: { name: "Cat's Grace", desc: "Gain +5 DEX until end of turn.", fn: (p) => { p.stats.dex += 5; addLog("Reflexes heightened!", "log-success"); updateHUD(); return true; }, img: "https://static.wixstatic.com/media/b16479_dff1cef153fd46f48cf12f64ba7217fd~mv2.jpeg" },
    bounty: { name: "Bounty Hunter", desc: "Gain 50G when winning a fight.", type: 'passive', onCombatVictory: (p) => { p.gold += 50; addLog("Bounty Hunter Reward: +50G", "log-gold"); updateHUD(); }, img: "https://static.wixstatic.com/media/b16479_e5a29d46970543149ab7224376250d34~mv2.jpeg" },
    lucky: { name: "Lucky Charm", desc: "Prompt to Reroll movement dice.", type: 'active', fn: (p) => { return false; }, img: "https://static.wixstatic.com/media/b16479_c5e3924f36c94d2793f1f3fd2ee349ad~mv2.jpeg" },
    anchor: { name: "Iron Anchor", desc: "You cannot be moved by enemy effects.", type:'passive', img: "https://static.wixstatic.com/media/b16479_1771400b778146b4871aad58992050b5~mv2.jpeg" }
};

// --- ABILITY NAMING & IMAGE CONFIG ---

// Maps Ability IDs to descriptive prefixes/adjectives
const ABILITY_PREFIXES = {
    // Fighter
    power_strike: "Titan's", intimidate: "Tyrant's", second_wind: "Renewing", shield_bash: "Bashing", rally: "Captain's", siege_breaker: "Breaching",
    veteran: "Veteran's", iron_skin: "Iron", executioner: "Executioner's", conqueror: "Conqueror's", heavy_armor: "Fortified", vanguard: "Vanguard",
    // Wizard
    fireball: "Infernal", transmute_gold: "Gilded", blink: "Warping", time_warp: "Chronos", polymorph: "Polymorphing", arcane_eye: "Seer's",
    scholar: "Scholar's", court_mage: "Noble's", alchemist_pas: "Alchemist's", mana_shield: "Shielding", leyline: "Leyline", elemental_attune: "Prismatic",
    // Rogue
    pickpocket: "Thief's", sprint_act: "Sprinter's", smoke_bomb_act: "Vanishing", sabotage: "Saboteur's", gamble_act: "Gambler's", shadow_strike: "Shadow",
    shadow_step: "Ghostly", greedy: "Greedy", fence: "Smuggler's", skeleton_key: "Burglar's", cutpurse: "Bandit's", ambush_pas: "Stalker's",
    // Cleric
    heal_spell: "Mending", smite: "Crusader's", bless: "Blessed", divine_intervention: "Divine", sanctuary: "Saint's", exorcism: "Banishing",
    devotion: "Devoted", medic: "Healer's", holy_aura: "Radiant", spirit_tithe: "Tithing", pacifist: "Peacekeeper's", resurrection: "Phoenix",
    // Generic
    dash: "Swift", teleport: "Warp", heal: "Restoring", transmute: "Golden",
    midas: "Midas", well_made: "Masterwork", freeze: "Frozen", scavenge: "Scavenger's", haggler: "Merchant's", 
    gold_rush: "Prospector's", escape_artist: "Elusive", divine_shield: "Guardian's", landlord: "Baron's", 
    vampirism: "Vampiric", gamblers_luck: "Lucky", ambush_master: "Assassin's", might: "Ogre's", focus: "Sage's", 
    agility: "Cat's", bounty: "Hunter's", lucky: "Fortunate", anchor: "Steady"
};

// --- ITEM IMAGE POOLS ---
// Add as many URLs as you want for each category. 
// The game will pick one randomly when the item is generated.
const ITEM_IMAGE_POOLS = {
    // === EQUIPMENT ===
    "Sword": [
        "https://static.wixstatic.com/media/b16479_b4a21594af4e4193b6c317d64bbb66e7~mv2.png", "https://static.wixstatic.com/media/b16479_0bc9d0d7f2ca41d9a01c583c066f8a7f~mv2.png", "https://static.wixstatic.com/media/b16479_798726f409f94ed2a945d75c2ee0b9d6~mv2.png", "https://static.wixstatic.com/media/b16479_9045b0125f78454f9256986832670bbb~mv2.png", "https://static.wixstatic.com/media/b16479_3fe0c98939b54aea88de6744c221fcb8~mv2.png", "https://static.wixstatic.com/media/b16479_9385a8b28de143c799dc933769602547~mv2.png", "https://static.wixstatic.com/media/b16479_ea05d90d3a7a4e529575f71e9897195e~mv2.png", "https://static.wixstatic.com/media/b16479_731edc4143e049f7ac295207fd62d8ad~mv2.png", "https://static.wixstatic.com/media/b16479_856ff4e996d9432589503bdcd74aa029~mv2.png", "https://static.wixstatic.com/media/b16479_69a123d82e81487d89005a197a42e3d5~mv2.png", "https://static.wixstatic.com/media/b16479_a47926b150044ab7bf4c60a048ab2d29~mv2.png", "https://static.wixstatic.com/media/b16479_3ef9327bbd504fce9b5518747e31fbff~mv2.png", "https://static.wixstatic.com/media/b16479_4532d20d87614b3ea2e122f034dfb8bc~mv2.png", "https://static.wixstatic.com/media/b16479_e1892c1590ef49498897fa78fc8ef2df~mv2.png", "https://static.wixstatic.com/media/b16479_4758dc0bdca04d2d97ac60c7a781c589~mv2.png"
    ],
	    "Axe": [
        "https://static.wixstatic.com/media/b16479_81988a9f29d0416c94fb11d8883edd49~mv2.png", "https://static.wixstatic.com/media/b16479_5c48354a0b544c4090fadd5ff2276ad8~mv2.png", "https://static.wixstatic.com/media/b16479_83aebd9f69244800b5b27d8dfd0ce50d~mv2.png", "https://static.wixstatic.com/media/b16479_e7fa46ac7163400ca18581e788ac01ee~mv2.png", "https://static.wixstatic.com/media/b16479_c6d00234cdcd45d1ac5c6912f1e56e8e~mv2.png", "https://static.wixstatic.com/media/b16479_674635048c4440a8b831c5b0c7ea5aaf~mv2.png", "https://static.wixstatic.com/media/b16479_68c9ceedcc114ea2981c69fc8335fd72~mv2.png", "https://static.wixstatic.com/media/b16479_a30b130af9bd4483a084990e4fa07268~mv2.png", "https://static.wixstatic.com/media/b16479_d78df7d407c54f4ebcb0b3cc6e5eac03~mv2.png", "https://static.wixstatic.com/media/b16479_4a36ed73536b4683b315080c90bb098a~mv2.png", "https://static.wixstatic.com/media/b16479_73acf1dcecd847eeb94c837bdfbef9bd~mv2.png"
    ],
    "Hammer": [
        "https://static.wixstatic.com/media/b16479_e16af69c72364203a172005ed37849e8~mv2.png", "https://static.wixstatic.com/media/b16479_db3f11a9b7f346b49895109bf448d731~mv2.png", "https://static.wixstatic.com/media/b16479_010135b49a2d4a5dac3759e02f1001d1~mv2.png", "https://static.wixstatic.com/media/b16479_d6ce6fc12da248c2a80febdf88c7c9ab~mv2.png", "https://static.wixstatic.com/media/b16479_58b7297549eb43d2848eb0d13f9b1c47~mv2.png", "https://static.wixstatic.com/media/b16479_aca038df21454a489fbcb1ef3208a25e~mv2.png", "https://static.wixstatic.com/media/b16479_001521f1f6aa4691843f888292636131~mv2.png", "https://static.wixstatic.com/media/b16479_2bddedbb1f044844a4124f36963fc32d~mv2.png", "https://static.wixstatic.com/media/b16479_51b47a8068b94b5f9b178a15791d630a~mv2.png", "https://static.wixstatic.com/media/b16479_230e470cd7b5444e92681a5ab8403997~mv2.png", "https://static.wixstatic.com/media/b16479_986bf380e3934165a7c240e4d068504f~mv2.png", "https://static.wixstatic.com/media/b16479_c44c7b2e9a71480bbfafbeec699b0aac~mv2.png"
    ],
    "Spear": [
        "https://static.wixstatic.com/media/b16479_52f8aa3723a94604810e6b31717022e4~mv2.png", "https://static.wixstatic.com/media/b16479_cc937da8d3734fb2b6de55dcb0f01f5d~mv2.png", "https://static.wixstatic.com/media/b16479_50270327e1734e18817848bb4c8d9798~mv2.png", "https://static.wixstatic.com/media/b16479_70942de2af0f40e1840213f43fd08260~mv2.png", "https://static.wixstatic.com/media/b16479_7d2c52d41edb48daa36d97f24af6c963~mv2.png", "https://static.wixstatic.com/media/b16479_b30e1e5627744709aa14a5671b54a8e2~mv2.png", "https://static.wixstatic.com/media/b16479_33f686fd2b184a05885040c2801da42d~mv2.png", "https://static.wixstatic.com/media/b16479_cee766083c7744ab92d6acab28fa5c3f~mv2.png", "https://static.wixstatic.com/media/b16479_682183d30ba94784ab7aa79141f51441~mv2.png", "https://static.wixstatic.com/media/b16479_00d9868633a34093affc950500f29400~mv2.png", "https://static.wixstatic.com/media/b16479_155c22b61e93433fae514cb9347591fd~mv2.png"
    ],
    "Shield": [
        "https://static.wixstatic.com/media/b16479_a03f80fa92274fdd9ee00b29fc700192~mv2.png", "https://static.wixstatic.com/media/b16479_7eda0173ff724ff0ba0de0b9d0be0573~mv2.png", "https://static.wixstatic.com/media/b16479_a9e25b5147e445b0b8cd803d15643387~mv2.png", "https://static.wixstatic.com/media/b16479_103ab43c8eb4460fa6e77a14d342a438~mv2.png", "https://static.wixstatic.com/media/b16479_99f00a87956c49129d7260efc32fe234~mv2.png", "https://static.wixstatic.com/media/b16479_ae9b56e03010468eb4f2826b042aed28~mv2.png", "https://static.wixstatic.com/media/b16479_afd89deac7664ad19d199ba217c1f060~mv2.png", "https://static.wixstatic.com/media/b16479_15ed80d0e6b745f691e4db13e3299f23~mv2.png", "https://static.wixstatic.com/media/b16479_0b5d32f4e26246eeaa15d6818c4fca88~mv2.png", "https://static.wixstatic.com/media/b16479_874eb8e380b84da08d80c50bc59daa9b~mv2.png", "https://static.wixstatic.com/media/b16479_bdb5afdcba9543c5b81aa8e6a894e45f~mv2.png", "https://static.wixstatic.com/media/b16479_eabcd570b2ca4a359c4b5ff98df6a691~mv2.png", "https://static.wixstatic.com/media/b16479_6ed2ea9d62df412180fa1c711e7b2fc7~mv2.png", "https://static.wixstatic.com/media/b16479_869b39284aa8438596cad9a6e63fb4f7~mv2.png"
    ],
    "Helm": [
        "https://static.wixstatic.com/media/b16479_e2b59a0af8964a16ba2d0689cbc96f95~mv2.png", "https://static.wixstatic.com/media/b16479_bffdff07708e408e948509b9d959031b~mv2.png", "https://static.wixstatic.com/media/b16479_95feaf30e4f940aba338cc6448fe2953~mv2.png", "https://static.wixstatic.com/media/b16479_ad78a6403b4a48429515decc3a52a36e~mv2.png", "https://static.wixstatic.com/media/b16479_22856ff220744951afc4800aa5f5ae8f~mv2.png"
    ],
    "Armor": [
        "https://static.wixstatic.com/media/b16479_38a18892e6f7455ca973664e1b8962e8~mv2.png", "https://static.wixstatic.com/media/b16479_7b13fca42dc64e5089422bf3e7806bfd~mv2.png", "https://static.wixstatic.com/media/b16479_4d857b651ab4436f920b8281c42cb938~mv2.png", "https://static.wixstatic.com/media/b16479_df4d6ed423b7473fb9d46553ce373e30~mv2.png", "https://static.wixstatic.com/media/b16479_81cba66f4084448ab653cfcebe61a5ae~mv2.png"
    ],
    "Wand": [
        "https://static.wixstatic.com/media/b16479_43ffac41a1d54299a02fa88bb0189375~mv2.png", "https://static.wixstatic.com/media/b16479_3c3c56801415469aad8ec4a97786e545~mv2.png", "https://static.wixstatic.com/media/b16479_d61b206ad71b49bd887ff20c8271ae8e~mv2.png", "https://static.wixstatic.com/media/b16479_71030fe086154dfe9e57eeb3032f44b0~mv2.png", "https://static.wixstatic.com/media/b16479_432c5a44e03e4b82b3f28c6d377e2fc9~mv2.png", "https://static.wixstatic.com/media/b16479_16f35f2e12284f23a07c6f91c4912b19~mv2.png"
    ],
    "Staff": [
        "https://static.wixstatic.com/media/b16479_db54e75db5ba408797ab74babcff4774~mv2.png", "https://static.wixstatic.com/media/b16479_54f19d37481a4320ac6402bcf5582af7~mv2.png", "https://static.wixstatic.com/media/b16479_4f7cbe4edbf64866ab49b472be344e58~mv2.png", "https://static.wixstatic.com/media/b16479_4e5af2243b9d46f388193adcaee10981~mv2.png", "https://static.wixstatic.com/media/b16479_44af651652ec4e729f898c8fbe65bd87~mv2.png", "https://static.wixstatic.com/media/b16479_bbfdc680c5be4ce6807ce4da7d49218d~mv2.png", "https://static.wixstatic.com/media/b16479_791fe5c3336641c88b3b0ae5ce6ce35d~mv2.png", "https://static.wixstatic.com/media/b16479_cf4a828fd73e4b52bee6f4acb0dd7a8e~mv2.png", "https://static.wixstatic.com/media/b16479_86cb8ae05bb546ff99db964b4556babe~mv2.png", "https://static.wixstatic.com/media/b16479_411cca6e861244c5b17ef76f9b3526bb~mv2.png", "https://static.wixstatic.com/media/b16479_165dcbb93bd24a7d860d1467dfe8c22d~mv2.png"
    ],
    "Bow": [
        "https://static.wixstatic.com/media/b16479_3bd83b51904040de87a05413a9fb2fc6~mv2.png", "https://static.wixstatic.com/media/b16479_6d89cb7e820e47d68daf3378d7610247~mv2.png", "https://static.wixstatic.com/media/b16479_b07649eb8f74408caea57644abc65212~mv2.png", "https://static.wixstatic.com/media/b16479_ff45b316b0224f1e892551b0e9c5885b~mv2.png", "https://static.wixstatic.com/media/b16479_7fd954b90cfe4bb3936b011122c6cb61~mv2.png", "https://static.wixstatic.com/media/b16479_c1917c845f1f4c98a776440a3c036e07~mv2.png", "https://static.wixstatic.com/media/b16479_ac99e8880f9d400bab21e9b1ef56d241~mv2.png", "https://static.wixstatic.com/media/b16479_aab1129fc8024211bb1a84fa6e5c9421~mv2.png", "https://static.wixstatic.com/media/b16479_3daa70c929ed4ab6bdfdd4160d7a5b9c~mv2.png"
    ],
    "Dagger": [
        "https://static.wixstatic.com/media/b16479_8fcf4b4eb377492c9f2bec6ddd6d51f9~mv2.png", "https://static.wixstatic.com/media/b16479_bae94c86a5264d628972c6fef0d2d223~mv2.png", "https://static.wixstatic.com/media/b16479_ab0baa8f373546df97052bde9ed91fb9~mv2.png", "https://static.wixstatic.com/media/b16479_030f85fddbb045af9efaf85c0a163410~mv2.png", "https://static.wixstatic.com/media/b16479_371e09162ad34700837c83c77987306a~mv2.png", "https://static.wixstatic.com/media/b16479_cb64c8002bfa4eac92a9cbf10c073231~mv2.png", "https://static.wixstatic.com/media/b16479_8f3425df2c504f599704b90d09cca05b~mv2.png", "https://static.wixstatic.com/media/b16479_3df342ff771445768aee88a4ddf33a50~mv2.png", "https://static.wixstatic.com/media/b16479_017efb6209e246e88aeb7b1137e227b5~mv2.png", "https://static.wixstatic.com/media/b16479_e5ef3df57f144cad92efa47b31772651~mv2.png"
    ],
    "Boots": [
        "https://static.wixstatic.com/media/b16479_4f3bc72dd85c4fa1a834fb3f40660095~mv2.png", "https://static.wixstatic.com/media/b16479_b4e69e7a855947da8cef539fb1935505~mv2.png", "https://static.wixstatic.com/media/b16479_5d5ecceab1f748919f97f3db1cfd9e4d~mv2.png", "https://static.wixstatic.com/media/b16479_05ed55cfd0b945fa936a51a2d3d26c97~mv2.png", "https://static.wixstatic.com/media/b16479_af4e5d7758d64429b722c3e2b18050af~mv2.png", "https://static.wixstatic.com/media/b16479_8cf296e60bad4827abee99215bbeea17~mv2.png"
    ],
    "Gloves": [
        "https://static.wixstatic.com/media/b16479_e8438c097a7f449693828dfa9ef7a5ff~mv2.png", "https://static.wixstatic.com/media/b16479_8e176bb9ea804d939a0d4a22370bd098~mv2.png", "https://static.wixstatic.com/media/b16479_2dd95362d1494c8eb1824a1f9e59ea90~mv2.png", "https://static.wixstatic.com/media/b16479_2a0d9a3fa1de41f0afbcf05931281ee2~mv2.png", "https://static.wixstatic.com/media/b16479_d6ab40f159634d559b5009d76da193ba~mv2.png", "https://static.wixstatic.com/media/b16479_4d7b4b17d4d241169ef101db169962b3~mv2.png"
    ],
    "Ring": [
        "https://static.wixstatic.com/media/b16479_cb387a62494547d5a5ae1fe9d972e469~mv2.png", "https://static.wixstatic.com/media/b16479_17be1a7118fa4e4aa4085a15769d5d9d~mv2.png", "https://static.wixstatic.com/media/b16479_e2c69a4b9ed14bf08440b6f0216ae827~mv2.png", "https://static.wixstatic.com/media/b16479_aea82eee16fb46fd9a220522381e4c21~mv2.png", "https://static.wixstatic.com/media/b16479_1e59b17b203747db89c72d0418db3fa8~mv2.png", "https://static.wixstatic.com/media/b16479_5bcdd5372b6d4ecfa618561ebb86b8c8~mv2.png", "https://static.wixstatic.com/media/b16479_f1480787dcbb440ea098f7704f62e2ee~mv2.png", "https://static.wixstatic.com/media/b16479_95363b158a0b4c37aba1a542472604de~mv2.png", "https://static.wixstatic.com/media/b16479_b6bb0ea423134557b288e13980213001~mv2.png", "https://static.wixstatic.com/media/b16479_79005a590c2747ac91b5162ae5820100~mv2.png", "https://static.wixstatic.com/media/b16479_b017f18d5b3441c29a1d953cf0878c5d~mv2.png"
    ],
    "Amulet": [
        "https://static.wixstatic.com/media/b16479_7c56222743b24558bd7f1d2871898516~mv2.png", "https://static.wixstatic.com/media/b16479_9bd39b76a7c54423a0cdb70bafed95a7~mv2.png", "https://static.wixstatic.com/media/b16479_6419bcc8d35145a18275bcd32d8bd6b5~mv2.png", "https://static.wixstatic.com/media/b16479_11341b7dfcb54715b85f2f077250b6ad~mv2.png", "https://static.wixstatic.com/media/b16479_54e8142a1c8244d2851658cf93c16947~mv2.png", "https://static.wixstatic.com/media/b16479_ca44b07638c74e30b55dbe41c86d5f28~mv2.png", "https://static.wixstatic.com/media/b16479_b63b70b1f3b94d3ba57764b0e34d5633~mv2.png", "https://static.wixstatic.com/media/b16479_0431e1f0eb234f24970ebbbf96c13049~mv2.png", "https://static.wixstatic.com/media/b16479_c8334c03695a4b98a61cbbd586a45d39~mv2.png", "https://static.wixstatic.com/media/b16479_4b0d7205dfbf4da3871504b9efcc4854~mv2.png", "https://static.wixstatic.com/media/b16479_c3677800edb54af294c64ba94fb0306c~mv2.png"
    ],
    "Cloak": [
        "https://static.wixstatic.com/media/b16479_6ebe2f2ccf254391ba4f3aed87956b60~mv2.png", "https://static.wixstatic.com/media/b16479_2186a046869c4a418d643c483385d9b6~mv2.png", "https://static.wixstatic.com/media/b16479_b9d9ea82d7d046c9977ed3f0625acfd3~mv2.png", "https://static.wixstatic.com/media/b16479_3edd1eaa8a56460ab686dd7b5a64d08e~mv2.png", "https://static.wixstatic.com/media/b16479_53eb9d93e2ab4328bd48ee16dd208968~mv2.png", "https://static.wixstatic.com/media/b16479_0ede1c5215744b5a8dad7f8503d88379~mv2.png", "https://static.wixstatic.com/media/b16479_6c2998bd35464f97aabea7299da75ddd~mv2.png", "https://static.wixstatic.com/media/b16479_7c7cdcff453640fb84ac0d5576e19180~mv2.png", "https://static.wixstatic.com/media/b16479_c12180b8b799462eaaecefdb1276d9e6~mv2.png"
    ],
    "Belt": [
        "https://static.wixstatic.com/media/b16479_a08b2159d4c14684bae67e09843fd220~mv2.png", "https://static.wixstatic.com/media/b16479_ece4f9186c0249b7979a6d6fe491f39d~mv2.png", "https://static.wixstatic.com/media/b16479_5b45905d08414f7cab07c8060e76df49~mv2.png", "https://static.wixstatic.com/media/b16479_e95565fcb16f41a980e663bacead23d8~mv2.png", "https://static.wixstatic.com/media/b16479_75630562eba041b490b01e5150315ede~mv2.png", "https://static.wixstatic.com/media/b16479_2f20590f6a9e4684897fe7da16ca4c18~mv2.png", "https://static.wixstatic.com/media/b16479_54ac04b153774efe82b7b3ef9feadb41~mv2.png", "https://static.wixstatic.com/media/b16479_309ba28cdcdd4de2bee543834bd2982f~mv2.png", "https://static.wixstatic.com/media/b16479_1be13f5919414fcb8b42a4907bb44116~mv2.png"
    ],

    // === CONSUMABLES & SCROLLS ===
    "Pouch of Gold": [
        "https://static.wixstatic.com/media/b16479_81538fe3a32548caa2604077f9d11cd6~mv2.png",
    ],
    "Lucky Coin": [
        "https://static.wixstatic.com/media/b16479_18e0db4a44244ff39644a7f7d40190c9~mv2.png",
    ],
    "Town Portal": [
        "https://static.wixstatic.com/media/b16479_c843409e1c8240259910310d2a7e052a~mv2.png",
    ],
    "Sprint Scroll": [
        "https://static.wixstatic.com/media/b16479_3de53f38c8a84a49a12a7f323ece6446~mv2.png",
    ],
    "Transmute Scroll": [
        "https://static.wixstatic.com/media/b16479_2f9dacc953eb4494b841ad85206538f0~mv2.png",
    ],
    "Elixir of Strength": [
        "https://static.wixstatic.com/media/b16479_a54dc18f484e4fbda6fba32b35b9251e~mv2.png",
    ],
    "Elixir of Speed": [
        "https://static.wixstatic.com/media/b16479_27995ec76358483a81d95ea86b4f274f~mv2.png",
    ],
    "Elixir of Wisdom": [
        "https://static.wixstatic.com/media/b16479_cf94bf5f4baf4b3e807c4b422e5df0ae~mv2.png",
    ],
    "Builder's Hammer": [
        "https://static.wixstatic.com/media/b16479_f099d02754e34f72a1aa4003914e2a10~mv2.png",
    ],
    "Mercenary Contract": [
        "https://static.wixstatic.com/media/b16479_beaac8471c8c447cbae344e9891d1608~mv2.png",
    ],
    "Thief's Glove": [
        "https://static.wixstatic.com/media/b16479_e8a750d554f34eb0a230eb8c62736820~mv2.png",
    ],
    "Royal Pardon": [
        "",
    ],
    "Map to Riches": [
        "https://static.wixstatic.com/media/b16479_d5392f0b79dc45adb47a3b0fdbc18653~mv2.png",
    ],
    "Investment Deed": [
        "",
    ],
    "Warp Stone": [
        "https://static.wixstatic.com/media/b16479_b842542d67474c0c89e82ff1255f9d8c~mv2.png",
    ],
    
    // === UNIQUE / SPECIAL ===
    "Vanguard Blade": [
        "https://static.wixstatic.com/media/b16479_d3d946b739b6400286978a0d39388900~mv2.png" 
    ]
};
function generateTreasureDeck() {
    const deck = [];
    const itemNames = [
        "Sword", "Shield", "Helm", "Armor", "Wand", "Staff", "Bow", "Dagger", 
        "Boots", "Gloves", "Ring", "Amulet", "Cloak", "Belt",
        "Axe", "Hammer", "Spear" 
    ];
    const slots = [
        'main', 'off', 'head', 'body', 'main', 'main', 'main', 'main', 
        'body', 'body', 'off', 'head', 'body', 'body',
        'main', 'main', 'main'
    ];
    const stats = [
        'str', 'str', 'str', 'str', 'int', 'int', 'dex', 'dex', 
        'dex', 'dex', 'int', 'int', 'dex', 'str',
        'str', 'str', 'dex'
    ];
    const abilities = Object.keys(ABILITY_LIBRARY);
    
    // --- NEW HELPER: Get Random Image ---
    const getImg = (name) => {
        const pool = ITEM_IMAGE_POOLS[name];
        if (!pool || pool.length === 0) return null; // Return null, not empty string
        const randomIndex = Math.floor(Math.random() * pool.length);
        const url = pool[randomIndex];
        return (url && url.length > 5) ? url : null; // Only return if valid URL
    };

    // 1. GOLD & CONSUMABLES
    for(let i=0; i<15; i++) deck.push({ id: `g${i}`, name: "Pouch of Gold", type: 'scroll', rarity: 'common', cost: 0, desc: "Gain 50 Gold", img: getImg("Pouch of Gold"), fn: (p) => { let amt = 50; if (p.activeSkillId === 'midas' || p.passiveSkillId === 'midas' || ['head','body','main','off'].some(s => p.equipment[s] && p.equipment[s].ability && p.equipment[s].ability.name === "Midas Touch")) { amt *= 2; addLog("Midas Touch! Gold doubled.", "log-gold"); } p.gold += amt; if(p.id === myPlayerId) AUDIO.playSound('sfx_gold'); addLog(`+${amt} Gold`, "log-gold"); updateHUD(); } });
    for(let i=0; i<8; i++) deck.push({ id: `lc${i}`, name: "Lucky Coin", type: 'scroll', rarity: 'common', cost: 50, desc: "Gain 20-100G", img: getImg("Lucky Coin"), fn: (p) => { let r = Math.floor(Math.random()*6)+1; let amt = (r > 3) ? 200 : -50; if (amt > 0 && (p.activeSkillId === 'midas' || p.passiveSkillId === 'midas')) amt *= 2; if(amt > 0) { p.gold += amt; if(p.id === myPlayerId) AUDIO.playSound('sfx_gold'); addLog(`Rolled ${r}: Won ${amt}G!`, "log-gold"); } else { pay(p, 50); addLog(`Rolled ${r}: Lost 50G.`, "log-fail"); } updateHUD(); } });

    // 2. EQUIPMENT REBALANCE with DYNAMIC NAMING & RANDOM IMAGES
    
    // OLD (Common)
    for(let i=0; i<20; i++) { 
        const idx = i % itemNames.length; 
        const b = {}; b[stats[idx]] = 1; 
        deck.push({ id: `c${i}`, name: `Old ${itemNames[idx]}`, type: 'equip', slot: slots[idx], bonus: b, rarity: 'common', cost: 100, img: getImg(itemNames[idx]) }); 
    }

    // MAGIC (Rare)
    for(let i=0; i<20; i++) { 
        const idx = i % itemNames.length; 
        const b={}; b[stats[idx]] = 2; 
        deck.push({ id: `m${i}`, name: `Magic ${itemNames[idx]}`, type: 'equip', slot: slots[idx], bonus: b, rarity: 'rare', cost: 300, img: getImg(itemNames[idx]) }); 
    }

    // ANCIENT (Epic)
    for(let i=0; i<20; i++) { 
        const idx = i % itemNames.length; 
        const b={}; b[stats[idx]] = 3; 
        const abilKey = abilities[i % abilities.length];
        const abil = ABILITY_LIBRARY[abilKey]; 
        const prefix = ABILITY_PREFIXES[abilKey] || "Ancient"; 
        
        deck.push({ 
            id: `r${i}`, 
            name: `${prefix} ${itemNames[idx]}`, 
            type: 'equip', slot: slots[idx], bonus: b, 
            rarity: 'epic', cost: 800, 
            img: getImg(itemNames[idx]),
            ability: { name: abil.name, type: abil.type || 'active', desc: abil.desc, fn: abil.fn } 
        }); 
    }

    // LEGENDARY
    for(let i=0; i<10; i++) { 
        const idx = i % itemNames.length; 
        const b={}; b[stats[idx]] = 4; 
        const abilKey = abilities[(i+10) % abilities.length];
        const abil = ABILITY_LIBRARY[abilKey]; 
        const prefix = ABILITY_PREFIXES[abilKey] || "Legendary";

        deck.push({ 
            id: `l${i}`, 
            name: `${prefix} ${itemNames[idx]}`, 
            type: 'equip', slot: slots[idx], bonus: b, 
            rarity: 'legendary', cost: 2000, 
            img: getImg(itemNames[idx]),
            ability: { name: abil.name, type: abil.type || 'active', desc: abil.desc, fn: abil.fn } 
        }); 
    }
    
    // SCROLLS & CONSUMABLES
    const misc = [
        {name: "Town Portal", rarity: 'rare', cost: 100, fn: ABILITY_LIBRARY.teleport.fn},
        {name: "Sprint Scroll", rarity: 'common', cost: 50, fn: ABILITY_LIBRARY.dash.fn},
        {name: "Transmute Scroll", rarity: 'epic', cost: 300, fn: ABILITY_LIBRARY.transmute.fn},
        {name: "Elixir of Strength", rarity: 'epic', cost: 500, fn: (p) => { p.stats.str++; addLog("Strength increased!", "log-success"); updateHUD(); }},
        {name: "Elixir of Speed", rarity: 'epic', cost: 500, fn: (p) => { p.stats.dex++; addLog("Dexterity increased!", "log-success"); updateHUD(); }},
        {name: "Elixir of Wisdom", rarity: 'epic', cost: 500, fn: (p) => { p.stats.int++; addLog("Intelligence increased!", "log-success"); updateHUD(); }},
        {name: "Builder's Hammer", rarity: 'rare', cost: 300, fn: (p) => { capture(tiles[p.pos], p, 2); addLog("Tavern Built!", "log-success"); }},
        {name: "Mercenary Contract", rarity: 'rare', cost: 150, fn: (p) => { tiles[p.pos].userData.guardCount++; addLog("Guard hired!", "log-success"); updateHUD(); }},
        {name: "Thief's Glove", rarity: 'rare', cost: 200, fn: (p) => { /* logic */ addLog("Steal!", "log-gold"); }},
        {name: "Royal Pardon", rarity: 'rare', cost: 150, fn: (p) => { p.isSkipping = false; addLog("Pardoned!", "log-success"); }},
        {name: "Map to Riches", rarity: 'epic', cost: 400, fn: (p) => { /* logic */ }},
        {name: "Investment Deed", rarity: 'rare', cost: 200, fn: (p) => { p.gold += 100; addLog("Dividends!", "log-gold"); updateHUD(); }},
        {name: "Warp Stone", rarity: 'common', cost: 50, fn: (p) => { /* logic */ }}
    ];

    misc.forEach((m, i) => {
        deck.push({ 
            id: `misc_${i}`, 
            name: m.name, 
            type: 'scroll', 
            rarity: m.rarity, 
            cost: m.cost, 
            desc: "Consumable", 
            img: getImg(m.name), // Calls the new random helper
            fn: m.fn 
        });
    });

    return deck;
}

const DECK_TREASURE = generateTreasureDeck();
const DECK_ENCOUNTER = [
    // STR/DEX
    {name:"Goblin Ambush", type:'combat', desc:"Goblins jump from the trees!", choices:[{txt:"Power Through (STR 4+)", stat:'str', tn:4, fail:40, mode:'capture'},{txt:"Dodge & Counter (DEX 3+)", stat:'dex', tn:3, fail:30, mode:'capture'}]},
    {name:"Bar Fight", type:'combat', desc:"A drunk patron swings a stool at you.", choices:[{txt:"Punch Back (STR 3+)", stat:'str', tn:3, fail:30, mode:'capture'},{txt:"Weave Away (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture'}]},
    {name:"Wolf Pack", type:'combat', desc:"Hungry wolves circle you.", choices:[{txt:"Intimidate (STR 4+)", stat:'str', tn:4, fail:50, mode:'capture', val:20}, {txt:"Quick Strikes (DEX 4+)", stat:'dex', tn:4, fail:50, mode:'capture', val:50}]},
    {name:"Rogue Duelist", type:'combat', desc:"He challenges you to a duel.", choices:[{txt:"Overpower (STR 5+)", stat:'str', tn:5, fail:60, mode:'capture', val:80}, {txt:"Parry (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture', val:40}]},
    {name:"Falling Rocks", type:'check', desc:"A landslide! React fast!", choices:[{txt:"Hold it up (STR 5+)", stat:'str', tn:5, fail:50, mode:'capture', val:100},{txt:"Dive (DEX 3+)", stat:'dex', tn:3, fail:30, mode:'capture', val:40}]},
    {name:"Mud Pit", type:'check', desc:"You are stuck in thick mud.", choices:[{txt:"Pull Out (STR 3+)", stat:'str', tn:3, fail:20, mode:'capture', val:30},{txt:"Balance Out (DEX 5+)", stat:'dex', tn:5, fail:40, mode:'capture', val:80}]},
    {name:"Giant Spider", type:'combat', desc:"It descends on a silk thread.", choices:[{txt:"Smash It (STR 4+)", stat:'str', tn:4, fail:50, mode:'capture'},{txt:"Roll Away (DEX 3+)", stat:'dex', tn:3, fail:30, mode:'capture'}]},
    {name:"Bear Trap", type:'check', desc:"SNAP! Your leg is caught.", choices:[{txt:"Pry Open (STR 4+)", stat:'str', tn:4, fail:50, mode:'capture', val:50},{txt:"Pick Lock (DEX 4+)", stat:'dex', tn:4, fail:50, mode:'capture', val:50}]},
    {name:"Wild Boar", type:'combat', desc:"It charges from the brush.", choices:[{txt:"Wrestle (STR 4+)", stat:'str', tn:4, fail:40, mode:'capture'},{txt:"Matador Dodge (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture', val:40}]},
    {name:"Falling Chandelier", type:'check', desc:"The chain snaps above you!", choices:[{txt:"Catch It (STR 5+)", stat:'str', tn:5, fail:60, mode:'capture', val:80},{txt:"Jump Away (DEX 3+)", stat:'dex', tn:3, fail:20, mode:'capture', val:20}]},
    {name:"Runaway Cart", type:'check', desc:"It's rolling down the hill towards town.", choices:[{txt:"Stop it (STR 5+)", stat:'str', tn:5, fail:50, mode:'capture', val:100},{txt:"Jump on & Steer (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture', val:70}]},
    {name:"Training Dummy", type:'combat', desc:"A magically animated sparring partner.", choices:[{txt:"Heavy Hit (STR 3+)", stat:'str', tn:3, fail:20, mode:'capture'},{txt:"Precision (DEX 3+)", stat:'dex', tn:3, fail:20, mode:'capture'}]},
    {name:"Bee Swarm", type:'combat', desc:"Not the bees! They are everywhere!", choices:[{txt:"Swat Wildly (STR 3+)", stat:'str', tn:3, fail:30, mode:'capture'},{txt:"Outrun (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture', val:30}]},
    {name:"Arm Wrestling", type:'check', desc:"A dwarf challenges you.", choices:[{txt:"Brute Force (STR 5+)", stat:'str', tn:5, fail:50, mode:'capture', val:100},{txt:"Technique (DEX 4+)", stat:'dex', tn:4, fail:50, mode:'capture', val:80}]},
    {name:"Bandit Toll", type:'check', desc:"They block the bridge.", choices:[{txt:"Shove Aside (STR 4+)", stat:'str', tn:4, fail:40, mode:'capture'},{txt:"Slip Past (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture'}]},
    {name:"Greased Pig", type:'check', desc:"Catch the prize pig at the fair.", choices:[{txt:"Tackle (STR 4+)", stat:'str', tn:4, fail:30, mode:'capture', val:60},{txt:"Snatch (DEX 5+)", stat:'dex', tn:5, fail:30, mode:'capture', val:90}]},
    {name:"Crumbling Floor", type:'check', desc:"The wood gives way beneath you.", choices:[{txt:"Hang on (STR 3+)", stat:'str', tn:3, fail:30, mode:'capture', val:20},{txt:"Leap (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture', val:50}]},

    // DEX/INT
    {name:"Arcane Trap", type:'check', desc:"Runes glow on the floor.", choices:[{txt:"Disarm (DEX 5+)", stat:'dex', tn:5, fail:60, mode:'capture', val:100},{txt:"Dispel (INT 3+)", stat:'int', tn:3, fail:30, mode:'capture', val:50}]},
    {name:"Pickpocket", type:'check', desc:"A thief bumps into you.", choices:[{txt:"Grab Him (DEX 3+)", stat:'dex', tn:3, fail:30, mode:'capture', val:40},{txt:"Predict Path (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture', val:70}]},
    {name:"Locked Gate", type:'check', desc:"An ancient mechanism blocks the way.", choices:[{txt:"Climb Over (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture', val:50},{txt:"Solve Puzzle (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture', val:50}]},
    {name:"Illusionist", type:'combat', desc:"Copies of the wizard surround you.", choices:[{txt:"Strike True (DEX 5+)", stat:'dex', tn:5, fail:50, mode:'capture', val:80},{txt:"See Truth (INT 3+)", stat:'int', tn:3, fail:30, mode:'capture', val:30}]},
    {name:"Arrow Storm", type:'combat', desc:"Arrows fly from the bushes.", choices:[{txt:"Dodge (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture'},{txt:"Shield Spell (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture'}]},
    {name:"Card Game", type:'check', desc:"A high stakes game at a tavern.", choices:[{txt:"Sleight of Hand (DEX 5+)", stat:'dex', tn:5, fail:100, mode:'capture', val:200},{txt:"Count Cards (INT 4+)", stat:'int', tn:4, fail:50, mode:'capture', val:100}]},
    {name:"Poison Gas", type:'check', desc:"Green mist fills the room.", choices:[{txt:"Hold Breath & Run (DEX 3+)", stat:'dex', tn:3, fail:30, mode:'capture', val:40},{txt:"Identify Antidote (INT 5+)", stat:'int', tn:5, fail:60, mode:'capture', val:120}]},
    {name:"Sphinx", type:'combat', desc:"It demands an answer or your life.", choices:[{txt:"Run Past (DEX 5+)", stat:'dex', tn:5, fail:80, mode:'capture'},{txt:"Answer Riddle (INT 4+)", stat:'int', tn:4, fail:50, mode:'capture', val:50}]},
    {name:"Shell Game", type:'check', desc:"A street scammer challenges you.", choices:[{txt:"Fast Eyes (DEX 4+)", stat:'dex', tn:4, fail:50, mode:'capture', val:80},{txt:"Calculate (INT 4+)", stat:'int', tn:4, fail:50, mode:'capture', val:80}]},
    {name:"Mimic", type:'combat', desc:"The chest has teeth!", choices:[{txt:"Reflex Stab (DEX 4+)", stat:'dex', tn:4, fail:40, mode:'capture', val:50},{txt:"Identify (INT 3+)", stat:'int', tn:3, fail:30, mode:'capture'}]},
    {name:"Singing Contest", type:'check', desc:"Perform for the crowd.", choices:[{txt:"Dance (DEX 4+)", stat:'dex', tn:4, fail:30, mode:'capture', val:60},{txt:"Compose Lyrics (INT 4+)", stat:'int', tn:4, fail:30, mode:'capture', val:60}]},
    {name:"Flying Book", type:'check', desc:"A spellbook flutters away.", choices:[{txt:"Catch It (DEX 4+)", stat:'dex', tn:4, fail:20, mode:'capture', val:50},{txt:"Summon It (INT 3+)", stat:'int', tn:3, fail:20, mode:'capture', val:50}]},
    {name:"Tripwire", type:'check', desc:"A thin wire spans the path.", choices:[{txt:"Cut Carefully (DEX 4+)", stat:'dex', tn:4, fail:50, mode:'capture', val:30},{txt:"Analyze Mechanism (INT 4+)", stat:'int', tn:4, fail:50, mode:'capture', val:30}]},
    {name:"Fey Prank", type:'combat', desc:"A pixie steals your boots.", choices:[{txt:"Chase (DEX 5+)", stat:'dex', tn:5, fail:30, mode:'capture', val:40},{txt:"Trick It Back (INT 4+)", stat:'int', tn:4, fail:30, mode:'capture', val:60}]},
    {name:"Lost in Woods", type:'check', desc:"The path has vanished.", choices:[{txt:"Climb Tree (DEX 3+)", stat:'dex', tn:3, fail:20, mode:'capture', val:20},{txt:"Navigate Stars (INT 4+)", stat:'int', tn:4, fail:20, mode:'capture', val:40}]},
    {name:"Clockwork Toy", type:'combat', desc:"A mechanical soldier malfunctions.", choices:[{txt:"Disable (DEX 4+)", stat:'dex', tn:4, fail:30, mode:'capture'},{txt:"Reprogram (INT 5+)", stat:'int', tn:5, fail:50, mode:'capture', val:100}]},
    {name:"Alchemy Accident", type:'check', desc:"A potion is about to explode.", choices:[{txt:"Throw it (DEX 4+)", stat:'dex', tn:4, fail:50, mode:'capture', val:40},{txt:"Neutralize (INT 5+)", stat:'int', tn:5, fail:60, mode:'capture', val:100}]},

    // STR/INT
    {name:"Stone Golem", type:'combat', desc:"Slow but incredibly tough.", choices:[{txt:"Shatter (STR 5+)", stat:'str', tn:5, fail:60, mode:'capture', val:80},{txt:"Find Weakness (INT 3+)", stat:'int', tn:3, fail:30, mode:'capture'}]},
    {name:"Cursed Armor", type:'combat', desc:"An animated suit of armor attacks.", choices:[{txt:"Bash (STR 4+)", stat:'str', tn:4, fail:40, mode:'capture'},{txt:"Banish Spirit (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture'}]},
    {name:"Rusted Portcullis", type:'check', desc:"The gate is heavy and stuck.", choices:[{txt:"Lift (STR 4+)", stat:'str', tn:4, fail:40, mode:'capture', val:50},{txt:"Leverage (INT 3+)", stat:'int', tn:3, fail:20, mode:'capture', val:40}]},
    {name:"Orc Shaman", type:'combat', desc:"He channels lightning.", choices:[{txt:"Rush Him (STR 4+)", stat:'str', tn:4, fail:50, mode:'capture', val:30},{txt:"Counterspell (INT 5+)", stat:'int', tn:5, fail:60, mode:'capture', val:80}]},
    {name:"Magic Sword", type:'check', desc:"A sword stuck in a stone.", choices:[{txt:"Pull (STR 6+)", stat:'str', tn:6, fail:50, mode:'capture', val:200},{txt:"Arcane Release (INT 5+)", stat:'int', tn:5, fail:50, mode:'capture', val:150}]},
    {name:"Drunken Giant", type:'combat', desc:"He creates a mess in the tavern.", choices:[{txt:"Wrestle (STR 5+)", stat:'str', tn:5, fail:60, mode:'capture', val:70},{txt:"Outsmart (INT 3+)", stat:'int', tn:3, fail:30, mode:'capture', val:30}]},
    {name:"Haunted House", type:'combat', desc:"Furniture is flying everywhere.", choices:[{txt:"Smash Furniture (STR 3+)", stat:'str', tn:3, fail:30, mode:'capture'},{txt:"Exorcise (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture', val:50}]},
    {name:"Collapsed Mine", type:'check', desc:"Rubble blocks the gold vein.", choices:[{txt:"Dig (STR 4+)", stat:'str', tn:4, fail:40, mode:'capture', val:60},{txt:"Engineer Support (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture', val:60}]},
    {name:"Crystal Guardian", type:'combat', desc:"Made of resonating crystal.", choices:[{txt:"Smash (STR 5+)", stat:'str', tn:5, fail:60, mode:'capture', val:70},{txt:"Sonic Resonance (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture', val:70}]},
    {name:"Frozen Door", type:'check', desc:"Ice seals the vault.", choices:[{txt:"Kick Open (STR 5+)", stat:'str', tn:5, fail:40, mode:'capture', val:60},{txt:"Melt Spell (INT 3+)", stat:'int', tn:3, fail:20, mode:'capture', val:30}]},
    {name:"Possessed Bear", type:'combat', desc:"Glowing purple eyes stare at you.", choices:[{txt:"Subdue (STR 5+)", stat:'str', tn:5, fail:60, mode:'capture'},{txt:"Cleansing Ritual (INT 4+)", stat:'int', tn:4, fail:50, mode:'capture', val:60}]},
    {name:"Sinking Boat", type:'check', desc:"Taking on water fast!", choices:[{txt:"Bail Water (STR 4+)", stat:'str', tn:4, fail:30, mode:'capture', val:30},{txt:"Repair Hull (INT 4+)", stat:'int', tn:4, fail:30, mode:'capture', val:50}]},
    {name:"Statue Puzzle", type:'check', desc:"Heavy statues must be arranged.", choices:[{txt:"Push Them (STR 5+)", stat:'str', tn:5, fail:50, mode:'capture', val:60},{txt:"Solve Order (INT 4+)", stat:'int', tn:4, fail:50, mode:'capture', val:60}]},
    {name:"Magical Barrier", type:'check', desc:"A forcefield blocks the loot.", choices:[{txt:"Hit Hard (STR 6+)", stat:'str', tn:6, fail:80, mode:'capture', val:150},{txt:"Counter-Frequency (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture', val:80}]},
    {name:"Entangled Roots", type:'combat', desc:"Vines grab your legs.", choices:[{txt:"Rip Free (STR 4+)", stat:'str', tn:4, fail:30, mode:'capture'},{txt:"Wither Spell (INT 3+)", stat:'int', tn:3, fail:30, mode:'capture'}]},
    {name:"Library Fire", type:'check', desc:"Save the ancient scrolls!", choices:[{txt:"Carry Water (STR 4+)", stat:'str', tn:4, fail:40, mode:'capture', val:70},{txt:"Frost Spell (INT 4+)", stat:'int', tn:4, fail:40, mode:'capture', val:70}]},
    {name:"Gargoyle", type:'combat', desc:"Stone turns to flesh.", choices:[{txt:"Break Wings (STR 5+)", stat:'str', tn:5, fail:50, mode:'capture'},{txt:"Command Word (INT 5+)", stat:'int', tn:5, fail:50, mode:'capture', val:100}]},

];

const DECK_SKIRMISH = [
    // STR/DEX (Bosses)
    {name:"Assassin Lord", type:'combat', desc:"Fast and deadly.", choices:[{txt:"Crush Him (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:50},{txt:"Match Speed (DEX 6+)", stat:'dex', tn:6, req:2, fail:120, mode:'capture', val:150}]},
    {name:"Hydra", type:'combat', desc:"Heads regrow as you cut them.", choices:[{txt:"Sever Heads (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:200},{txt:"Dance Around (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:50}]},
    {name:"Blade Gauntlet", type:'check', desc:"A hallway of swinging scythes.", choices:[{txt:"Block & Move (STR 5+)", stat:'str', tn:5, req:2, fail:80, mode:'capture', val:150},{txt:"Acrobatics (DEX 5+)", stat:'dex', tn:5, req:2, fail:80, mode:'capture', val:150}]},
    {name:"Dragon Turtle", type:'combat', desc:"An armored beast of the deep.", choices:[{txt:"Crack Shell (STR 6+)", stat:'str', tn:6, req:2, fail:120, mode:'capture', val:100},{txt:"Aim for Eyes (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:50}]},
    {name:"Chimera", type:'combat', desc:"Lion, Goat, and Snake heads attack.", choices:[{txt:"Hold Heads (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:100},{txt:"Dodge Breath (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:100}]},
    {name:"Collapsing Temple", type:'check', desc:"The roof is coming down!", choices:[{txt:"Hold Pillar (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:250},{txt:"Parkour Out (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Dragon Rider", type:'combat', desc:"An elite knight on a drake.", choices:[{txt:"Knock Off (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:80},{txt:"Aerial Battle (DEX 6+)", stat:'dex', tn:6, req:2, fail:150, mode:'capture', val:200}]},
    {name:"Sandworm", type:'combat', desc:"It bursts from the ground.", choices:[{txt:"Wrestle Maw (STR 6+)", stat:'str', tn:6, req:2, fail:120, mode:'capture', val:150},{txt:"Ride It (DEX 6+)", stat:'dex', tn:6, req:2, fail:120, mode:'capture', val:300}]},
    {name:"Blade Master", type:'combat', desc:"He wields six swords.", choices:[{txt:"Parry All (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:80},{txt:"Riposte (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:100}]},
    {name:"Tsunami", type:'check', desc:"A massive wave approaches.", choices:[{txt:"Anchor Self (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:200},{txt:"Climb High (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Juggernaut", type:'combat', desc:"An unstoppable armored charger.", choices:[{txt:"Stop Momentum (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:200},{txt:"Trip Him (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:100}]},
    {name:"Invisible Stalker", type:'combat', desc:"You can hear it breathing.", choices:[{txt:"Flail Wildly (STR 5+)", stat:'str', tn:5, req:2, fail:80, mode:'capture'},{txt:"React to Sound (DEX 5+)", stat:'dex', tn:5, req:2, fail:80, mode:'capture', val:120}]},
    {name:"Gladiator Pit", type:'combat', desc:"You are thrown into the arena.", choices:[{txt:"Survive (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:150},{txt:"Flourish (DEX 6+)", stat:'dex', tn:6, req:2, fail:100, mode:'capture', val:250}]},

    // DEX/INT (Bosses)
    {name:"Lich King", type:'combat', desc:"Master of death magic.", choices:[{txt:"Dodge Spells (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:50},{txt:"Duel Magic (INT 6+)", stat:'int', tn:6, req:2, fail:150, mode:'capture', val:200}]},
    {name:"Mirror Maze", type:'check', desc:"Reflections confuse you.", choices:[{txt:"Wall Jump (DEX 6+)", stat:'dex', tn:6, req:1, fail:100, mode:'capture', val:200},{txt:"Deduce Path (INT 5+)", stat:'int', tn:5, req:2, fail:80, mode:'capture', val:120}]},
    {name:"Void Stalker", type:'combat', desc:"It phases out of reality.", choices:[{txt:"Reaction Shot (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:80},{txt:"Predict Phase (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:80}]},
    {name:"Ancient Vault", type:'check', desc:"The lock of the gods.", choices:[{txt:"Legendary Pick (DEX 6+)", stat:'dex', tn:6, req:2, fail:150, mode:'capture', val:300},{txt:"Dispel Ward (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Time Loop", type:'check', desc:"You are reliving this moment.", choices:[{txt:"Break Cycle (DEX 6+)", stat:'dex', tn:6, req:2, fail:100, mode:'capture', val:200},{txt:"Unravel Spell (INT 6+)", stat:'int', tn:6, req:2, fail:100, mode:'capture', val:300}]},
    {name:"Lich's Phylactery", type:'check', desc:"The source of his power.", choices:[{txt:"Steal It (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:150},{txt:"Disenchant (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Psychic Storm", type:'check', desc:"Bolts of mental energy rain down.", choices:[{txt:"Dodge Bolts (DEX 5+)", stat:'dex', tn:5, req:2, fail:80, mode:'capture', val:100},{txt:"Mental Shield (INT 5+)", stat:'int', tn:5, req:2, fail:80, mode:'capture', val:100}]},
    {name:"Laser Grid", type:'check', desc:"Deadly beams block the treasure.", choices:[{txt:"Gymnastics (DEX 6+)", stat:'dex', tn:6, req:2, fail:150, mode:'capture', val:250},{txt:"Hack Terminal (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Doppelganger", type:'combat', desc:"It knows your every move.", choices:[{txt:"Reflex Duel (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:100},{txt:"Logic Paradox (INT 6+)", stat:'int', tn:6, req:2, fail:150, mode:'capture', val:200}]},
    {name:"Clockwork Dragon", type:'combat', desc:"A masterpiece of destruction.", choices:[{txt:"Jam Gears (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:120},{txt:"Override Code (INT 6+)", stat:'int', tn:6, req:2, fail:120, mode:'capture', val:220}]},
    {name:"Poisoned Banquet", type:'check', desc:"The King is dying!", choices:[{txt:"Sleight of Hand (DEX 6+)", stat:'dex', tn:6, req:2, fail:200, mode:'capture', val:300},{txt:"Mix Antidote (INT 5+)", stat:'int', tn:5, req:2, fail:150, mode:'capture', val:200}]},
    {name:"Floating Island", type:'check', desc:"The bridge has crumbled away.", choices:[{txt:"Parkour Gaps (DEX 5+)", stat:'dex', tn:5, req:2, fail:100, mode:'capture', val:150},{txt:"Flight Spell (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Shadow Master", type:'combat', desc:"He attacks from the dark.", choices:[{txt:"Counter-Strike (DEX 6+)", stat:'dex', tn:6, req:2, fail:120, mode:'capture', val:150},{txt:"Light Spell (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:120}]},

    // STR/INT (Bosses)
    {name:"Demon Gate", type:'check', desc:"Demons pour from the portal.", choices:[{txt:"Bar the Gate (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:250},{txt:"Close Portal (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Iron Golem", type:'combat', desc:"Impervious to normal weapons.", choices:[{txt:"Topple (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:50},{txt:"Rust Spell (INT 6+)", stat:'int', tn:6, req:2, fail:150, mode:'capture', val:200}]},
    {name:"Vampire Lord", type:'combat', desc:"Ancient and powerful.", choices:[{txt:"Drive Stake (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:100},{txt:"Holy Light (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:100}]},
    {name:"Obelisk", type:'check', desc:"A fallen monument blocks the road.", choices:[{txt:"Heave (STR 6+)", stat:'str', tn:6, req:1, fail:100, mode:'capture', val:150},{txt:"Levitate (INT 5+)", stat:'int', tn:5, req:2, fail:80, mode:'capture', val:120}]},
    {name:"Volcano Eruption", type:'check', desc:"Lava flows towards the village.", choices:[{txt:"Divert Flow (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:200},{txt:"Freeze Magma (INT 6+)", stat:'int', tn:6, req:2, fail:150, mode:'capture', val:250}]},
    {name:"Titan", type:'combat', desc:"A giant as tall as a mountain.", choices:[{txt:"Leg Sweep (STR 6+)", stat:'str', tn:6, req:2, fail:200, mode:'capture', val:300},{txt:"Banishment (INT 6+)", stat:'int', tn:6, req:2, fail:200, mode:'capture', val:300}]},
    {name:"Necropolis Gate", type:'check', desc:"Sealed by blood magic.", choices:[{txt:"Break It (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:200},{txt:"Holy Word (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Living Wall", type:'combat', desc:"The bricks try to crush you.", choices:[{txt:"Smash Bricks (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:100},{txt:"Command Word (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:100}]},
    {name:"Storm Giant", type:'combat', desc:"He throws lightning bolts.", choices:[{txt:"Arm Wrestle (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:200},{txt:"Lightning Rod (INT 5+)", stat:'int', tn:5, req:2, fail:120, mode:'capture', val:150}]},
    {name:"Void Rift", type:'check', desc:"Reality is tearing apart.", choices:[{txt:"Force Closed (STR 6+)", stat:'str', tn:6, req:2, fail:200, mode:'capture', val:300},{txt:"Seal Magic (INT 6+)", stat:'int', tn:6, req:2, fail:150, mode:'capture', val:300}]},
    {name:"Cursed Tree", type:'combat', desc:"It drains life from the land.", choices:[{txt:"Uproot (STR 6+)", stat:'str', tn:6, req:2, fail:120, mode:'capture', val:150},{txt:"Purify Root (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Meat Grinder", type:'check', desc:"A room of spinning blades.", choices:[{txt:"Jam Gears (STR 5+)", stat:'str', tn:5, req:2, fail:100, mode:'capture', val:150},{txt:"Shutdown (INT 5+)", stat:'int', tn:5, req:2, fail:100, mode:'capture', val:150}]},
    {name:"Abyssal Horror", type:'combat', desc:"Madness given form.", choices:[{txt:"Crush It (STR 6+)", stat:'str', tn:6, req:2, fail:150, mode:'capture', val:200},{txt:"Mind Blast (INT 6+)", stat:'int', tn:6, req:2, fail:150, mode:'capture', val:250}]},
    {name:"King of the Hill", type:'combat', desc:"An Orc Warlord challenges you.", choices:[{txt:"Throw Off (STR 5+)", stat:'str', tn:5, req:2, fail:80, mode:'capture', val:100},{txt:"Tactics (INT 5+)", stat:'int', tn:5, req:2, fail:80, mode:'capture', val:120}]},
];

const LOCATIONS = [
    {name:"Old Crooks Inn",type:"start",cost:0,color:"#4ade80",img:"https://static.wixstatic.com/media/b16479_b4d35a4270574b5380497c6eb27146bd~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_a353cedcf17c4b618027f64190b6be73~mv2.jpg",flavor:"A warm hearth greets you, smelling of roasted meat and ale. Rough laughter fills the air as adventurers swap stories of their latest conquests."},
    {name:"Rat Cellar",type:"combat",cost:60,tn:3,req:1,color:"#9ca3af",img:"https://static.wixstatic.com/media/b16479_7981e4bf2a9f42fca2ba9335a79b6315~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_1f9645c758e8451c90e7d733f2bc5057~mv2.jpg",flavor:"Squeaking echoes from the damp shadows of this musty basement. Red eyes watch you from the cracks."},
    {name:"Chest",type:"chest",cost:0,color:"#fcd34d",img:"https://static.wixstatic.com/media/b16479_2a0e4f70b29e4611927b65c33fce86f4~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_87f60295a50d4881bc95f728314e37fb~mv2.jpg",flavor:"The dirt here has been recently disturbed. You spot the corner of a wooden box protruding from the mud."},
    {name:"Wolf Den",type:"combat",cost:60,tn:3,req:1,color:"#9ca3af",img:"https://static.wixstatic.com/media/b16479_4318c9bb74dd48ddbe8702ec17a059dd~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_2e2baedb53b944da923cc49f6dcce0ff~mv2.jpg",flavor:"Gnawed bones litter the entrance to this dark cave. A low growl reverberates from the shadows."},
    {name:"Tax",type:"tax",cost:0,color:"#f87171",img:"https://static.wixstatic.com/media/b16479_b2ff79acb9db40c1b8e230e2b43f2a53~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_3671f830191345c1b8a315017da72a5b~mv2.jpg",flavor:"The King's tax collectors block the road with their armored carriage. Pay up or face the dungeon."},
    {name:"Stable",type:"shop",cost:200,color:"#78350f",img:"https://static.wixstatic.com/media/b16479_63e31ea7ac144c2c8086342125a30877~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_f660a75ab6284f56b2c90f4f221f53a3~mv2.jpg",flavor:"The smell of hay and horses is strong here. A merchant offers fresh mounts to speed your journey."},
    {name:"Goblin Camp",type:"combat",cost:100,tn:4,req:1,color:"#84cc16",img:"https://static.wixstatic.com/media/b16479_1d0dc90e90e04783a2cd04823ccf9255~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_c48e6fdf163d4dd68b411d5674de6b4b~mv2.jpg",flavor:"Crude tents made of animal skins dot the clearing. You hear the chaotic chatter of goblins."},
    {name:"Fairy Ring",type:"mystery",cost:0,color:"#a855f7",img:"https://static.wixstatic.com/media/b16479_1437cc54895e4595a43f461ed959c5ce~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_65c314c4ef784a58b9b162d4d30b1698~mv2.jpg",flavor:"A circle of mushrooms glows with a soft, unnatural light. The air hums with chaotic magic."},
    {name:"Bandit Road",type:"combat",cost:100,tn:4,req:1,color:"#84cc16",img:"https://static.wixstatic.com/media/b16479_5101a6720f074efcb628b70b85bcdac6~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_6364e428d9504a139a2c56e1e168eb3d~mv2.jpg",flavor:"This stretch of road is suspiciously quiet. Broken wagon wheels suggest travelers often meet a grim fate here."},
    {name:"Ogre Cave",type:"combat",cost:120,tn:4,req:1,color:"#84cc16",img:"https://static.wixstatic.com/media/b16479_778f6cf396474b47835aa4e8c103bffd~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_d5dcf031b6c24893b00b8fa6d0145eca~mv2.jpg",flavor:"A massive boulder blocks the wind, but not the smell of rotting meat. Something very large calls this home."},
    {name:"Dungeon",type:"jail",cost:0,color:"#fb923c",img:"https://static.wixstatic.com/media/b16479_a259ef3e7d8c4c09a88aea824537e57b~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_117e17f3d5b84577beb01fcca1cddad9~mv2.jpg",flavor:"Cold iron bars and damp stone walls surround you. It is a place of despair and lost time."},
    {name:"Crypt",type:"combat",cost:140,tn:4,req:2,color:"#475569",img:"https://static.wixstatic.com/media/b16479_c230f43aefe64d898b4d2dfe91ad0ba0~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_eb64132a865f440c97f6652e340cbb05~mv2.jpg",flavor:"The air is stale and smells of dust and decay. Ancient sarcophagi line the walls. The dead do not sleep easily here."},
    {name:"Mana Well",type:"util",cost:150,color:"#3b82f6",img:"https://static.wixstatic.com/media/b16479_e2c1dbc5f8f64a988893a00b0cd6f066~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_90031776e646488c93f69cc6461d9333~mv2.jpg",flavor:"Pure arcane energy bubbles up from the earth in a glowing blue spring. Wizards travel miles just to glimpse it."},
    {name:"Witch Hut",type:"combat",cost:140,tn:4,req:2,color:"#475569",img:"https://static.wixstatic.com/media/b16479_6d223ad95ed04eea8a963cf5b3596e35~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_b095b71e60ff4619833aa4b45bc7795d~mv2.jpg",flavor:"A crooked shack stands on chicken legs in the swamp. Green smoke billows from the chimney."},
    {name:"Graveyard",type:"combat",cost:160,tn:4,req:2,color:"#475569",img:"https://static.wixstatic.com/media/b16479_d7da23aa207b4549b9cd245959d69e6e~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_8ae524f80b344def99ec6833ea717083~mv2.jpg",flavor:"Fog clings to the tilted headstones of this forgotten cemetery. The ground feels soft, as if something is trying to claw its way out."},
    {name:"Port",type:"shop",cost:200,color:"#78350f",img:"https://static.wixstatic.com/media/b16479_bc4d708aeb394233b697b148d0d33dc7~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_7403c140a66345be8cb9a8eb5b0ebc99~mv2.jpg",flavor:"The cry of seagulls and the crash of waves welcome you. Ships from distant lands unload exotic cargo on the docks."},
    {name:"Orc Fort",type:"combat",cost:180,tn:5,req:1,color:"#b91c1c",img:"https://static.wixstatic.com/media/b16479_c529b3b0e6c7410989ac654ae3f8cac7~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_dc2c9a5dfd124ef6b8320451e5359218~mv2.jpg",flavor:"Jagged wooden spikes surround a fortified encampment. War drums beat a steady rhythm that shakes the ground."},
    {name:"Chest",type:"chest",cost:0,color:"#fcd34d",img:"https://static.wixstatic.com/media/b16479_9bfca911c8764f158b066493eae2bc81~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_87f60295a50d4881bc95f728314e37fb~mv2.jpg",flavor:"An ornate iron-bound chest sits half-buried in the dirt. The lock looks rusty but the wood is sound."},
    {name:"Troll Bridge",type:"combat",cost:180,tn:5,req:1,color:"#b91c1c",img:"https://static.wixstatic.com/media/b16479_249a86b0e4f4415ba0a9be35119eb43a~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_0e9e3392a6a44f8291b357aacf04aef8~mv2.jpg",flavor:"A massive stone bridge spans the rushing river below. A hulking figure demands a toll from anyone wishing to cross."},
    {name:"Wyvern Peak",type:"combat",cost:200,tn:5,req:1,color:"#b91c1c",img:"https://static.wixstatic.com/media/b16479_f91826c1558c493ba71c3a2c0a05ff71~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_d3f9c5b8ba2c4ef2998dd9bd6d2ac062~mv2.jpg",flavor:"The air is thin and cold up on this jagged mountain spire. Screeches echo from the clouds as winged shadows circle above."},
    {name:"Capital City",type:"park",cost:0,color:"#e2e8f0",img:"https://static.wixstatic.com/media/b16479_e5d51e21d1d84a009b8845a522bb5d23~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_909eefa9a23646b2825e2f3819031b90~mv2.jpg",flavor:"The white walls of the capital gleam in the sunlight. Guards in polished armor patrol the streets. Here, the King's law is absolute."},
    {name:"Lava Pits",type:"combat",cost:220,tn:5,req:2,color:"#7f1d1d",img:"https://static.wixstatic.com/media/b16479_799f54f3baaf47d3a6917ae7c8efb12a~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_7672054ca2e14a6c95d9151543aaba1d~mv2.jpg",flavor:"The heat is unbearable as magma bubbles to the surface. Sulfurous fumes burn your lungs and obscure your vision."},
    {name:"Dark Altar",type:"combat",cost:200,tn:5,req:2,color:"#7f1d1d",img:"https://static.wixstatic.com/media/b16479_3616e7911ae547e8aaf64dd76e7610b8~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_333c76fdd88842199ab18801646ddbbe~mv2.jpg",flavor:"Bloodstains mar the surface of this obsidian slab. Whispers in an unknown tongue fill your mind with dread."},
    {name:"Demon Gate",type:"combat",cost:220,tn:5,req:2,color:"#7f1d1d",img:"https://static.wixstatic.com/media/b16479_0738c43cfb574de79bdf4dd84c0a663b~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_cf022d5d1c264836aade5ffa21a5e77c~mv2.jpg",flavor:"A tear in reality reveals a landscape of fire and torment. Horrors try to claw their way through the barrier."},
    {name:"Dragon Tooth",type:"combat",cost:240,tn:5,req:2,color:"#7f1d1d",img:"https://static.wixstatic.com/media/b16479_aadde8877c854d8fa78d286c00699f7c~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_e373bec825124ac98094938d17fcf71b~mv2.jpg",flavor:"This jagged rock formation looks like the maw of a beast. Legends say an ancient dragon died here, cursing the land."},
    {name:"Airship",type:"shop",cost:200,color:"#78350f",img:"https://static.wixstatic.com/media/b16479_be49c909366540c8a0b017661cc63e51~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_b79ed0dec9104e64a3180a7683ea3fce~mv2.jpg",flavor:"A massive vessel floats tethered to a high tower. The crew shouts orders as they prepare for departure. The sky is the limit."},
    {name:"Lich Tower",type:"combat",cost:260,tn:6,req:1,color:"#581c87",img:"https://static.wixstatic.com/media/b16479_7bf555b6dc624c4f9523e3faab71a7c8~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_2e1c7a754fa84bfd8523c85fd1d415f8~mv2.jpg",flavor:"A spire of black stone pierces the sky, radiating necromantic energy. The master of this tower conquered death long ago."},
    {name:"Vampire Manor",type:"combat",cost:260,tn:6,req:1,color:"#581c87",img:"https://static.wixstatic.com/media/b16479_20a15d19b6424e22bc444a5e1ee7a994~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_c3cc7bb80938445bb99b8f38f2c91ca1~mv2.jpg",flavor:"An elegant gothic mansion sits atop a lonely hill. The windows are dark, but you feel eyes watching you."},
    {name:"Shrine",type:"util",cost:150,color:"#3b82f6",img:"https://static.wixstatic.com/media/b16479_b4682e4fcd6f4dc0b127326528fe97a8~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_c90b252d420f4e84ac0340d4555fbdc8~mv2.jpg",flavor:"A humble statue stands covered in vines and offerings. A sense of peace washes over you, healing your spirit."},
    {name:"Giant's Keep",type:"combat",cost:280,tn:6,req:2,color:"#581c87",img:"https://static.wixstatic.com/media/b16479_eb69b5762c8043cc827fd2c0bad0e45a~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_1e0fcc1de9b844359e778231ea7cc1a3~mv2.jpg",flavor:"Massive stone blocks form a fortress that reaches the clouds. You feel like an ant in this place."},
    {name:"Go To Dungeon",type:"goto",cost:0,color:"#fb923c",img:"https://static.wixstatic.com/media/b16479_33036f2decd74835b1a323a8bfd08ef3~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_a212ee172c0c4df5a2cb3ccc22653f50~mv2.jpg",flavor:"The city guards have caught you red-handed! You are shackled and dragged away without trial."},
    {name:"Cloud Castle",type:"combat",cost:300,tn:6,req:2,color:"#0f172a",img:"https://static.wixstatic.com/media/b16479_1d74349092e741eda4d34f735125ce72~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_ddb8d1cc6af442348847805aaf261ae5~mv2.jpg",flavor:"A fortress floats effortlessly among the clouds. Harps play soft music, and the air tastes sweet."},
    {name:"Titan's Grip",type:"combat",cost:300,tn:6,req:2,color:"#0f172a",img:"https://static.wixstatic.com/media/b16479_0b5cf76a120a45c8b5da8d2d6da2fa62~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_a091ec8e8f164723b44457bc878dedeb~mv2.jpg",flavor:"Two massive stone hands rise from the earth, clutching a valley. The pressure here is immense."},
    {name:"Chest",type:"chest",cost:0,color:"#fcd34d",img:"https://static.wixstatic.com/media/b16479_5624f6d69ac6404e9aede7d4dd5f4d47~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_87f60295a50d4881bc95f728314e37fb~mv2.jpg",flavor:"A grand chest reinforced with steel bands sits in the open. The latch is broken, inviting you to look inside."},
    {name:"Void Edge",type:"combat",cost:320,tn:6,req:2,color:"#0f172a",img:"https://static.wixstatic.com/media/b16479_9eb9e98ea6084dccbe4e57fdcc525324~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_3e59b7d985d84b9688c33ea51322875c~mv2.jpg",flavor:"The world seems to end here, dropping off into nothingness. Stars shine brightly below you in the abyss."},
    {name:"Portal",type:"shop",cost:200,color:"#78350f",img:"https://static.wixstatic.com/media/b16479_062be0c2c7a3459b87645b4f86c8bfd0~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_aa482a0a26e94d6a9754eee718278aa1~mv2.jpg",flavor:"A swirling vortex of purple energy stands before you. It promises travel to distant lands in the blink of an eye."},
    {name:"Smuggler Cove",type:"mystery",cost:0,color:"#a855f7",img:"https://static.wixstatic.com/media/b16479_70c52b2f88864f7ca3f568cf44a3ad70~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_401a126718a64763924ed8ad5314899d~mv2.jpg",flavor:"A hidden cave by the sea. Thieves use secret tunnels here to vanish without a trace."},
    {name:"Royal Palace",type:"combat",cost:350,tn:6,req:3,color:"#fbbf24",img:"https://static.wixstatic.com/media/b16479_6434230067414f34a341a95383fe7896~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_8d01f5e2e59a4244a4101efb92c77487~mv2.jpg",flavor:"The seat of power in the realm, draped in gold and velvet. Nobles scheme in the corridors while the King sits upon his throne."},
    {name:"Luxury Tax",type:"tax",cost:0,color:"#f87171",img:"https://static.wixstatic.com/media/b16479_9b58c85963434fb3abe9ecfb4b114c67~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_2513d4cb760246f69570e8f7eb040a39~mv2.jpg",flavor:"The Crown demands a tribute for your continued prosperity. Jewelry and fine clothes make you a target for the taxman."},
    {name:"Ancient Vault",type:"combat",cost:400,tn:6,req:3,color:"#000000",img:"https://static.wixstatic.com/media/b16479_b8a71205363745b7ad11f72ca6ca30b2~mv2.jpg",cardImg:"https://static.wixstatic.com/media/b16479_0e78493512ad4e559cd6392a9341ddad~mv2.jpg",flavor:"Massive steel doors guard the greatest treasure in the realm. Traps and guardians wait for the foolish."}
];

// ---Audio Manager ---
const AUDIO = {
    // --- MUSIC TRACKS ---
    bgm_start: new Audio('https://static.wixstatic.com/mp3/b16479_c60fba3015874266934a6c546fa40969.mp3'),
    bgm_day: new Audio('https://static.wixstatic.com/mp3/b16479_c597397512544410bd146fd4ac8db680.mp3'),
    bgm_night: new Audio('https://static.wixstatic.com/mp3/b16479_bcf6ce4574284c0e980537782ef4994b.mp3'),
	sfx_equip: new Audio('https://static.wixstatic.com/mp3/b16479_491cb15103f549cb87f770d84ede0c26.mp3'),
	sfx_click: new Audio('https://static.wixstatic.com/mp3/b16479_ba81d5de617146f8bcda766900080f5d.mp3'),
	sfx_fail: new Audio('https://static.wixstatic.com/mp3/b16479_68b7d8f2d0214569b00ad55a90de74a5.mp3'),
    sfx_transition: new Audio('https://static.wixstatic.com/mp3/b16479_37e7a5db0768438985fdc0f17578f394.mp3'),
    sfx_roll: new Audio('https://static.wixstatic.com/mp3/b16479_f1d9c34c2197472aaae5ed91301149a7.mp3'),
    sfx_gold: new Audio('https://static.wixstatic.com/mp3/b16479_e793cc62b89f4111a1b2820828b452be.mp3'),
    sfx_win: new Audio('https://static.wixstatic.com/mp3/b16479_ad96420ff6db49278fcf1fc13e9b816c.mp3'),
    sfx_hit: new Audio('https://static.wixstatic.com/mp3/b16479_7a157bee526d4555a123e97160fceef7.mp3'),
     
    currentTrack: null,
    bgmVolume: 0.4, 
    sfxVolume: 0.3, 
    allowStartMusic: true, 

    init: function() {
        this.bgm_start.loop = true;
        this.bgm_day.loop = true;
        this.bgm_night.loop = true;
        
        // Initial volume setting
        this.bgm_night.volume = 0.2; 
    },
    
    tryPlayStart: function() {
        if (!this.allowStartMusic) return;
        if (this.currentTrack === this.bgm_start) return;

        this.bgm_start.volume = this.bgmVolume;
        const playPromise = this.bgm_start.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                if (!this.allowStartMusic) {
                    this.bgm_start.pause();
                    this.bgm_start.currentTime = 0;
                } else {
                    this.currentTrack = this.bgm_start;
                }
            }).catch(e => {});
        }
    },

    setBGM: function(val) {
        this.bgmVolume = parseFloat(val);
        if(this.currentTrack) {
            // FIX: Updated logic here too
            if(this.currentTrack === this.bgm_night) this.currentTrack.volume = this.bgmVolume * 0.8;
            else this.currentTrack.volume = this.bgmVolume;
        }
    },

    setSFX: function(val) { this.sfxVolume = parseFloat(val); },

    playMusic: function(isNight) {
        const target = isNight ? this.bgm_night : this.bgm_day;
        
        // FIX: Increased from 0.5 to 0.8 (80% of master volume)
        const targetVol = isNight ? (this.bgmVolume * 0.8) : this.bgmVolume;

        if (this.currentTrack === target) {
            target.volume = targetVol;
            return; 
        }

        if (this.currentTrack) {
            const old = this.currentTrack;
            new TWEEN.Tween({v: old.volume})
                .to({v: 0}, 2000)
                .onUpdate(o => old.volume = o.v)
                .onComplete(() => { old.pause(); old.currentTime = 0; })
                .start();
        }

        target.volume = 0;
        target.play().catch(e => console.log("Audio blocked", e));
        this.currentTrack = target;
        
        new TWEEN.Tween({v: 0})
            .to({v: targetVol}, 2000)
            .onUpdate(o => target.volume = o.v)
            .start();
    },
    
    stopStartMusic: function() {
        this.allowStartMusic = false; 
        if (this.currentTrack === this.bgm_start) {
            const old = this.bgm_start;
            new TWEEN.Tween({v: old.volume})
                .to({v: 0}, 1500)
                .onUpdate(o => old.volume = o.v)
                .onComplete(() => { old.pause(); old.currentTime = 0; })
                .start();
        } else {
            this.bgm_start.pause();
            this.bgm_start.currentTime = 0;
        }
    },

    playSound: function(name) {
        if (this.sfxVolume <= 0) return;
        let src = this[name];
        if(src) {
            let sound = src.cloneNode();
            sound.volume = (name === 'sfx_click') ? Math.min(this.sfxVolume, 0.6) : this.sfxVolume;
            sound.play().catch(e => {});
        }
    }
};

function debugLog(msg) {
    // Only log if the overlay is visible
    const overlay = document.getElementById('debug-log-overlay');
    if (overlay.style.display === 'none') return;
    
    const content = document.getElementById('debug-log-content');
    const line = document.createElement('div');
    line.className = 'debug-line';
    
    const time = new Date().toLocaleTimeString().split(' ')[0];
    line.innerHTML = `<span>[${time}]</span> ${msg}`;
    
    // Add to top (since flex-direction is column-reverse)
    content.insertBefore(line, content.firstChild);
    console.log(`[GAME DEBUG] ${msg}`);
}

function updateCamera() {
    const width = window.innerWidth;
    const isMobileMode = document.body.classList.contains('force-mobile') || width <= 768;

    // --- DESKTOP VIEW ---
    if (!isMobileMode) {
        camera.position.set(0, 55, 0.1);
        camera.lookAt(0, 0, 0);
        return;
    }

    // --- MOBILE VIEW (Dynamic Zoom) ---
    const boardSize = 55; 
    const fovRad = (45 * Math.PI) / 360; 
    
    const height = window.innerHeight * 0.82; 
    const aspect = width / height;

    let dist;
    if (aspect > 1) {
        dist = (boardSize / 2) / Math.tan(fovRad);
    } else {
        dist = ((boardSize / aspect) / 2) / Math.tan(fovRad);
    }

    camera.position.set(0, dist, 0.1); 
    camera.lookAt(0, 0, 0);
}

function animate(){ 
    requestAnimationFrame(animate); 
    TWEEN.update(); 
    
    // 1. Update Guards
    if(typeof updateGuards === 'function') updateGuards();

    // 2. Hero Animations
    const time = Date.now() * 0.005;
    players.forEach(p => {
        if (p.mesh && !p.isDead) {
            if (gameState !== 'MOVING') {
                p.mesh.scale.y = 1 + Math.sin(time) * 0.02;
            }
            const cape = p.mesh.getObjectByName("Cape");
            if (cape) {
                cape.rotation.x = 0.2 + Math.sin(time * 2) * 0.1;
                if (gameState === 'MOVING') {
                    cape.rotation.x = 0.8 + Math.sin(time * 10) * 0.2;
                }
            }
        }
    });

    // 3. Fog & Particles
    if(fogGroup) {
        fogGroup.children.forEach((cloud, idx) => {
            cloud.rotation.z += 0.001 * (idx % 2 === 0 ? 1 : -1);
            if(isNight) cloud.position.x += Math.sin(Date.now() * 0.0005 + idx) * 0.005;
        });
    }
    if(particleSystem) {
        const positions = particleSystem.geometry.attributes.position.array;
        const type = particleSystem.userData.type;
        for(let i=1; i<positions.length; i+=3) {
            positions[i] -= 0.1;
            if(type === 'snow') positions[i-1] -= 0.02;
            if(positions[i] < 0) {
                positions[i] = 10 + Math.random() * 5;
                if(type === 'snow') positions[i-1] += (Math.random()*10);
            }
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
    }
    if (activeEvent && activeEvent.mesh) {
        activeEvent.mesh.rotation.y += 0.01;
    }

    // 4. Camera Tracking (SMOOTH FOLLOW FIX)
    if(isZoomed && cameraTarget) {
        // Look at the player's X/Z, but lock Y to 0 (floor) to ignore hopping jitter
        camera.lookAt(cameraTarget.position.x, 0, cameraTarget.position.z);
    }

    renderer.render(scene,camera); 
}

//Camera Functions

function zoomToPiece(p) {
    isZoomed = true;
    cameraTarget = p.mesh; // Target the player mesh again
    
    // Standard Board Game View Offset
    const offset = { x: 0, y: 22, z: 18 }; 
    
    new TWEEN.Tween(camera.position)
        .to({
            x: p.mesh.position.x + offset.x,
            y: offset.y, // Keep Y steady (don't add mesh.y to avoid bobbing start)
            z: p.mesh.position.z + offset.z
        }, 800)
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();
}

// Moves Player and Camera together to a specific tile
function animateTeleport(p, targetTile, onComplete) {
    gameState = 'MOVING';
    
    // Ensure tracking player
    isZoomed = true;
    cameraTarget = p.mesh;

    const startPos = p.mesh.position.clone();
    const endPos = targetTile.position.clone();
    
    // Move Player
    new TWEEN.Tween(p.mesh.position)
        .to({ x: endPos.x, y: endPos.y, z: endPos.z }, 1500)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .onComplete(() => {
            if (onComplete) {
                setTimeout(() => onComplete(), 100); 
            }
        })
        .start();

    // Move Camera (Offset)
    const offset = { x: 0, y: 22, z: 18 }; 

    new TWEEN.Tween(camera.position)
        .to({
            x: endPos.x + offset.x,
            y: offset.y, // Maintain steady height
            z: endPos.z + offset.z 
        }, 1500)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .start();
}

function resetCamera() {
    isZoomed = false;
    cameraTarget = null;
    
    // Default overhead view
    const width = window.innerWidth;
    const isMobileMode = document.body.classList.contains('force-mobile') || width <= 768;
    let dist = 55;
    if (isMobileMode) {
       const boardSize = 55; 
       const fovRad = (45 * Math.PI) / 360; 
       const height = window.innerHeight * 0.82; 
       const aspect = width / height;
       if (aspect > 1) dist = (boardSize / 2) / Math.tan(fovRad);
       else dist = ((boardSize / aspect) / 2) / Math.tan(fovRad);
    }

    new TWEEN.Tween(camera.position)
        .to({ x: 0, y: dist, z: 0.1 }, 1200)
        .easing(TWEEN.Easing.Cubic.Out)
        .onUpdate(() => camera.lookAt(0, 0, 0))
        .start();
}

// Handles the logic for the single big circle button
function handleActionClick() {
    // If it's the Roll Phase, Roll.
    if (gameState === 'ROLL') {
        rollMove();
    } 
    // If it's the End Phase, End Turn.
    else if (gameState === 'END') {
        endTurn();
    }
    // Otherwise, button shouldn't be clickable, but just in case:
    else {
        console.log("Not a valid phase for action button");
    }
}

function onWindowResize() {
    const wrapper = document.getElementById('game-viewport-wrapper');
    const width = wrapper.clientWidth;
    const height = wrapper.clientHeight;
    
    camera.aspect = width / height; 
    camera.updateProjectionMatrix();
    
    renderer.setSize(width, height); 
    // IMPORTANT: style.width/height needs to match to prevent stretching
    renderer.domElement.style.width = width + 'px';
    renderer.domElement.style.height = height + 'px';
    
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    
    updateCamera(); 
}

function transitionDayNight(toNight) {
    // 1. Board Transition
    new TWEEN.Tween(nightBoard.material)
        .to({ opacity: toNight ? 1 : 0 }, 5000)
        .start();

    // 2. Play Transition SFX (Only when going Day -> Night)
    if(toNight) {
        AUDIO.playSound('sfx_transition');
    }

    // 3. Fog Transition
    if (toNight) {
        // Fog Fades In
        if(fogGroup) {
            fogGroup.children.forEach(cloud => {
                cloud.position.x = cloud.userData.initialX;
                cloud.position.z = cloud.userData.initialZ;
                new TWEEN.Tween(cloud.material).to({ opacity: 0.5 + Math.random() * 0.3 }, 5000).start();
            });
        }
        new TWEEN.Tween(scene.background).to({r:0.02, g:0.02, b:0.06}, 5000).start();
    } else {
        // Fog Moves Out
        if(fogGroup) {
            fogGroup.children.forEach(cloud => {
                const destX = cloud.position.x > 0 ? 60 : -60;
                new TWEEN.Tween(cloud.position).to({ x: destX }, 5000).start();
                new TWEEN.Tween(cloud.material).to({ opacity: 0 }, 5000).start();
            });
        }
        new TWEEN.Tween(scene.background).to({r:0.8, g:0.8, b:0.8}, 5000).start();
    }
}

// --- DYNAMIC EVENT GLOBALS ---
let activeEvent = null; // Stores current event data { id, mesh, pos, type }
let particleSystem = null; // For weather
let eventTurnCounter = 0; // Duration tracker

// --- EVENT DEFINITIONS ---

// --- EVENT ENTITY HANDLERS (Visuals Only) ---
function spawnEventEntity(data) {
    // 1. Create Model (Visuals)
    const mesh = createDetailedBossMesh(data.modelType);
    
    // 2. Create ID
    const entityId = -1 * (Math.floor(Math.random() * 1000) + 10);
    
    // 3. Random Spawn Position
    const startPos = Math.floor(Math.random() * 40);

    // 4. Create Entity Object
    const entityPlayer = {
        id: entityId,
        name: data.name,
        isEventEntity: true, 
        isAi: true,       
        bossType: data.type, 
        color: '#a855f7',
        pos: startPos, 
        mesh: mesh,
        gold: 99999, 
        stats: { str: 0, dex: 0, int: 0 }, 
        race: null, 
        class: null,
        inventory: [],
        equipment: {},
        metrics: { spacesMoved: 0, successfulSieges: 0, guardsHired: 0 },
        history: []
    };

    // 5. Setup Mesh Scaling and Position
    // FIX: Changed 'g' to 'mesh' to fix the ReferenceError
    mesh.scale.set(1.5, 1.5, 1.5); 
    
    const t = tiles[startPos].position.clone();
    mesh.position.set(t.x, 0, t.z);

    // 6. Add to Players Array
    const maxIdx = Math.max(1, players.length);
    players.splice(maxIdx, 0, entityPlayer);
    
    addLog(`${data.name} has arrived at ${tiles[startPos].userData.info.name}!`, "log-epic");
    updateHUD(); 
    
    return entityPlayer;
}

function removeEventEntity(entityPlayer) {
    if (!entityPlayer) return;
    const idx = players.indexOf(entityPlayer);
    if (idx > -1) {
        players.splice(idx, 1);
        if(entityPlayer.mesh) scene.remove(entityPlayer.mesh);
        addLog(`${entityPlayer.name} has departed.`, "log-rare");
        
        // Adjust turn index if we removed someone before current turn
        if (idx < turnIndex) turnIndex--;
        updateHUD();
    }
}

function removeBossPlayer(bossPlayer) {
    const idx = players.indexOf(bossPlayer);
    if (idx > -1) {
        players.splice(idx, 1);
        scene.remove(bossPlayer.mesh);
        addLog(`${bossPlayer.name} has departed.`, "log-rare");
        
        // Adjust turn index if we removed someone before current turn
        if (idx < turnIndex) turnIndex--;
        updateHUD();
    }
}

const MAP_EVENTS = [
    // 1. THE ALCHEMIST
    {
        id: 'merch_alchemist', name: "Roaming Alchemist", type: 'merchant', duration: 12, modelType: 'merchant_purple',
        desc: "Potions and Scrolls.",
        onStart: () => { activeEvent.playerRef = spawnEventEntity(MAP_EVENTS[0]); },
        onEnd: () => { removeEventEntity(activeEvent.playerRef); },
        onTurn: (me) => true,
        // UPDATED onLand: Accepts 'next' callback
        onLand: (p, me, next) => {
            if(p.id === 0) { 
                const stock = DECK_TREASURE.filter(i => i.type === 'scroll' && !i.name.includes('Gold') && !i.name.includes('Coin'));
                const items = [];
                for(let k=0; k<3; k++) items.push(stock[Math.floor(Math.random()*stock.length)]);
                // Pass 'next' to the shop function
                openCustomShop(p, items, "Alchemist's Cart", next);
            } else {
                // AI simply ignores shop and proceeds to tile
                if(next) next();
            }
        }
    },
    // 2. THE ARMORER
    {
        id: 'merch_armorer', name: "Iron Caravan", type: 'merchant', duration: 12, modelType: 'merchant_red',
        desc: "Heavy armor and shields.",
        onStart: () => { activeEvent.playerRef = spawnEventEntity(MAP_EVENTS[1]); },
        onEnd: () => { removeEventEntity(activeEvent.playerRef); },
        onTurn: (me) => true,
        onLand: (p, me, next) => {
            if(p.id === 0) {
                const stock = DECK_TREASURE.filter(i => (i.slot === 'head' || i.slot === 'body' || i.slot === 'off') && !i.name.includes('Gold'));
                const items = [];
                for(let k=0; k<3; k++) items.push(stock[Math.floor(Math.random()*stock.length)]);
                openCustomShop(p, items, "The Iron Caravan", next);
            } else {
                if(next) next();
            }
        }
    },
    // 3. THE WEAPONSMITH
    {
        id: 'merch_weaponsmith', name: "Blade Peddler", type: 'merchant', duration: 12, modelType: 'merchant_red',
        desc: "Sharp steel for sale.",
        onStart: () => { activeEvent.playerRef = spawnEventEntity(MAP_EVENTS[2]); },
        onEnd: () => { removeEventEntity(activeEvent.playerRef); },
        onTurn: (me) => true,
        onLand: (p, me, next) => {
            if(p.id === 0) {
                const stock = DECK_TREASURE.filter(i => i.slot === 'main' && !i.name.includes('Gold'));
                const items = [];
                for(let k=0; k<3; k++) items.push(stock[Math.floor(Math.random()*stock.length)]);
                openCustomShop(p, items, "Blade Peddler", next);
            } else {
                if(next) next();
            }
        }
    },
    // ... (Keep existing Weather/Global events exactly as they were) ...
    { id: 'weather_blizzard', name: "Great Blizzard", type: 'weather', duration: 3, desc: "Heavy snow slows everyone down (-1 Move).", onStart: () => createParticleSystem('snow'), onTurn: () => {}, onEnd: () => { removeParticles(); addLog(" The blizzard clears."); } },
    { id: 'weather_goldrain', name: "Golden Rain", type: 'weather', duration: 1, desc: "Magical rain! Gain 10G per step taken.", onStart: () => createParticleSystem('gold'), onTurn: () => {}, onEnd: () => { removeParticles(); addLog(" The gold rain stops."); } },
    { id: 'event_fog', name: "Dense Fog", type: 'weather', duration: 3, desc: "Visibility reduced. Encounter requirements (Stats/TN) are hidden!", onStart: () => transitionDayNight(true), onEnd: () => transitionDayNight(false) },
    { id: 'event_market', name: "Market Boom", type: 'global', duration: 3, desc: "All properties generate +50% Rent.", onStart: () => addLog("Real estate prices skyrocket!", "log-success") },
    { id: 'event_tax', name: "Royal Audit", type: 'global', duration: 1, desc: "The King demands a tribute instantly.", onStart: () => { players.forEach(pl => { if(!pl.isDead && !pl.isEventEntity) { const tax = Math.floor(pl.gold * 0.1); pl.gold -= tax; treasuryGold += tax; } }); addLog("Royal Audit: Everyone lost 10% Gold.", "log-fail"); updateHUD(); } }
];

// --- EVENT VISUAL BUILDERS ---
// --- ADVANCED MODEL BUILDER ---
function createDetailedBossMesh(type) {
    const g = new THREE.Group();
    let matBody;

    // Only Merchants remain
    if (type.includes('merchant')) {
        const isMystic = type.includes('purple');
        matBody = new THREE.MeshStandardMaterial({ color: isMystic ? 0x6b21a8 : 0x991b1b }); // Purple or Red Robe
        
        // Body
        const robe = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.8, 8), matBody);
        robe.position.y = 0.9;
        
        // Head
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshStandardMaterial({color: 0xffccaa}));
        head.position.y = 1.9;
        
        // Hat
        const hat = new THREE.Mesh(new THREE.ConeGeometry(0.5, 0.8, 8), matBody);
        hat.position.y = 2.3;
        hat.rotation.x = -0.2;

        // Backpack
        const packGroup = new THREE.Group();
        const packMain = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.8), new THREE.MeshStandardMaterial({color:0x5c4033}));
        const bedroll = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.2), new THREE.MeshStandardMaterial({color:0xeee8aa}));
        bedroll.rotation.z = Math.PI/2;
        bedroll.position.y = 0.7;
        
        packGroup.add(packMain, bedroll);
        packGroup.position.set(0, 1.2, -0.6);
        
        g.add(robe, head, hat, packGroup);
    } 
    // Fallback if something else is called (prevents crash)
    else {
        const fallback = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color: 0xff00ff}));
        fallback.position.y = 1;
        g.add(fallback);
    }

    g.position.copy(tiles[0].position);
    scene.add(g);
    return g;
}

function createParticleSystem(type) {
    const count = 1000;
    const geom = new THREE.BufferGeometry();
    const positions = [];
    for(let i=0; i<count; i++) {
        positions.push((Math.random()-0.5)*60, 10+Math.random()*10, (Math.random()-0.5)*60);
    }
    geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    
    let col = (type === 'snow') ? 0xffffff : 0xffd700;
    const mat = new THREE.PointsMaterial({color: col, size: 0.3, transparent: true});
    particleSystem = new THREE.Points(geom, mat);
    particleSystem.userData = { type: type };
    scene.add(particleSystem);
}

function removeParticles() {
    if(particleSystem) {
        scene.remove(particleSystem);
        particleSystem = null;
    }
}

// --- LOGIC HELPERS ---
function triggerRandomEvent() {
    // 1. Cleanup old event
    if(activeEvent) {
        if(activeEvent.data.onEnd) activeEvent.data.onEnd(); // Removes boss from array
        // Note: we don't need scene.remove here because removeBossPlayer handles it
        activeEvent = null;
    }

    // 2. Roll Event
    const idx = Math.floor(Math.random() * MAP_EVENTS.length);
    const evData = MAP_EVENTS[idx];
    
    // 3. Initialize
    activeEvent = {
        data: evData,
        mesh: null, // Mesh is now inside the player object
        turnsLeft: evData.duration,
        playerRef: null // Will store the boss player object
    };

    // 4. Start (Spawns Boss/Particles)
    if(evData.onStart) evData.onStart();

    addLog(`EVENT: ${evData.name}!`, "log-epic");
    addLog(evData.desc, "log-rare");
    AUDIO.playSound('sfx_transition');
}

function processBossTurn(boss) {
    debugLog(`Boss Turn: ${boss.name}`);
    if(!isZoomed) zoomToPiece(boss);

    if (boss.pos === 0) boss.abilityReady = true;

    // Custom Logic
    const eventDef = MAP_EVENTS.find(e => e.name === boss.name);
    let specialMoveUsed = false;
    if (eventDef && eventDef.onTurn) {
        specialMoveUsed = eventDef.onTurn(boss);
    }

    if (specialMoveUsed) {
        debugLog("Boss used Special Move");
        return;
    }

    // Standard Move
    let moveRoll = 0;
    const bName = boss.name || "";
    if (bName.includes("Dragon") || bName.includes("Inferno")) moveRoll = Math.floor(Math.random() * 4) + 2; 
    else if (bName.includes("Wraith") || bName.includes("Void")) moveRoll = 3; 
    else if (bName.includes("Golem")) moveRoll = 1; 
    else moveRoll = 2; 

    addLog(`${boss.name} moves ${moveRoll} spaces.`);
    debugLog(`Boss Rolling: ${moveRoll}`);
    
    gameState = 'MOVING'; 
    animateMove(boss, moveRoll);
}

function moveEntity(eventObj, steps) {
    if(!eventObj.mesh) return;
    
    let currentPos = eventObj.pos;
    eventObj.pos = (currentPos + steps) % 40;
    
    const target = tiles[eventObj.pos].position;
    
    // Animate jump
    new TWEEN.Tween(eventObj.mesh.position)
        .to({x: target.x, z: target.z}, 1000)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .onComplete(() => {
            // Apply effect on tile landed
            if(eventObj.data.onTileEffect) eventObj.data.onTileEffect(tiles[eventObj.pos]);
        })
        .start();
}

function openCustomShop(p, items, title, nextCallback) {
    const m = document.getElementById('card-modal');
    document.getElementById('enc-title').innerText = title;
    document.getElementById('enc-desc').innerText = "Hover/Tap to view info. Double-Tap to buy.";
    document.getElementById('enc-header').className = 'card-header market';
    
    const l = document.getElementById('choice-list'); 
    l.innerHTML = '';
    
    let selectedItemUID = null;

    // --- DISCOUNT LOGIC ---
    const getDiscountedPrice = (baseCost) => {
        let cost = baseCost;
        if (p.passiveSkillId === 'veteran') {
            cost = Math.floor(cost * 0.8); // 20% Off
        }
        if (p.passiveSkillId === 'haggler') {
            cost = Math.floor(cost * 0.75); // 25% Off
        }
        // If both, they stack multiplicatively (approx 40% total)
        return Math.max(0, cost);
    };

    items.forEach(it => {
        let b = document.createElement('div'); 
        b.className = 'choice-btn';
        b.style.display = 'flex';
        b.style.flexDirection = 'column';
        b.style.alignItems = 'flex-start';
        b.style.gap = '2px';
        
        const finalCost = getDiscountedPrice(it.cost);
        
        // Show discount visual if price is different
        let costHtml = `<span style="color:var(--gold)">${finalCost}G</span>`;
        if (finalCost < it.cost) {
            costHtml = `<span style="text-decoration:line-through; color:#666; font-size:0.8em; margin-right:5px;">${it.cost}G</span> ` + costHtml;
        }

        const headerDiv = document.createElement('div');
        headerDiv.style.display = 'flex';
        headerDiv.style.justifyContent = 'space-between';
        headerDiv.style.width = '100%';
        headerDiv.innerHTML = `<span style="font-weight:bold; color:${getRarityColor(it.rarity)}">${it.name}</span> <div>${costHtml}</div>`;
        
        const subDiv = document.createElement('div');
        subDiv.style.fontSize = '0.75rem';
        subDiv.style.color = '#aaa';
        subDiv.innerText = it.type === 'scroll' ? "Scroll (Consumable)" : `Equip: ${it.slot ? it.slot.toUpperCase() : '?'}`;
        
        b.appendChild(headerDiv);
        b.appendChild(subDiv);
        
        b.onmouseenter = () => showTooltip(it);
        b.onmouseleave = hideTooltip;

        const attemptBuy = () => {
            if(p.gold >= finalCost) {
                if(p.inventory.length >= 12) {
                    addLog("Inventory Full!", "log-fail");
                    return;
                }
                p.gold -= finalCost;
                p.inventory.push(createItemInstance(it));
                addLog(`Bought ${it.name} for ${finalCost}G.`, "log-success");
                updateHUD();
                b.remove(); 
                hideTooltip();
                selectedItemUID = null;
            } else {
                addLog("Not enough Gold!", "log-fail");
            }
        };

        b.onclick = (e) => {
            e.stopPropagation();
            if (selectedItemUID === it.id) attemptBuy();
            else {
                document.querySelectorAll('.choice-btn').forEach(btn => btn.style.borderColor = '#4a5568'); 
                b.style.borderColor = '#fbbf24'; 
                selectedItemUID = it.id;
                showTooltip(it);
            }
        };
        
        b.ondblclick = (e) => { e.stopPropagation(); attemptBuy(); };
        l.appendChild(b);
    });
    
    // --- LEAVE BUTTON ---
    let b = document.createElement('div'); 
    b.className = 'choice-btn';
    b.innerText = "Leave Shop";
    b.style.marginTop = "15px";
    b.style.textAlign = "center";
    b.style.justifyContent = "center";
    b.onclick = () => {
        hideTooltip();
        m.classList.remove('active');
        if (nextCallback) nextCallback();
    };
    l.appendChild(b);
    
    m.classList.add('active');
}

// --- UNIQUE ID GENERATOR ---
function generateUID() {
    return 'item_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}

// --- ITEM INSTANTIATOR ---
// Creates a unique copy of an item so it doesn't share state with others
function createItemInstance(templateItem) {
    if (!templateItem) return null; 
    
    // Deep copy data properties
    const newItem = JSON.parse(JSON.stringify(templateItem));
    
    // Ensure Unique ID
    newItem.uid = 'item_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
    
    // Restore function reference from local template (if available)
    if (templateItem.fn) newItem.fn = templateItem.fn;
    if (templateItem.ability && templateItem.ability.fn) newItem.ability.fn = templateItem.ability.fn;

    newItem.isDepleted = false;
    return newItem;
}

// --- UNIFIED NOTIFICATION SYSTEM ---
const NOTIFICATIONS = {
    init: function() {
        if(!currentUser) return;
        
        // Show the bell
        document.getElementById('global-notify-btn').style.display = 'block';

        // Listen for new items in 'inbox'
        db.ref(`users/${currentUser.uid}/inbox`).on('child_added', snap => {
            const note = snap.val();
            const noteKey = snap.key;
            
            // LOGIC: Are we in a Game Room?
            const inGameRoom = (document.getElementById('gameroom-screen').style.display === 'flex');
            
            if (inGameRoom && note.type === 'dm') {
                // OPTION A: Show Purple Text in Room Chat
                this.injectWhisperToRoom(note);
                
                // Remove from database so it doesn't persist as "unread" since we saw it
                db.ref(`users/${currentUser.uid}/inbox/${noteKey}`).remove();
            } else {
                // OPTION B: Increment Badge
                this.updateBadge();
                AUDIO.playSound('sfx_click'); // Small sound cue
            }
        });
        
        // Also listen for removals to update badge count down
        db.ref(`users/${currentUser.uid}/inbox`).on('child_removed', () => {
            this.updateBadge();
        });
    },

    updateBadge: function() {
        db.ref(`users/${currentUser.uid}/inbox`).once('value').then(snap => {
            const count = snap.numChildren();
            const badge = document.getElementById('notify-badge-count');
            if(count > 0) {
                badge.innerText = count;
                badge.style.display = 'flex';
                // Pulse animation
                badge.style.transform = 'scale(1.3)';
                setTimeout(()=>badge.style.transform='scale(1)', 200);
            } else {
                badge.style.display = 'none';
            }
        });
    },

    injectWhisperToRoom: function(note) {
        const chatBox = document.getElementById('room-chat-box');
        if(chatBox) {
            const d = document.createElement('div'); 
            d.className = 'chat-msg whisper';
            // W: SenderName: Message
            d.innerHTML = `<span class="whisper-name">W: ${note.senderName}:</span> <span class="whisper-text">${note.text}</span>`;
            chatBox.appendChild(d);
            chatBox.scrollTop = chatBox.scrollHeight;
        }
    },

    openModal: function() {
        const modal = document.getElementById('notification-modal');
        const list = document.getElementById('notification-list');
        modal.style.display = 'flex';
        list.innerHTML = 'Loading...';

        db.ref(`users/${currentUser.uid}/inbox`).once('value').then(snap => {
            list.innerHTML = '';
            if(!snap.exists()) {
                list.innerHTML = '<div style="color:#aaa; text-align:center;">No new notifications.</div>';
                return;
            }

            snap.forEach(child => {
                const n = child.val();
                const div = document.createElement('div');
                div.className = 'notify-item';
                
                if (n.type === 'dm') {
                    div.innerHTML = `
                        <div class="notify-header">
                            <span>From: ${n.senderName}</span>
                            <span style="cursor:pointer; color:#ef4444;" onclick="NOTIFICATIONS.delete('${child.key}')">Ã—</span>
                        </div>
                        <div class="notify-body">"${n.text}"</div>
                        <div class="notify-actions">
                            <button class="req-btn" style="background:var(--gold-dim); color:#fff;" onclick="DM.open('${n.senderUid}', '${n.senderName}')">Reply</button>
                        </div>
                    `;
                }
                list.prepend(div); // Newest top
            });
        });
    },

    delete: function(key) {
        db.ref(`users/${currentUser.uid}/inbox/${key}`).remove();
        // UI updates automatically via openModal re-render or manual logic? 
        // For simplicity, just hide the specific element or re-open.
        setTimeout(() => this.openModal(), 100);
    },

    clearAll: function() {
        if(confirm("Clear all notifications?")) {
            db.ref(`users/${currentUser.uid}/inbox`).remove();
            this.openModal();
        }
    }
};

function init() {
    // 1. Three.js Setup
    scene = new THREE.Scene(); 
    const fogColor = 0xcccccc; 
    scene.background = new THREE.Color(fogColor); 
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000); 
    
    renderer = new THREE.WebGLRenderer({antialias:true}); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    renderer.shadowMap.enabled = true;
    document.getElementById('game-layer').appendChild(renderer.domElement);
    
    const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffd700, 0.8); dir.position.set(30,40,20); dir.castShadow = true; scene.add(dir);
    
    updateCamera(); 
    window.addEventListener('resize', onWindowResize, false);
    createEnvironment(); 
    createBoard(); 
    createDecks(); 
    createFog(); 
    
    AUDIO.init();

    // --- TRANSITION LOGIC ---
    window.triggerGameMenu = () => {
        const logo = document.getElementById('logo-screen');
        const splash = document.getElementById('splash-screen');
        const authScreen = document.getElementById('auth-screen');
        const logoImg = document.getElementById('logo-img');
        const logoText = document.getElementById('logo-text');

        // 1. Ensure Logo is visible covering everything
        logo.style.display = 'flex';
        logo.style.opacity = '1';
        if(logoImg) logoImg.style.opacity = '1';
        if(logoText) logoText.style.opacity = '1';

        // 2. Start Sequence
        setTimeout(() => {
            // A. Fade out Logo Text/Image first (Black background stays)
            if(logoImg) logoImg.style.opacity = '0';
            if(logoText) logoText.style.opacity = '0';

            // B. Wait 2 seconds, then PREPARE the next screen BEHIND the logo
            setTimeout(() => {
                
                // IMPORTANT: Turn on the destination screen BEFORE fading out the logo
                if(currentUser) {
                    // Logged In: Enable Splash
                    authScreen.style.display = 'none';
                    splash.style.display = 'flex';
                    splash.style.opacity = '1'; 
                    
                    // Check URL Join
                    const urlParams = new URLSearchParams(window.location.search);
                    const joinId = urlParams.get('join');
                    if(joinId) setTimeout(() => LOBBY.attemptJoin(joinId), 500);

                } else {
                    // Not Logged In: Enable Auth
                    splash.style.display = 'none';
                    authScreen.style.display = 'flex';
                }

                // C. Now fade out the Black Background (Revealing Splash or Auth immediately)
                logo.style.opacity = '0';
                AUDIO.tryPlayStart();

                // D. Cleanup Logo from DOM after fade finishes
                setTimeout(() => {
                    logo.style.display = 'none';
                }, 1500); 

            }, 2000); 
        }, 100);
    };

    // 4. Logo Click Listener (Manual Start)
    document.getElementById('logo-screen').addEventListener('click', () => {
        if(document.getElementById('logo-screen').style.opacity !== '0') {
             window.triggerGameMenu();
        }
    }, { once: true });
    
    // 5. Initialize Auth
    AUTH.init();
    
    setupCreationUI(); 
    setupEquipDragDrop();
    animate();
    
    document.addEventListener('click', function(e) {
        if (e.target.closest('button, .choice-btn, .sel-opt, .skill-card, .color-opt, .help-tab, .skill-slot, .equip-slot, .inv-slot, .close-x, #btn-help, #btn-settings')) {
            AUDIO.playSound('sfx_click');
        }
    });
    
    document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
            window.scrollTo(0, 0);
            setTimeout(() => window.scrollTo(0, 0), 100);
        }
    });

    document.addEventListener('touchstart', function() {
        const tt = document.getElementById('tooltip');
        if (tt) tt.style.display = 'none';
    }, { passive: true });

    makeDraggable(document.getElementById("p1-sheet"));
    makeDraggable(document.getElementById("leaderboard"));
	makeDraggable(document.getElementById("dm-window"));
}

function createTileTexture(name, cStr, cost) {
    const c = document.createElement('canvas'); c.width = 256; c.height = 256; const ctx = c.getContext('2d');
    ctx.fillStyle = cStr; ctx.fillRect(0, 0, 256, 256);
    ctx.fillStyle = "rgba(0,0,0,0.1)"; for(let i=0; i<50; i++) ctx.fillRect(Math.random()*256, Math.random()*256, 10, 10);
    ctx.fillStyle = "#fff"; ctx.fillRect(10, 10, 236, 40); ctx.strokeRect(10, 10, 236, 40);
    ctx.fillStyle = "#000"; ctx.font = "bold 20px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(name, 128, 30);
    if(cost > 0) { ctx.fillStyle = "#fbbf24"; ctx.fillRect(80, 210, 96, 30); ctx.strokeRect(80, 210, 96, 30); ctx.fillStyle = "#000"; ctx.fillText(cost + " G", 128, 225); }
    return new THREE.CanvasTexture(c);
}
function createGrassTexture() { const c=document.createElement('canvas'); c.width=512; c.height=512; const ctx=c.getContext('2d'); ctx.fillStyle="#14532d"; ctx.fillRect(0,0,512,512); for(let i=0;i<2000;i++){ctx.fillStyle=Math.random()>0.5?"#166534":"#15803d";ctx.fillRect(Math.random()*512,Math.random()*512,3,3);} const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(8,8); return t; }
function createEnvironment() { const g = new THREE.Mesh(new THREE.PlaneGeometry(600, 600), new THREE.MeshStandardMaterial({map:createGrassTexture()})); g.rotation.x = -Math.PI/2; g.position.y = -0.6; g.receiveShadow = true; scene.add(g); for(let i=0; i<400; i++) { const rad = 45 + Math.random() * 250; const ang = Math.random() * Math.PI * 2; const x = Math.cos(ang) * rad; const z = Math.sin(ang) * rad; if(z > 30 && x > -20 && x < 20) continue; const t = new THREE.Group(); const tr = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 2), new THREE.MeshStandardMaterial({color:0x3e2723})); tr.position.y = 1; const lv = new THREE.Mesh(new THREE.ConeGeometry(3, 6, 8), new THREE.MeshStandardMaterial({color:0x15803d})); lv.position.y = 4; t.add(tr); t.add(lv); t.position.set(x, -0.6, z); t.scale.setScalar(0.8 + Math.random()); scene.add(t); } }
function createBoard() {
    const loader = new THREE.TextureLoader(); 
    const boardTex = loader.load('https://static.wixstatic.com/media/b16479_5caac3525f59406d8ff175695ef11cb1~mv2.jpg');
    const board = new THREE.Mesh(new THREE.PlaneGeometry(45, 45), new THREE.MeshStandardMaterial({ map: boardTex }));
    board.rotation.x = -Math.PI / 2; board.position.y = -0.55; board.receiveShadow = true; scene.add(board);

    // --- NEW: NIGHT BOARD OVERLAY ---
    const nightTex = loader.load('https://static.wixstatic.com/media/b16479_2458008184884e2986ee9e7c6dc37fc8~mv2.jpg');
    // Transparent, Opacity 0 to start. Sits slightly higher (-0.54) to avoid glitching
    nightBoard = new THREE.Mesh(new THREE.PlaneGeometry(45, 45), new THREE.MeshStandardMaterial({ map: nightTex, transparent: true, opacity: 0 }));
    nightBoard.rotation.x = -Math.PI / 2; 
    nightBoard.position.y = -0.54; 
    nightBoard.receiveShadow = true;
    scene.add(nightBoard);
    // --------------------------------

    for(let i=0; i<40; i++) {
        const info = LOCATIONS[i]; let mapTex = (info.img && info.img.length > 0) ? loader.load(info.img) : createTileTexture(info.name, info.color, info.cost);
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.5, 3.8), new THREE.MeshStandardMaterial({ map: mapTex }));
        const side = Math.floor(i/10); const pos = i%10; let x=0, z=0, rot=0; const off = 20; const spa = 4;
        if(side===0) { x = off - (pos*spa); z = off; rot=0; } else if(side===1) { x = -off; z = off - (pos*spa); rot=-Math.PI/2; } else if(side===2) { x = -off + (pos*spa); z = -off; rot=Math.PI; } else { x = off; z = -off + (pos*spa); rot=Math.PI/2; }
        if(i===0){x=off;z=off;} mesh.position.set(x, 0, z); mesh.rotation.y = rot; mesh.receiveShadow = true; mesh.userData = {id:i, info:info, owner:null, buildingLevel:0}; scene.add(mesh); tiles.push(mesh);
    }

}
function createFog() {
    fogGroup = new THREE.Group();
    
    // Create a procedural "Cloud" texture using Canvas (no external image needed)
    const c = document.createElement('canvas'); c.width = 128; c.height = 128;
    const ctx = c.getContext('2d');
    const grd = ctx.createRadialGradient(64,64,0, 64,64,64);
    grd.addColorStop(0, 'rgba(255,255,255,0.3)'); // Light white center
    grd.addColorStop(1, 'rgba(255,255,255,0)');   // Transparent edges
    ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);
    const fogTex = new THREE.CanvasTexture(c);

    // Create 40 fog clouds
    for(let i=0; i<40; i++) {
        const mat = new THREE.MeshBasicMaterial({
            map: fogTex, 
            transparent: true, 
            opacity: 0, // Invisible at start
            depthWrite: false,
            blending: THREE.AdditiveBlending 
        });
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), mat);
        
        // Random placement over the board
        mesh.position.set(Math.random()*60 - 30, 3 + Math.random()*2, Math.random()*60 - 30);
        mesh.rotation.x = -Math.PI/2;
        mesh.rotation.z = Math.random() * Math.PI * 2;
        
        // Save initial X pos for resetting later
        mesh.userData = { initialX: mesh.position.x, initialZ: mesh.position.z };
        
        fogGroup.add(mesh);
    }
    scene.add(fogGroup);
}
function transitionDayNight(toNight) {
    // 1. Board Transition (5 Seconds)
    // Fade NightBoard IN (1) or OUT (0)
    new TWEEN.Tween(nightBoard.material)
        .to({ opacity: toNight ? 1 : 0 }, 5000)
        .start();

    // 2. Fog Transition
    if (toNight) {
        // --- DAY TO NIGHT: Fog Fades In ---
        if(fogGroup) {
            fogGroup.children.forEach(cloud => {
                // Reset positions to random over board
                cloud.position.x = cloud.userData.initialX;
                cloud.position.z = cloud.userData.initialZ;
                
                // Fade In
                new TWEEN.Tween(cloud.material)
                    .to({ opacity: 0.5 + Math.random() * 0.3 }, 5000) // Varied opacity
                    .start();
            });
        }
        // Darken Background
        new TWEEN.Tween(scene.background).to({r:0.02, g:0.02, b:0.06}, 5000).start();
    } else {
        // --- NIGHT TO DAY: Fog Moves Out & Fades Out ---
        if(fogGroup) {
            fogGroup.children.forEach(cloud => {
                // Determine direction: Left or Right based on position
                const destX = cloud.position.x > 0 ? 60 : -60;
                
                // Move Out
                new TWEEN.Tween(cloud.position)
                    .to({ x: destX }, 5000) // Move off screen over 5s
                    .start();

                // Fade Out
                new TWEEN.Tween(cloud.material)
                    .to({ opacity: 0 }, 5000)
                    .start();
            });
        }
        // Lighten Background
        new TWEEN.Tween(scene.background).to({r:0.8, g:0.8, b:0.8}, 5000).start();
    }
}
function createDecks() {
    const geo = new THREE.BoxGeometry(7.5, 0.15, 10.5); const loader = new THREE.TextureLoader(); const whiteMat = new THREE.MeshStandardMaterial({color: 0xffffff});
    function createMaterials(texture) { return [whiteMat, whiteMat, new THREE.MeshStandardMaterial({map: texture}), whiteMat, whiteMat, whiteMat]; }
    normalDeck = new THREE.Group(); const nMats = createMaterials(loader.load('https://static.wixstatic.com/media/b16479_b3d23c888e524e31a6ba70275de7f665~mv2.jpg')); for(let i=0; i<5; i++){ let c = new THREE.Mesh(geo, nMats); c.position.y = i * 0.16; c.rotation.y = Math.random() * 0.05; normalDeck.add(c); } normalDeck.position.set(-10, 0, -2); scene.add(normalDeck);
    skirmishDeck = new THREE.Group(); const sMats = createMaterials(loader.load('https://static.wixstatic.com/media/b16479_cd6258f031004df4962a76830ae296f3~mv2.jpg')); for(let i=0; i<5; i++){ let c = new THREE.Mesh(geo, sMats); c.position.y = i * 0.16; c.rotation.y = Math.random() * 0.05; skirmishDeck.add(c); } skirmishDeck.position.set(10, 0, -2); scene.add(skirmishDeck);
    treasureDeck = new THREE.Group(); const tMats = createMaterials(loader.load('https://static.wixstatic.com/media/b16479_03570af932d9445ea8b35d26c915366d~mv2.jpg')); for(let i=0; i<5; i++){ let c = new THREE.Mesh(geo, tMats); c.position.y = i * 0.16; c.rotation.y = Math.random() * 0.05; treasureDeck.add(c); } treasureDeck.position.set(0, 0, -2); scene.add(treasureDeck);
}

// --- REGION 4: PLAYER & AI (WAS MISSING) ---
function spawnPlayer(id, n, r, c, actId, pasId, ai, col, startPos = 0) {
    // --- FAIL-SAFE OVERRIDE ---
    // If we are in Multiplayer, check the Room Data 'truth'.
    // If the slot says 'human', we force ai = false, no matter what argument was passed.
    if (isMultiplayer && currentRoomData && currentRoomData.slots) {
        const slotDef = currentRoomData.slots[id];
        if (slotDef && slotDef.type === 'human') {
            console.log(`[SPAWN FIX] Forcing Player ${id} (${n}) to HUMAN (was ${ai})`);
            ai = false;
        }
    }
    // ---------------------------

    const stats = { str: r.stats.str, dex: r.stats.dex, int: r.stats.int, gold: 1000 };
    
    const passiveDef = ABILITY_LIBRARY[pasId];
    if (passiveDef && passiveDef.effect) passiveDef.effect(stats);
    
    let archetype = 'str';
    if(c.id === 'wizard' || c.id === 'cleric' || r.stats.int > r.stats.str) archetype = 'int';
    else if(c.id === 'rogue' || r.stats.dex > r.stats.str) archetype = 'dex';
    
    const g = createPlayerMesh(r, c, col);
    
    // Set Initial Position
    if (tiles[startPos]) {
        g.position.copy(tiles[startPos].position);
    } else {
        g.position.copy(tiles[0].position);
    }

    if (id > 0) { 
        g.position.x += (Math.random() - 0.5) * 0.5; 
        g.position.z += (Math.random() - 0.5) * 0.5; 
    }
    scene.add(g);
    
    const portraitUrl = CHAR_PORTRAITS[`${r.id}_${c.id}`] || "";
    
    const newPlayer = {
        id: id, name: n, race: r, class: c, portrait: portraitUrl,
        activeSkillId: actId, passiveSkillId: pasId,
        stats: stats, gold: stats.gold, 
        pos: startPos, 
        mesh: g, color: col, 
        isAi: ai, // Now using the corrected flag
        archetype: archetype, 
        equipment: { main: null, off: null, head: null, body: null },
        inventory: [], 
        quickSlots: [null, null], 
        isSkipping: false, abilityUsed: false,
        shadowStrikeDebuff: false,
        pacifistBuff: false,
        resurrectionUsed: false,
        extraTurn: false,
        metrics: { spacesMoved: 0, successfulSieges: 0, guardsHired: 0 },
        history: [{ turn: 0, gold: 1000, props: 0 }] 
    };

    if (pasId === 'vanguard') {
        const vImg = (ITEM_IMAGE_POOLS["Vanguard Blade"] && ITEM_IMAGE_POOLS["Vanguard Blade"].length > 0) 
                     ? ITEM_IMAGE_POOLS["Vanguard Blade"][0] : "";
        const sword = { id: `vg_${id}`, name: `Vanguard Blade`, type: 'equip', slot: 'main', bonus: {str:2}, rarity: 'rare', cost: 300, img: vImg };
        newPlayer.inventory.push(sword);
    }
    
    if (pasId === 'leyline') {
        const manaWell = tiles.find(t => t.userData.info.type === 'util');
        if (manaWell) {
            newPlayer.pos = manaWell.userData.id;
            newPlayer.mesh.position.copy(manaWell.position);
        }
    }

    players.push(newPlayer);
}
function recalcStats(p) {
    if (!p || p.isBoss || p.isEventEntity || !p.race) return;

    // Base Stats
    p.stats.str = p.race.stats.str; 
    p.stats.dex = p.race.stats.dex; 
    p.stats.int = p.race.stats.int;
    
    // Items
    ['head', 'body', 'main', 'off'].forEach(slot => { 
        const item = p.equipment[slot]; 
        if(item && item.bonus) { 
            const k = Object.keys(item.bonus)[0]; 
            if (p.stats[k] !== undefined) p.stats[k] += item.bonus[k]; 
        } 
    });

    // Passive Library Effects
    const pas = ABILITY_LIBRARY[p.passiveSkillId]; 
    if(pas && pas.effect) pas.effect(p.stats);

    // --- NEW MODIFIERS ---
    
    // Shadow Strike Debuff
    if (p.shadowStrikeDebuff) {
        p.stats.str = Math.max(1, p.stats.str - 1);
        p.stats.dex = Math.max(1, p.stats.dex - 1);
        p.stats.int = Math.max(1, p.stats.int - 1);
    }
    
    // Pacifist Buff
    if (p.pacifistBuff) {
        p.stats.str += 1;
        p.stats.dex += 1;
        p.stats.int += 1;
    }
}

function processTax(victim, amount) {
    // --- FIX: BOSS IMMUNITY ---
    if (victim.isBoss) {
        addLog(`${victim.name} scares the Tax Collector away!`, "log-rare");
        return; 
    }
    // --------------------------

    // 1. Check Immunity (Self)
    if (victim.passiveSkillId === 'court_mage' || victim.activeSkillId === 'court_mage') {
        addLog(`${victim.name} (Court Mage) is Tax Exempt!`, "log-rare");
        return; 
    }

    // 2. Check for Court Mage to siphon gold (Other players)
    const mage = players.find(p => 
        !p.isDead && 
        p.id !== victim.id && 
        (p.passiveSkillId === 'court_mage' || p.activeSkillId === 'court_mage')
    );

    let taxAmount = amount;

    if (mage) {
        const siphon = Math.min(10, taxAmount); 
        taxAmount -= siphon;
        mage.gold += siphon;
        addLog(`Court Mage (${mage.name}) took ${siphon}G tax cut.`, "log-epic");
    }

    // 3. Pay the rest to Treasury
    if (taxAmount > 0) {
        pay(victim, taxAmount); 
    }
}

function manageAiInventory(p) {
    if (!p || !p.inventory) return;

    // 1. Clean Inventory Logic (Inline to ensure it runs)
    // Remove any null/undefined entries to prevent crashes
    p.inventory = p.inventory.filter(item => item !== null && item !== undefined);

    // 2. Determine stat priority
    const mainStat = p.archetype || 'str'; 

    // 3. Iterate backwards safely
    for (let i = p.inventory.length - 1; i >= 0; i--) {
        const item = p.inventory[i];
        
        // Double check existence + type check
        if (item && item.type === 'equip') {
            const current = p.equipment[item.slot]; 
            let shouldEquip = false;
            
            if (!current) {
                shouldEquip = true;
            } else {
                // Compare stats
                const currentVal = (current.bonus && current.bonus[mainStat]) ? current.bonus[mainStat] : 0;
                const newVal = (item.bonus && item.bonus[mainStat]) ? item.bonus[mainStat] : 0;
                
                // For Bosses, check total stats
                const currentTotal = current.bonus ? Object.values(current.bonus).reduce((a,b)=>a+b,0) : 0;
                const newTotal = item.bonus ? Object.values(item.bonus).reduce((a,b)=>a+b,0) : 0;

                if (newVal > currentVal || (newVal === currentVal && newTotal > currentTotal)) {
                    shouldEquip = true;
                }
            }
            
            if (shouldEquip) { 
                addLog(`${p.name} equips ${item.name}.`, "log-rare"); 
                // Pass p.id to use the safe lookup in equipItem
                equipItem(p.id, i); 
            }
        }
    }
}

function attemptAiAbilities(p, phase) {
    if (phase === 'pre-roll') {
        if (p.isSkipping) { 
            // Try to heal status
            if (p.activeSkillId === 'heal_light' && !p.classSkillDepleted) useSkillAi(p, 0); 
            checkItemSkills(p, ['heal', 'teleport']);
            return false; 
        }
        
        // Check for Class Skill (Active)
        if (!p.classSkillDepleted && Math.random() > 0.6) {
            const skill = ABILITY_LIBRARY[p.activeSkillId];
            // If the skill is a movement skill, we return TRUE to stop the standard roll
            if (skill && (skill.name === 'Blink' || skill.name === 'Sprint' || skill.name === 'Teleport' || skill.name === 'Town Portal')) {
                useSkillAi(p, 0); 
                return true; // MOVEMENT OCCURRED
            }
            // Other non-movement skills (buffs, etc) just fire and continue
            useSkillAi(p, 0); 
        }
    }
    // Combat phase logic remains...
    if (phase === 'combat') { checkItemSkills(p, ['might', 'focus', 'agility', 'fireball', 'smite']); }
    
    return false;
}

function checkItemSkills(p, skillKeys) {
    ['head', 'body', 'main', 'off'].forEach(slot => {
        const item = p.equipment[slot];
        if (item && item.ability && !item.isDepleted) {
            const key = Object.keys(ABILITY_LIBRARY).find(k => ABILITY_LIBRARY[k].name === item.ability.name);
            if (skillKeys.includes(key) || Math.random() > 0.7) { item.ability.fn(p); item.isDepleted = true; updateHUD(); }
        }
    });
}

function useSkillAi(p, slotIdx) {
    if(slotIdx === 0 && !p.classSkillDepleted) { const skill = ABILITY_LIBRARY[p.activeSkillId]; if(skill && skill.fn) { skill.fn(p); p.classSkillDepleted = true; updateHUD(); } }
}

// --- REGION 5: LOGIC (Turns, Move, Combat) ---
function rollMove() { 
    if(gameState !== 'ROLL') return; 
    
    const p = players[turnIndex]; 
    if(p.isDead) { endTurn(); return; }

    // Disable button immediately to prevent double clicks
    const btn = document.getElementById('btn-action');
    if(btn) btn.disabled = true;

    // --- SINGLE PLAYER ---
    if (!isMultiplayer) {
        let d1 = Math.floor(Math.random() * 6) + 1;
        let d2 = Math.floor(Math.random() * 6) + 1;
        let total = d1 + d2;
        if (p.passiveSkillId === 'shadow_step') total += 1;
        if (activeEvent && activeEvent.data.id === 'weather_blizzard') total = Math.max(1, total - 1);
        
        addLog(`${p.name} rolled ${d1+d2}.`);
        if (p.id === 0) AUDIO.playSound('sfx_roll');
        finishRollLogic(p, total);
        return;
    }

    // --- MULTIPLAYER ---
    const isMyTurn = (p.id === myPlayerId);
    // Host handles AI, but we must check room slots to ensure it's actually an AI slot
    let isAiTurn = (p.isAi && myPlayerId === 0);
    if (currentRoomData && currentRoomData.slots[p.id].type === 'human') isAiTurn = false;

    if (isMyTurn || isAiTurn) {
        if (db && gameId) {
            // Send Request using .push() to create unique ID
            db.ref(`games/${gameId}/request`).push({
                type: 'ROLL',
                pid: p.id
            });
        }
    }
}
function finishRollLogic(p, r) {
    // Shadow Step Logic (Passive +1)
    const passive = ABILITY_LIBRARY[p.passiveSkillId];
    if (passive && passive.name === "Shadow Step") { 
        r += 1; 
        addLog("Shadow Step: +1 Move"); 
    }

    // --- WEATHER MODIFIERS ---
    if (activeEvent && activeEvent.data.id === 'weather_blizzard') {
        r = Math.max(1, r - 1);
        addLog("Blizzard slows you down! (-1)", "log-fail");
    }
    
    // Capture the distance for animation logic
    if (activeEvent && activeEvent.data.id === 'weather_goldrain') {
        const bonus = r * 10; // 10G per step
        p.gold += bonus;
        addLog(`Golden Rain: +${bonus}G`, "log-gold");
    }
    // -------------------------

    gameState='MOVING'; 
    animateMove(p,r); 
}

function animateMove(p, s) { 
    if (s <= 0) { 
        // Turn back to camera before resolving landing
        new TWEEN.Tween(p.mesh.rotation)
            .to({ y: 0 }, 300)
            .onComplete(() => resolveLanding(p))
            .start();
        return; 
    } 
    
    // Ensure we are tracking the player mesh
    if (!isZoomed || cameraTarget !== p.mesh) {
        cameraTarget = p.mesh;
        isZoomed = true;
    }

    p.pos = (p.pos + 1) % 40; 
    p.metrics.spacesMoved++;

    // --- Logic Checks (Cutpurse, Leyline, Start) ---
    if (p.passiveSkillId === 'cutpurse' && s > 1) {
        const victims = players.filter(v => v.id !== p.id && !v.isDead && v.pos === p.pos);
        let stolenPassing = 0;
        victims.forEach(v => {
            const amt = Math.min(5, v.gold); 
            if (amt > 0) { v.gold -= amt; stolenPassing += amt; }
        });
        if (stolenPassing > 0) {
            p.gold += stolenPassing;
            if (p.id === 0) addLog(`Cutpurse: Swiped ${stolenPassing}G passing by.`, "log-rare");
            updateHUD();
        }
    }
    
    if (p.passiveSkillId === 'leyline' && tiles[p.pos].userData.info.type === 'util') {
        p.gold += 200;
        addLog("Leyline Walker: +200G at Mana Well!", "log-epic");
        updateHUD();
    }

    if (p.pos === 0) {
        p.gold += 200; addLog("Passed Inn (+200G)", "log-success");
        let recharged = false;
        if(p.classSkillDepleted) { p.classSkillDepleted = false; recharged = true; }
        if(p.shadowStrikeDebuff) { p.shadowStrikeDebuff = false; recharged = true; }
        if(p.pacifistBuff) { p.pacifistBuff = false; recharged = true; }
        ['head', 'body', 'main', 'off'].forEach(slot => { 
            const item = p.equipment[slot]; 
            if (item && item.isDepleted) { item.isDepleted = false; recharged = true; } 
        });
        if(recharged) addLog("Abilities Recharged & Status Cleared.", "log-epic");
        updateHUD();
    } 

    // --- ANIMATION SYNC ---
    const t = tiles[p.pos].position.clone(); 
    if (p.id > 0) { t.x += (Math.random()-0.5)*0.5; t.z += (Math.random()-0.5)*0.5; } 

    // 1. Calculate Rotation
    const dx = t.x - p.mesh.position.x;
    const dz = t.z - p.mesh.position.z;
    const angle = Math.atan2(dx, dz);

    // 2. Rotate First (150ms)
    new TWEEN.Tween(p.mesh.rotation)
        .to({ y: angle }, 150)
        .onComplete(() => {
            // 3. Move Player (300ms)
            new TWEEN.Tween(p.mesh.position)
                .to({x: t.x, z: t.z}, 300)
                .start();
            
            // 4. Move Camera (300ms) - EXACT SAME DURATION
            if(isZoomed) {
                const offset = { x: 0, y: 22, z: 18 }; 
                new TWEEN.Tween(camera.position)
                    .to({
                        x: t.x + offset.x, 
                        y: offset.y, // Maintain steady height (ignore player hop)
                        z: t.z + offset.z
                    }, 300)
                    .start();
            }

            // 5. Hop Arc (Visual Only)
            new TWEEN.Tween(p.mesh.position)
                .to({y: 1.5}, 150)
                .yoyo(true)
                .repeat(1)
                .onComplete(() => animateMove(p, s - 1))
                .start();
        })
        .start();
}
function endStep(){ 
    // Prevent double-ending the same turn
    if (gameState === 'END') return; 

    gameState = 'END'; 
    updateHUD(); 
    
    // AI/Boss Auto-End
    const currentP = players[turnIndex];
    if(currentP.isAi || currentP.isBoss) { 
        // Short delay to let the user see the result (e.g., "Captured!")
        setTimeout(endTurn, 800); 
    }
}

function endTurn(){
    if (turnProcessing || gameState === 'MOVING') return;
    turnProcessing = true;

    const btnAction = document.getElementById('btn-action');
    if(btnAction) { btnAction.disabled = true; btnAction.innerText = "..."; }

    const prevP = players[turnIndex]; 
    if (prevP && !prevP.isEventEntity && !prevP.isBoss) {
        if (prevP.isPolymorphed) cureSheep(prevP);
        recalcStats(prevP);
        
        // --- FIX: Allow Host to manage AI Inventory in MP ---
        // Old: if(!isMultiplayer && prevP.isAi)
        // New: Run if Single Player OR (Multiplayer AND I am Host)
        if (prevP.isAi && (!isMultiplayer || myPlayerId === 0)) {
            manageAiInventory(prevP); 
        }
        // ---------------------------------------------------

        const props = tiles.filter(t => t.userData.owner === prevP.id).length;
        prevP.history.push({ turn: turnCount, gold: prevP.gold, props: props });
    }

    setTimeout(() => {
        // --- MULTIPLAYER LOGIC ---
        if(isMultiplayer && db && gameId) {
            const isMyTurn = (prevP.id === myPlayerId);
            const isAiTurn = (prevP.isAi && myPlayerId === 0);
            if (isMyTurn || isAiTurn) {
                db.ref(`games/${gameId}/request`).push({
                    type: 'END_TURN',
                    pid: prevP.id
                });
            }
            turnProcessing = false;
            return; 
        }

        // --- SINGLE PLAYER LOGIC ---
        let nextIndex;
        if (prevP && prevP.extraTurn) {
            nextIndex = turnIndex; 
            prevP.extraTurn = false; 
            addLog(`${prevP.name} warps time! Taking another turn.`, "log-epic");
        } else {
            nextIndex = (turnIndex + 1) % players.length;
            let safetyCount = 0;
            while(players[nextIndex].isDead && safetyCount < players.length) {
                nextIndex = (nextIndex + 1) % players.length;
                safetyCount++;
            }
        }

        if (nextIndex === 0 && !prevP.extraTurn) {
            turnCount++;
            if (activeEvent) {
                activeEvent.turnsLeft--;
                if (activeEvent.turnsLeft <= 0) {
                    if(activeEvent.data.onEnd) activeEvent.data.onEnd();
                    if(activeEvent.playerRef) removeEventEntity(activeEvent.playerRef);
                    activeEvent = null;
                    removeParticles();
                    addLog("Event ended.", "log-entry");
                }
            } else {
                const roll = Math.floor(Math.random() * 6) + 1;
                if (roll === 6) {
                    triggerRandomEvent();
                }
            }
        }
        
        turnIndex = nextIndex;
        gameState = 'ROLL'; 
        updateHUD();
        turnProcessing = false;

        const curP = players[turnIndex];
        if(curP.isDead) { endTurn(); return; }

        if(curP.isAi) { 
            zoomToPiece(curP);
            if (curP.isEventEntity) setTimeout(() => processBossTurn(curP), 800);
            else setTimeout(() => { 
                const didMove = attemptAiAbilities(curP, 'pre-roll'); 
                if (!didMove) setTimeout(rollMove, 500); 
            }, 1000);
        } 
        else {
            if(curP.id === myPlayerId) {
                addLog("Your Turn!");
                zoomToPiece(curP);
                if(typeof AUDIO !== 'undefined') AUDIO.playSound('sfx_transition');
            } else {
                addLog(`${curP.name}'s Turn`);
                zoomToPiece(curP);
            }
        }
    }, 1200); 
}
function resolveLanding(p) {
    debugLog(`Landed: ${p.name} at Tile ${p.pos} (AI: ${p.isAi})`);
    
    // --- SINGLE PLAYER ---
    if (!isMultiplayer) {
        triggerTileEvent(p); 
        return;
    }

    // --- MULTIPLAYER ---
    const isMe = (p.id === myPlayerId);
    const isMyAi = (p.isAi && myPlayerId === 0); // Host owns AI

    // Only the "Owner" of the character initiates the event
    if (isMe || isMyAi) {
        // Sync position to DB to be safe
        db.ref(`games/${gameId}/players/${p.id}`).update({ pos: p.pos });
        
        // Trigger the event logic
        triggerTileEvent(p); 
    }
}

// Helper to separate Logic from the Authority Check
function triggerTileEvent(p) {
    const t = tiles[p.pos]; 
    const i = t.userData.info;
    
    // 1. AI LOGIC
    if (p.isAi) {
        if (isMultiplayer) {
            // Host sends the request for the AI
            if (myPlayerId === 0) {
                db.ref(`games/${gameId}/request`).push({
                    type: 'TILE_EVENT',
                    pid: p.id,
                    tileIndex: p.pos
                });
            }
        } else {
            // Single Player Local Logic
            processAiTurn(p, t, i); 
        }
        return;
    }
    
    // 2. HUMAN MULTIPLAYER LOGIC
    if (isMultiplayer) {
        // If it is ME, I request the event
        if (p.id === myPlayerId) {
            db.ref(`games/${gameId}/request`).push({
                type: 'TILE_EVENT',
                pid: p.id,
                tileIndex: p.pos
            });
        }
        return;
    }

    // 3. HUMAN SINGLE PLAYER LOGIC (Visuals)
    const m = document.getElementById('arrival-modal');
    if(m) {
        const imgEl = document.getElementById('arrival-image');
        if(imgEl) { 
            if(i.cardImg) { imgEl.src = i.cardImg; imgEl.style.display = 'block'; } 
            else { imgEl.style.display = 'none'; } 
        }
        const flavorEl = document.getElementById('arrival-flavor');
        if(flavorEl) flavorEl.innerText = i.flavor || "You arrive at " + i.name + ".";
        m.classList.add('active');
    }
    AUDIO.playSound('sfx_gold');
}

// --- NEW FUNCTION: SEPARATED TILE LOGIC ---
function triggerTileEvent(p) {
    const t = tiles[p.pos]; 
    const i = t.userData.info;
    
    // 1. AI Logic (Host handles locally for speed, or you can route via MP logic too)
    if(p.isAi && !isMultiplayer) { 
        processAiTurn(p, t, i); 
        return; 
    }
    
    // 2. MULTIPLAYER REQUEST
    if (isMultiplayer) {
        const isMyTurn = (p.id === myPlayerId);
        const isAiTurn = (p.isAi && myPlayerId === 0);
        
        if (isMyTurn || isAiTurn) {
            // Ask Host to generate the card/shop
            db.ref(`games/${gameId}/request`).push({
                type: 'TILE_EVENT',
                pid: p.id,
                tileIndex: p.pos
            });
        }
        // Wait for the 'currentEvent' listener to trigger UI
        return;
    }

    // 3. SINGLE PLAYER (Local Generation)
    const m = document.getElementById('arrival-modal');
    if(m) {
        const imgEl = document.getElementById('arrival-image');
        if(imgEl) { 
            if(i.cardImg) { imgEl.src = i.cardImg; imgEl.style.display = 'block'; } 
            else { imgEl.style.display = 'none'; } 
        }
        const flavorEl = document.getElementById('arrival-flavor');
        if(flavorEl) flavorEl.innerText = i.flavor || "You arrive at " + i.name + ".";
        m.classList.add('active');
    }
    AUDIO.playSound('sfx_gold');
}

function continueFromArrival() {
    document.getElementById('arrival-modal').classList.remove('active');
    const p = players[turnIndex]; const t = tiles[p.pos]; const i = t.userData.info;
    
    if(i.type === 'start') { if(p.id === 0) showEncounter(p, i, t, 'shop'); else endStep(); return; }
    if(i.type === 'mystery') {
        const deckType = isNight ? 'skirmish' : 'normal';
        drawCardAnim(deckType, () => showEncounter(p, i, t, 'mystery_event'));
        return;
    }
    if(i.type === 'park') { 
        if(treasuryGold > 0){ p.gold += treasuryGold; addLog(`Won ${treasuryGold}G!`, "log-success"); treasuryGold = 0; updateHUD(); } 
        else { addLog("Treasury empty."); } 
        endStep(); return; 
    }
    if(i.type === 'tax') { processTax(p, 50); endStep(); return; } 
    if(i.type === 'goto') { 
        if (p.passiveSkillId === 'smoke_bomb' || p.activeSkillId === 'smoke_bomb') { addLog("Skeleton Key: Evaded Dungeon!", "log-epic"); endStep(); } 
        else { p.pos = 10; p.mesh.position.copy(tiles[10].position); addLog("Jailed!", "log-fail"); p.isSkipping = true; endStep(); }
        return; 
    } 
    if(i.type === 'jail') { endStep(); return; }
	if(i.type === 'chest') { 
            const card = DECK_TREASURE[Math.floor(Math.random() * DECK_TREASURE.length)]; 
            
            // UPDATED
            p.inventory.push(createItemInstance(card)); 
            
            addLog(`${p.name} found ${card.name}.`, "log-success"); 
            if (card.name === "Pouch of Gold" && p.passiveSkillId === 'alchemist_pas') { 
                const extra = DECK_TREASURE[Math.floor(Math.random() * DECK_TREASURE.length)]; 
                // UPDATED
                p.inventory.push(createItemInstance(extra)); 
                addLog(`Alchemist Bonus: Found ${extra.name}!`, "log-epic"); 
            } 
            endStep(); return; 
        }

    const deckType = isNight ? 'skirmish' : 'normal'; const modeType = isNight ? 'wild_skirmish' : 'wild'; const owner = t.userData.owner;
    
    if(owner === p.id) { 
        if(t.userData.buildingLevel === 1) { 
            showModal("Upgrade?", `Build Tavern ${i.cost*2}G? (Skirmish)`, [ 
                { txt: "Upgrade", act: () => { 
                    if(p.gold >= i.cost*2) { 
                        p.gold -= i.cost*2; 
                        drawCardAnim('skirmish', () => showEncounter(p, i, t, "upgrade")); 
                    } else { addLog("No Gold"); endStep(); } 
                }}, 
                { txt: "Skip", act: endStep } 
            ]); 
        } else { 
            let guards = t.userData.guardCount || 0; 
            showModal("Manage Tavern", `Current Guards: ${guards}. Hire Bodyguard for 50G?`, [ 
{ 
    txt: "Hire Guard (50G)", 
    act: () => { 
        if(p.gold >= 50) { 
            p.gold -= 50; 
            t.userData.guardCount = (t.userData.guardCount || 0) + 1; 
            p.metrics.guardsHired++;
            addLog("Guard Hired!", "log-gold"); 
            updateHUD(); 
            
            // REFRESH VISUALS: Call capture with current level to redraw guards
            capture(t, p, t.userData.buildingLevel, () => endStep()); 
        } else { 
            addLog("Not enough Gold"); 
            endStep(); 
        } 
    }
},
                { txt: "Rest (Skip)", act: endStep } 
            ]); 
        } 
    } else if(owner !== null) { 
        drawCardAnim('normal', () => showEncounter(p, i, t, "enemy")); 
    } else { 
        drawCardAnim(deckType, () => showEncounter(p, i, t, modeType)); 
    }
}

function processAiTurn(p, t, i) {
    // Security: Only Host runs AI
    if (isMultiplayer && myPlayerId !== 0) return;
    
    // Prevent AI logic for Humans
    if (isMultiplayer && currentRoomData && currentRoomData.slots[p.id].type === 'human') return;

    debugLog(`AI (${p.name}) processing tile...`);
    
    setTimeout(() => {
        try {
            // --- MYSTERY TILE (Headless Resolution) ---
            if (i.type === 'mystery') {
                addLog(`${p.name} explores the mystery...`, "log-rare");
                
                // 1. Select Card (Logic only, no visual deck draw)
                const deck = isNight ? DECK_SKIRMISH : DECK_ENCOUNTER;
                const card = deck[Math.floor(Math.random() * deck.length)] || DECK_ENCOUNTER[0];
                
                if (card && card.choices) {
                    // 2. AI Chooses Best Option
                    let best = card.choices[0];
                    if (card.choices[1]) {
                        const stat1 = p.stats[best.stat] || 0;
                        const stat2 = p.stats[card.choices[1].stat] || 0;
                        if (stat2 > stat1) best = card.choices[1];
                    }
                    
                    // 3. Resolve Combat silently (headless)
                    // We need a version of rollCombat that doesn't touch the DOM
                    resolveAiCombat(p, best.stat, best.tn, best.req || 1, t, best.mode, best.val || 0, best.fail || 50);
                    return;
                }
                endStep(); return;
            }
            
            // --- CHEST (Headless) ---
            if(i.type === 'chest') {
                const card = DECK_TREASURE[Math.floor(Math.random() * DECK_TREASURE.length)];
                p.inventory.push(createItemInstance(card));
                addLog(`${p.name} found ${card.name}.`, "log-success");
                endStep(); return;
            }

            // --- SHOPS / TAX / PARK ---
            if(i.type === 'shop' || i.type === 'start') { endStep(); return; } // AI skips shops
            if(i.type === 'tax') { processTax(p, 50); endStep(); return; }
            if(i.type === 'park') { 
                if(treasuryGold > 0) { p.gold += treasuryGold; addLog(`${p.name} wins Treasury!`, "log-gold"); treasuryGold=0; updateHUD(); }
                endStep(); return; 
            }

            // --- STANDARD CAPTURE LOGIC ---
            // (Same as before, but ensure capture() doesn't trigger UI callbacks)
            if(i.cost > 0 && t.userData.owner === null) {
                if(p.gold >= i.cost * 1.5) {
                    capture(t, p, 1, () => checkForBonusLoot(p));
                } else {
                    addLog(`${p.name} passes.`, "log-entry");
                    endStep();
                }
                return;
            }

            // --- ENEMY LAND ---
            if(t.userData.owner !== null && t.userData.owner !== p.id) {
                // ... (Keep your existing siege calc logic) ...
                // If sieging:
                // resolveAiCombat(p, stat, tn, req, t, 'capture', 0, failCost);
                // If paying:
                // pay(p, i.cost...); endStep();
                
                // For brevity, defaulting to pay here to ensure it works
                const owner = players.find(pl => pl.id === t.userData.owner);
                pay(p, i.cost, owner);
                endStep();
                return;
            }

            endStep();

        } catch (err) {
            console.error("AI Error", err);
            endStep();
        }
    }, 600);
}

function syncPlayerState() {
    if (!isMultiplayer || !db || !gameId) return;
    
    const p = players.find(pl => pl.id === myPlayerId);
    if (!p) return;

    // We only sync essential data to save bandwidth
    db.ref(`games/${gameId}/players/${myPlayerId}`).update({
        gold: p.gold,
        stats: p.stats,
        // We serialize inventory/equipment to ensure syncing
        // (Simplified for performance: assumes other clients generate same item IDs or just view names)
        // If your items are complex, you might need a deeper sync strategy, 
        // but for Stats/Gold (most skills), this is sufficient.
        activeSkillId: p.activeSkillId,
        passiveSkillId: p.passiveSkillId
    });
}

// NEW HELPER: Headless Combat for AI (No UI)
function resolveAiCombat(p, stat, tn, req, t, mode, rewardVal, failCost) {
    let poolSize = p.stats[stat] || 1;
    let wins = 0;
    
    for(let i=0; i<poolSize; i++) {
        if(Math.floor(Math.random()*6)+1 >= tn) wins++;
    }
    
    if(wins >= req) {
        addLog(`${p.name} Succeeded! (${wins} wins)`, "log-success");
        
        // --- AI TELEPORT SYNC ---
        if(mode === 'teleport') {
            const newPos = Math.floor(Math.random() * 40);
            if (isMultiplayer && db && gameId) {
                db.ref(`games/${gameId}/teleportLog`).push({
                    pid: p.id,
                    targetPos: newPos,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
                // Do NOT call endStep(); listener handles animation -> resolveLanding -> endStep
                return;
            } else {
                p.pos = newPos;
                gameState = 'MOVING';
                animateMove(p, 0); // Snap visual
            }
        } 
        // ------------------------
        
        else if(mode === 'capture' || mode === 'upgrade') {
            const lvl = (mode === 'upgrade') ? 2 : 1;
            capture(t, p, lvl, () => checkForBonusLoot(p));
            return; 
        }
    } else {
        addLog(`${p.name} Failed. Paid penalty.`, "log-fail");
        pay(p, failCost);
    }
    
    endStep();
}
function showEncounter(p, i, t, mode, preDeterminedCard = null) {
    const originalMode = mode;
    const m = document.getElementById('card-modal'); 
    const l = document.getElementById('choice-list'); 
    const headerEl = document.getElementById('enc-header');
    
    l.innerHTML = ''; 
    document.getElementById('dice-result').innerHTML = ''; 
    document.getElementById('market-sell-area').style.display = 'none';

    // 1. Draw Card Logic
    let card;
    if (preDeterminedCard) {
        card = preDeterminedCard;
    } else {
        if (mode === 'loot') card = DECK_TREASURE[Math.floor(Math.random() * DECK_TREASURE.length)]; 
        else if (mode === 'mystery_event') card = (isNight ? DECK_SKIRMISH : DECK_ENCOUNTER)[Math.floor(Math.random() * 15)];
        else if (mode.includes('skirmish') || mode === 'upgrade') card = DECK_SKIRMISH[Math.floor(Math.random() * 15)]; 
        else card = DECK_ENCOUNTER[Math.floor(Math.random() * 15)];
    }
    
    if (card.type === 'shop') mode = 'shop'; 
    if (card.type === 'loot') { 
        mode = 'loot'; 
        if(!card.cost && !card.name) card = DECK_TREASURE[Math.floor(Math.random() * DECK_TREASURE.length)]; 
    }
    
    // 2. Header Styling (Crucial for applyCaptureVisuals check)
    let title = card.name; 
    
    // Reset Classes first
    headerEl.className = 'card-header';
    
    if (mode.includes('skirmish') || mode === 'upgrade' || (mode === 'mystery_event' && isNight)) { 
        headerEl.classList.add('skirmish'); 
        title += " (SKIRMISH)"; 
    } 
    else if (mode === 'loot') { 
        headerEl.classList.add('loot'); // This tag prevents auto-close
    } 
    else if (mode === 'shop') { 
        headerEl.classList.add('market'); // This tag prevents auto-close
    }
    
    document.getElementById('enc-title').innerText = title;
    
    let desc = card.desc || "Event occurs."; 
    let opts = [];

    // --- A. LOOT LOGIC ---
    if (mode === 'loot') { 
        desc = `You found: ${card.name} (${card.rarity || 'Common'})`; 
        
        if (p.inventory.length >= 12) {
             opts = [{ 
                 txt: "Inventory Full (Discard)", 
                 act: () => { 
                     addLog("Inventory full. Item discarded.", "log-fail"); 
                     updateHUD(); 
                     closeEnc(); 
                 }
             }];
        } else {
            opts = [{ 
                txt: "Keep", 
                act: () => { 
                    p.inventory.push(createItemInstance(card)); 
                    addLog("Gained " + card.name, "log-success"); 
                    
                    if (card.name === "Pouch of Gold" && p.passiveSkillId === 'alchemist_pas') {
                        addLog("Alchemist: Transmuting extra loot...", "log-epic");
                        updateHUD(); 
                        setTimeout(() => { 
                            drawCardAnim('treasure', () => showEncounter(p, null, null, 'loot')); 
                        }, 500);
                        return; 
                    }
                    if (isMultiplayer) syncPlayerState(); 
                    updateHUD(); 
                    closeEnc(); 
                }
            }]; 
        }
    } 
    // --- B. SHOP LOGIC ---
    else if (mode === 'shop' || (i && i.type === 'start')) { 
        openCustomShop(p, [], "Merchant", () => {
             const isCombatMode = (originalMode === 'wild' || originalMode === 'wild_skirmish');
             if (isCombatMode) drawCardAnim('normal', () => showEncounter(p, i, t, originalMode));
             else closeEnc();
        });
        return; 
    } 
    // --- C. STANDARD LOGIC ---
    else { 
        if (card.choices) { 
            card.choices.forEach(c => { 
                let btnTxt = c.txt; 
                if(c.fail) btnTxt += ` | Fail: -${c.fail}G`; 
                let useMode = (originalMode === 'mystery_event') ? 'teleport' : (originalMode === 'upgrade' ? 'upgrade' : c.mode);
                opts.push({ txt: btnTxt, stat: c.stat, tn: c.tn, req: c.req || 1, mode: useMode, val: c.val || 0, failCost: c.fail || 50 }); 
            }); 

            if (p.passiveSkillId === 'pacifist') {
                opts.push({ txt: "â˜… Flee (Pacifist +30G)", act: () => {
                    p.gold += 30; p.pacifistBuff = true; 
                    addLog("Pacifist Flee: +30G and Stats Boosted!", "log-success");
                    updateHUD(); closeEnc();
                }});
            } else {
                opts.push({ txt: "Leave / Flee", act: closeEnc }); 
            }
        } 
        else if (card.type === 'pay') { 
            opts = [{ txt: `Pay ${card.cost}G`, act: () => { processTax(p, card.cost); closeEnc(); }}]; 
        } 
        
        // Enemy Land
        else if (mode === 'enemy') {
             // ... (This part uses t and i variables, ensure they are passed correctly)
             // Copy existing enemy logic block here if needed, or rely on existing implementation
             // For brevity, assuming standard enemy/siege logic from previous steps works fine
             // Just ensuring the header class was set is the main fix here.
             
             let guards = t.userData.guardCount || 0; 
             let defStat = t.userData.defendingStat || 'str'; 
             let rentCost = (i.cost * ((t.userData.buildingLevel > 1) ? 2 : 1)) + (guards * 20);
             let failCost = (i.cost * 2) + (guards * 10); 
             
             const ownerName = players[t.userData.owner] ? players[t.userData.owner].name : "Unknown";
             desc = `Owned by ${ownerName}. Defending: ${defStat.toUpperCase()}. Guards: ${guards}.`; 
             
             opts = [ 
                { txt: `Pay Rent ${rentCost}G`, act: () => { pay(p, rentCost, players[t.userData.owner]); closeEnc(); } }, 
                { txt: `Siege | Risk: -${failCost}G`, stat: defStat, tn: 3, req: 1, mode: 'capture', penalty: false, failCost: failCost, isSiege: true } 
             ];
             
             // Siege Breaker Check
             if (p.activeSkillId === 'siege_breaker' && !p.classSkillDepleted) {
                 opts.unshift({ txt: "â˜… Siege Breaker", act: () => { /* ... existing siege breaker logic ... */ }});
             }
        }
        else {
            opts = [{ txt: "Continue", act: closeEnc }];
        }
    }
    
    // Render
    const descEl = document.getElementById('enc-desc'); 
    if(descEl) descEl.innerText = desc;
    
    opts.forEach(o => { 
        let b = document.createElement('div'); 
        b.className = 'choice-btn'; 
        b.innerText = o.txt; 
        b.onclick = () => { 
            if (o.act) o.act(b); 
            else rollCombat(p, o.stat, o.tn, o.req, t, o.mode, o.penalty, o.val, o.failCost, o.isSiege); 
        }; 
        l.appendChild(b); 
    }); 
    
    m.classList.add('active');
}
function closeEnc(){document.getElementById('card-modal').classList.remove('active');endStep();}
function closeFlavor() { document.getElementById('flavor-modal').classList.remove('active'); continueFromArrival(); }
function drawCardAnim(type, cb) {
    let deck, texUrl; 
    if(type === 'treasure') { deck = treasureDeck; texUrl = 'https://static.wixstatic.com/media/b16479_03570af932d9445ea8b35d26c915366d~mv2.jpg'; } 
    else if(type === 'skirmish') { deck = skirmishDeck; texUrl = 'https://static.wixstatic.com/media/b16479_cd6258f031004df4962a76830ae296f3~mv2.jpg'; } 
    else { deck = normalDeck; texUrl = 'https://static.wixstatic.com/media/b16479_b3d23c888e524e31a6ba70275de7f665~mv2.jpg'; }
    
    const loader = new THREE.TextureLoader(); 
    const tex = loader.load(texUrl); 
    const whiteMat = new THREE.MeshStandardMaterial({color: 0xffffff}); 
    const mats = [whiteMat, whiteMat, new THREE.MeshStandardMaterial({map: tex}), whiteMat, whiteMat, whiteMat];
    const c = new THREE.Mesh(new THREE.BoxGeometry(7.5, 0.15, 10.5), mats); 
    c.position.copy(deck.position); 
    c.position.y += 2; 
    scene.add(c);
    
    // --- FIX: Ensure Callback Runs Exactly Once ---
    let hasRun = false;
    const finish = () => {
        if(!hasRun) {
            hasRun = true;
            scene.remove(c); 
            if(cb) cb();
        }
    };
    // ----------------------------------------------

    new TWEEN.Tween(c.position).to({x: camera.position.x * 0.8, y: camera.position.y - 20, z: camera.position.z * 0.8}, 600).start();
    new TWEEN.Tween(c.rotation).to({x: Math.PI / 2, y: Math.PI, z: 0}, 600).onComplete(finish).start();
    
    // Safety fallback
    setTimeout(finish, 800);
}

function rollCombat(p, stat, tn, req, t, mode, penalty, rewardVal, failCost, isSiege) {
    const d = document.getElementById('dice-result'); 
    d.innerHTML = ''; 
    
    let poolSize = p.stats[stat] || 1; 
    if (p.isPolymorphed) { poolSize = 1; }
    if (isSiege && p.passiveSkillId === 'ambush_pas') { req = Math.max(0, req - 1); }
    if (penalty) poolSize = Math.floor(poolSize / 2); 
    if (poolSize < 1) poolSize = 1;

    let results = [];
    for(let i=0; i<poolSize; i++) {
        const active = ABILITY_LIBRARY[p.activeSkillId];
        let r = (active && active.onRoll) ? active.onRoll(p) : (Math.floor(Math.random()*6)+1);
        results.push(r);
    }

    const finalizeCombat = (finalResults) => {
        let wins = 0;
        d.innerHTML = ''; 
        
        finalResults.forEach(r => {
            let b = document.createElement('div'); 
            b.className = 'mini-die ' + (r >= tn ? 'win' : 'lose'); 
            b.innerText = r; 
            d.appendChild(b);
            if(r >= tn) { 
                wins++; 
                if (r === 6 && p.passiveSkillId === 'executioner') { wins++; b.style.boxShadow = "0 0 10px #ef4444"; } 
            }
        });

        setTimeout(() => {
            let autoClose = true;
            // Check if this is the local player or host-managed AI
            const isLocalControl = (p.id === myPlayerId) || (p.isAi && myPlayerId === 0);

            if(wins >= req) { 
                addLog(`Success! (${wins} wins)`, "log-success"); 
                if (isLocalControl) AUDIO.playSound('sfx_win');
                
                if (mode === 'capture' || mode === 'upgrade' || isSiege) { 
                    const passive = ABILITY_LIBRARY[p.passiveSkillId]; 
                    if (passive && passive.onCombatVictory) passive.onCombatVictory(p); 
                }
                const lootCallback = () => checkForBonusLoot(p);

                // --- TELEPORT LOGIC ---
                if (mode === 'teleport') {
                    const newPos = Math.floor(Math.random() * 40);
                    if (isMultiplayer && db && gameId) {
                        db.ref(`games/${gameId}/teleportLog`).push({
                            pid: p.id, targetPos: newPos, timestamp: firebase.database.ServerValue.TIMESTAMP
                        });
                        // autoClose is TRUE so modal closes, listener handles movement
                    } else {
                        addLog("The portal opens... Teleporting!", "log-epic");
                        gameState = 'MOVING';
                        p.pos = newPos;
                        animateTeleport(p, tiles[newPos], () => { resolveLanding(p); });
                    }
                }
                // ----------------------
                else if(isSiege) { 
                    let guards = t.userData.guardCount || 0; 
                    if (guards > 0) { 
                        t.userData.guardCount--; addLog(`Guard Defeated!`, "log-success"); 
                    } else { 
                        capture(t, p, 1, lootCallback); 
                        if(isLocalControl) autoClose = false; 
                    } 
                    p.metrics.successfulSieges++;
                } 
                else if(mode === 'capture') { 
                    capture(t, p, 1, lootCallback); 
                    if(rewardVal > 0) { p.gold += rewardVal; } 
                    if(isLocalControl) autoClose = false; 
                }
                else if(mode === 'upgrade') { 
                    capture(t, p, 2, lootCallback); 
                    if(isLocalControl) autoClose = false; 
                }

            } else { 
                if (p.passiveSkillId === 'pacifist') {
                     addLog("Pacifist retreat: +30G.", "log-success");
                     p.gold += 30;
                } else {
                    addLog("Failure!", "log-fail"); 
                    if (isLocalControl) AUDIO.playSound('sfx_fail');
                    if(isSiege) { pay(p, failCost, players[t.userData.owner]); } 
                    else { pay(p, failCost); } 
                }
            }
            
            updateHUD(); 
            if(isMultiplayer) syncPlayerState(); 
            
            if(autoClose) {
                setTimeout(() => {
                    if(!p.isAi) { closeEnc(); } 
                    else { 
                        document.getElementById('card-modal').classList.remove('active'); 
                        if (!isMultiplayer || myPlayerId === 0) endStep();
                    }
                }, 1000);
            }
        }, 600);
    };

    // Gamblers Luck Logic
    const hasOnes = results.includes(1);
    const isLocalControl = (p.id === myPlayerId); 
    if (isLocalControl && hasOnes && !p.isPolymorphed) {
        let skillSource = null; let skillType = '';
        if (ABILITY_LIBRARY[p.activeSkillId].name === "Gambler's Luck" && !p.classSkillDepleted) { skillSource = ABILITY_LIBRARY[p.activeSkillId]; skillType = 'class'; } 
        else { ['head','body','main','off'].forEach(slot => { const it = p.equipment[slot]; if (it && it.ability && it.ability.name === "Gambler's Luck" && !it.isDepleted) { skillSource = it; skillType = 'equip'; } }); }

        if (skillSource) {
            d.innerHTML = '<div style="width:100%; text-align:center; margin-bottom:10px; font-size:0.9rem; color:#aaa;">Rolled: ' + results.join(', ') + '</div>';
            showModal("Combat Roll: " + results.join(', '), "Use Gambler's Luck to reroll 1s?", [
                { txt: "Keep Roll", act: () => { document.getElementById('card-modal').classList.add('active'); finalizeCombat(results); }},
                { txt: "Reroll 1s", act: () => { document.getElementById('card-modal').classList.add('active'); if(skillType === 'class') p.classSkillDepleted = true; else if(skillType === 'equip') skillSource.isDepleted = true; updateHUD(); results = results.map(r => (r === 1 ? Math.floor(Math.random()*6)+1 : r)); addLog("Gambler's Luck: Rerolled 1s!", "log-gold"); finalizeCombat(results); }}
            ]);
            return;
        }
    }
    
    if (isLocalControl) AUDIO.playSound('sfx_roll');
    finalizeCombat(results);
}

function createPlayerMesh(race, charClass, playerColor) {
    const group = new THREE.Group();
    
    // --- 1. CONFIG ---
    const colors = {
        skin: 0xffccaa, 
        hair: 0x3e2723,
        primary: playerColor, 
        secondary: 0x222222,
        gold: 0xffd700
    };
    
    let scale = { x: 1, y: 1, z: 1 };
    
    // Race adjustments
    if (race.id === 'orc') { colors.skin = 0x558b2f; scale = { x: 1.25, y: 1.15, z: 1.25 }; }
    else if (race.id === 'elf') { colors.skin = 0xffe0b2; scale = { x: 0.9, y: 1.2, z: 0.9 }; }
    else if (race.id === 'dwarf') { colors.skin = 0xd7ccc8; scale = { x: 1.4, y: 0.75, z: 1.4 }; }
    else if (race.id === 'gnome') { colors.skin = 0xffccaa; scale = { x: 0.7, y: 0.7, z: 0.7 }; }
    else if (race.id === 'halfling') { colors.skin = 0xffccaa; scale = { x: 0.7, y: 0.7, z: 0.7 }; }
    else if (race.id === 'tiefling') { colors.skin = 0x7b1fa2; scale = { x: 1, y: 1.15, z: 1 }; } 
    else if (race.id === 'dragonborn') { colors.skin = 0xb71c1c; scale = { x: 1.2, y: 1.3, z: 1.2 }; }

    const matSkin = new THREE.MeshStandardMaterial({ color: colors.skin });
    const matClothe = new THREE.MeshStandardMaterial({ color: colors.primary }); 
    const matDark = new THREE.MeshStandardMaterial({ color: colors.secondary });
    const matSteel = new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.7, roughness: 0.3 });
    const matGold = new THREE.MeshStandardMaterial({ color: colors.gold, metalness: 0.8, roughness: 0.2 });

    // --- 2. BODY ---
    // Torso
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5 * scale.x, 0.6 * scale.y, 0.3 * scale.z), matClothe);
    torso.position.y = 0.8 * scale.y;
    torso.castShadow = true;
    group.add(torso);

    // Belt
    const belt = new THREE.Mesh(new THREE.BoxGeometry(0.52 * scale.x, 0.1 * scale.y, 0.32 * scale.z), matDark);
    belt.position.y = 0.55 * scale.y;
    group.add(belt);

    // Head
    let headGeo = (race.id === 'gnome') ? new THREE.IcosahedronGeometry(0.35 * scale.x, 1) : new THREE.DodecahedronGeometry(0.25 * scale.x);
    const head = new THREE.Mesh(headGeo, matSkin);
    head.position.y = 1.25 * scale.y;
    head.castShadow = true;
    group.add(head);

    // Eyes (To indicate direction)
    const eyeGeo = new THREE.SphereGeometry(0.05, 4, 4);
    const matEye = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const eyeL = new THREE.Mesh(eyeGeo, matEye); eyeL.position.set(-0.1, 1.25*scale.y, 0.2*scale.x);
    const eyeR = new THREE.Mesh(eyeGeo, matEye); eyeR.position.set(0.1, 1.25*scale.y, 0.2*scale.x);
    group.add(eyeL, eyeR);

    // Legs
    const legGeo = new THREE.BoxGeometry(0.18 * scale.x, 0.5 * scale.y, 0.2 * scale.z);
    const legL = new THREE.Mesh(legGeo, matDark); legL.position.set(-0.15 * scale.x, 0.25 * scale.y, 0);
    const legR = new THREE.Mesh(legGeo, matDark); legR.position.set(0.15 * scale.x, 0.25 * scale.y, 0);
    group.add(legL, legR);

    // Arms 
    const armGeo = new THREE.BoxGeometry(0.15 * scale.x, 0.5 * scale.y, 0.15 * scale.z);
    const armL = new THREE.Mesh(armGeo, matClothe); armL.position.set(-0.35 * scale.x, 0.8 * scale.y, 0);
    const armR = new THREE.Mesh(armGeo, matClothe); armR.position.set(0.35 * scale.x, 0.8 * scale.y, 0);
    group.add(armL, armR);

    // --- 3. ACCESSORIES ---
    
    // CAPE (For everyone except Rogues who have hoods covering back)
    if (charClass.id !== 'rogue') {
        const capeGeo = new THREE.BoxGeometry(0.5 * scale.x, 0.8 * scale.y, 0.05);
        // Pivot point at top
        capeGeo.translate(0, -0.4 * scale.y, 0); 
        const cape = new THREE.Mesh(capeGeo, matClothe);
        cape.position.set(0, 1.1 * scale.y, -0.17 * scale.z);
        cape.name = "Cape"; // For animation
        group.add(cape);
    } else {
        // Rogues get Backpack
        const pack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.3), new THREE.MeshStandardMaterial({color: 0x3e2723}));
        pack.position.set(0, 0.9 * scale.y, -0.2 * scale.z);
        group.add(pack);
    }

    // --- 4. RACE DETAILS ---
    if (race.id === 'elf' || race.id === 'halfling') {
        const earL = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 4), matSkin);
        earL.rotation.z = 1.5; earL.position.set(-0.25, 1.25 * scale.y, 0);
        const earR = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 4), matSkin);
        earR.rotation.z = -1.5; earR.position.set(0.25, 1.25 * scale.y, 0);
        group.add(earL, earR);
    }
    if (race.id === 'gnome') {
        const hat = new THREE.Mesh(new THREE.ConeGeometry(0.35 * scale.x, 0.8 * scale.y, 16), matClothe);
        hat.position.set(0, 1.7 * scale.y, 0); hat.rotation.x = -0.2;
        group.add(hat);
        const beard = new THREE.Mesh(new THREE.BoxGeometry(0.35 * scale.x, 0.25 * scale.y, 0.1 * scale.z), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
        beard.position.set(0, 1.1 * scale.y, 0.28 * scale.z);
        group.add(beard);
    }
    if (race.id === 'dwarf') {
        const beard = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.15), new THREE.MeshStandardMaterial({color: colors.hair}));
        beard.position.set(0, 1.1 * scale.y, 0.18);
        group.add(beard);
    }
    if (race.id === 'tiefling') {
        const hornL = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.25, 4), matSteel);
        hornL.position.set(-0.15, 1.55 * scale.y, 0); hornL.rotation.z = 0.5;
        const hornR = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.25, 4), matSteel);
        hornR.position.set(0.15, 1.55 * scale.y, 0); hornR.rotation.z = -0.5;
        group.add(hornL, hornR);
    }
    if (race.id === 'dragonborn') {
        const tail = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.8, 8), matSkin);
        tail.position.set(0, 0.4, -0.4); tail.rotation.x = -2;
        group.add(tail);
        const snout = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.15,0.25), matSkin);
        snout.position.set(0, 1.2 * scale.y, 0.2); group.add(snout);
    }

    // --- 5. CLASS GEAR ---
    if (charClass.id === 'wizard' && race.id !== 'gnome') {
        const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.05, 8), matClothe);
        brim.position.y = 1.45 * scale.y;
        const cone = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.6, 8), matClothe);
        cone.position.y = 1.75 * scale.y;
        group.add(brim, cone);
        const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 2.2), new THREE.MeshStandardMaterial({color: 0x5d4037}));
        staff.position.set(0.45 * scale.x, 1.1 * scale.y, 0.3);
        staff.add(new THREE.Mesh(new THREE.DodecahedronGeometry(0.12), new THREE.MeshStandardMaterial({color: 0x00ffff, emissive:0x00aaaa})));
        group.add(staff);
    }
    if (charClass.id === 'fighter' || charClass.id === 'cleric') {
        const sword = new THREE.Group();
        sword.position.set(0.55 * scale.x, 1.0 * scale.y, 0.2); sword.rotation.x = Math.PI/2;
        sword.add(new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.3), matDark));
        if (charClass.id === 'cleric') {
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.25), matSteel);
            head.position.y = 0.3; sword.add(head);
        } else {
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.9, 0.04), matSteel);
            blade.position.y = 0.6; sword.add(blade);
        }
        group.add(sword);
        const shield = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.05), matSteel);
        shield.position.set(-0.45 * scale.x, 1.0 * scale.y, 0.2);
        shield.add(new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.06), matClothe));
        group.add(shield);
    }
    if (charClass.id === 'rogue' && race.id !== 'gnome') {
        const hood = new THREE.Mesh(new THREE.SphereGeometry(0.32 * scale.x, 8, 8, 0, Math.PI * 2, 0, Math.PI * 0.5), matClothe);
        hood.position.y = 1.3 * scale.y; group.add(hood);
        const dag1 = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.4, 4), matSteel);
        dag1.position.set(0.45 * scale.x, 0.9 * scale.y, 0.3); dag1.rotation.x = Math.PI/2;
        group.add(dag1);
    }

    group.position.y = 0; 
    return group;
}

function checkForBonusLoot(p) { 
    // Internal roll (1 in 6 chance)
    const roll = Math.floor(Math.random() * 6) + 1; 
    
    if (roll === 6) { 
        addLog(`${p.name} found something!`, "log-gold"); 
        
        // --- AI LOGIC ---
        if (p.isAi) {
            const card = DECK_TREASURE[Math.floor(Math.random() * DECK_TREASURE.length)];
            p.inventory.push(createItemInstance(card)); 
            addLog(`${p.name} obtained ${card.name}`, "log-success");
            
            if (isMultiplayer && myPlayerId === 0) {
                // Basic Sync for AI
                syncPlayerState(); // Host acts as AI, so syncs AI state
            }
            endStep(); 
            return;
        }

        // --- HUMAN LOGIC ---
        // We use a custom callback for the UI to ensure sync happens on click
        setTimeout(() => { 
            // We pass a callback to showEncounter if we wanted custom logic, 
            // but showEncounter 'loot' mode uses standard logic.
            // Since we updated showEncounter above to include syncPlayerState, this is now safe!
            drawCardAnim('treasure', () => showEncounter(p, null, null, 'loot')); 
        }, 500); 

    } else { 
        endStep(); 
    } 
}

function createGuardMesh() {
    const g = new THREE.Group();
    // Simple low-poly guard
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.5), new THREE.MeshStandardMaterial({color: 0x555555})); // Grey armor
    body.position.y = 0.25;
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshStandardMaterial({color: 0xffccaa}));
    head.position.y = 0.6;
    const helm = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.2, 8), new THREE.MeshStandardMaterial({color: 0x333333}));
    helm.position.y = 0.7;
    const spear = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.8), new THREE.MeshStandardMaterial({color: 0x5d4037}));
    spear.position.set(0.2, 0.4, 0);
    g.add(body, head, helm, spear);
    g.scale.set(0.8, 0.8, 0.8); // Make them smaller than players
    return g;
}

function capture(t, p, lvl, callback) {
    const isUpgrade = (lvl > 1);

    // --- MULTIPLAYER LOGIC ---
    if(isMultiplayer && db && gameId) {
        
        // A. If I am a Human Player capturing (My Turn), I need to choose the stat
        if (p.id === myPlayerId) {
            // Helper to write to DB
            const commitCapture = (stat) => {
                db.ref(`games/${gameId}/board/${t.userData.id}`).set({
                    owner: p.id,
                    level: lvl,
                    guardCount: t.userData.guardCount || 0,
                    defendingStat: stat
                });
                // Optional callback execution (visuals handled by listener)
                if (callback) setTimeout(callback, 1000);
            };

            // If it's a new capture (Level 1), ask for defense
            if (lvl === 1) {
                // We use the existing chooseDefense UI helper
                chooseDefense(t, () => {
                    // When UI closes, it sets t.userData.defendingStat locally
                    // We send that local choice to the DB
                    commitCapture(t.userData.defendingStat);
                });
            } else {
                // If upgrading, keep existing stat
                commitCapture(t.userData.defendingStat || 'str');
            }
            return;
        }

        // B. If I am Host managing an AI capture
        if (myPlayerId === 0 && p.isAi) {
            const s = p.stats; 
            let defStat = 'str';
            if (s.dex >= s.str && s.dex >= s.int) defStat = 'dex'; 
            else if (s.int >= s.str && s.int >= s.dex) defStat = 'int';

            db.ref(`games/${gameId}/board/${t.userData.id}`).set({
                owner: p.id,
                level: lvl,
                guardCount: t.userData.guardCount || 0,
                defendingStat: defStat
            });
            
            if (callback) setTimeout(callback, 1000);
            return;
        }

        // C. If I am a Client watching someone else capture, do nothing.
        // The DB Listener will handle the visuals.
        return; 
    }

    // --- SINGLE PLAYER LOGIC (Preserved) ---
    t.userData.owner = p.id; 
    t.userData.buildingLevel = lvl; 
    applyCaptureVisuals(t, p, lvl);
    
    if (p.id === 0) {
        if (lvl === 1) setTimeout(() => chooseDefense(t, callback), 4000); 
        else if (callback) setTimeout(callback, 4000); 
        else setTimeout(endStep, 4000); 
    } else {
        const s = p.stats; 
        if (s.str >= s.dex && s.str >= s.int) t.userData.defendingStat = 'str'; 
        else if (s.dex >= s.str && s.dex >= s.int) t.userData.defendingStat = 'dex'; 
        else t.userData.defendingStat = 'int';
        
        if (callback) setTimeout(callback, 2000);
        else setTimeout(endStep, 2000);
    }
}

// NEW FUNCTION: Handles the 3D graphics (Called by Capture OR DB Listener)
function applyCaptureVisuals(t, p, lvl) {
    // 1. Remove Old Visuals
    if (t.userData.prop) {
        t.remove(t.userData.prop);
        t.userData.prop = null;
    }
    
    // Clear old guards for this tile
    if (typeof activeGuards !== 'undefined') {
        activeGuards = activeGuards.filter(g => g.tileId !== t.userData.id);
    }

    // --- FIX: Prevent closing Loot/Shop windows during sync ---
    const modal = document.getElementById('card-modal');
    const header = document.getElementById('enc-header');
    
    // Only close the window if it is open AND it is NOT a Loot or Shop window
    // (We assume Loot/Shop have specific classes added in showEncounter)
    if (modal.classList.contains('active')) {
        const isLoot = header.classList.contains('loot');
        const isShop = header.classList.contains('market');
        
        if (!isLoot && !isShop) {
            modal.classList.remove('active');
        }
    }
    // ----------------------------------------------------------

    // 2. Create New Visual Group
    const g = new THREE.Group();
    const buildingMat = new THREE.MeshStandardMaterial({ color: p.color });

    if (lvl === 1) { 
        // Campsite
        const m = new THREE.Mesh(new THREE.ConeGeometry(1, 1.5, 4), buildingMat); 
        m.position.set(0, 0.5, 0); 
        g.add(m); 
    } else { 
        // Tavern
        const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1.5), new THREE.MeshStandardMaterial({ color: 0x5c4033 })); 
        b.position.set(0, 0.5, 0); 
        const r = new THREE.Mesh(new THREE.ConeGeometry(1.5, 1, 4), buildingMat); 
        r.position.set(0, 1.5, 0); r.rotation.y = Math.PI / 4; 
        g.add(b); g.add(r); 
    }

    // 3. Spawn Guards
    const guardCount = t.userData.guardCount || 0;
    if (guardCount > 0 && typeof createGuardMesh === 'function') {
        for(let i=0; i<guardCount; i++) {
            const guardMesh = createGuardMesh();
            const angle = Math.random() * Math.PI * 2;
            const radius = 1.1 + (Math.random() * 0.5); 
            guardMesh.position.set(Math.cos(angle)*radius, 0, Math.sin(angle)*radius);
            g.add(guardMesh);
            activeGuards.push({
                mesh: guardMesh,
                target: { x: guardMesh.position.x, z: guardMesh.position.z }, 
                tileId: t.userData.id
            });
        }
    }
    
    // 4. Animations
    g.position.y = -5; 
    t.add(g); 
    t.userData.prop = g;
    
    new TWEEN.Tween(g.position).to({y: 0}, 4000).easing(TWEEN.Easing.Elastic.Out).start();
    
    // Only log if this wasn't a reload/sync (simple check if we are moving or it's our turn)
    if(p.id === turnIndex || gameState === 'MOVING') {
        addLog(lvl === 1 ? `${p.name} captured land!` : `${p.name} upgraded!`, "log-success");
    }
    updateHUD();
}
function chooseDefense(t, callback) { 
    // This function runs while camera is still zoomed in
    
    const next = () => { 
        if (callback) callback(); 
        else endStep(); // This triggers resetCamera()
    };
    
    showModal("Tactics", "Choose a stat to defend this location.", [ 
        { txt: "Strength (STR)", act: () => { t.userData.defendingStat = 'str'; addLog("Defense set to STR", "log-success"); next(); } }, 
        { txt: "Dexterity (DEX)", act: () => { t.userData.defendingStat = 'dex'; addLog("Defense set to DEX", "log-success"); next(); } }, 
        { txt: "Intelligence (INT)", act: () => { t.userData.defendingStat = 'int'; addLog("Defense set to INT", "log-success"); next(); } } 
    ]); 
}
function pay(p, amount, recipient) {
    let finalAmount = amount; 
    
    if (p.passiveSkillId === 'iron_skin' && finalAmount > 0) { 
        const oldAmt = finalAmount; 
        finalAmount = Math.max(0, finalAmount - 20); 
        addLog(`Iron Skin reduced loss by ${oldAmt - finalAmount}G`, "log-rare"); 
    }
    
    // --- MANA SHIELD CHECK ---
    // If the cost would bankrupt them, and they have Mana Shield and Items, destroy an item instead.
    if (p.passiveSkillId === 'mana_shield' && p.gold < finalAmount && p.inventory.length > 0) {
        p.inventory.shift(); // Remove first item
        addLog("Mana Shield: Item sacrificed to negate debt!", "log-epic");
        return; // Skip payment
    }
    // -------------------------

    p.gold -= finalAmount;
    if (p.gold < 0) { handleDebt(p, Math.abs(p.gold), recipient); } 
    else { 
        if (recipient) recipient.gold += finalAmount; 
        else treasuryGold += finalAmount; 
        if(finalAmount > 0) addLog(`Paid ${finalAmount}G`, "log-fail"); 
        updateHUD(); 
    }
	AUDIO.playSound('sfx_gold');
}
function handleDebt(p, debt, recipient) {
    const ownedTiles = tiles.filter(t => t.userData.owner === p.id);
    
    // --- RESURRECTION CHECK ---
    if (p.passiveSkillId === 'resurrection' && !p.resurrectionUsed && p.gold < 0 && ownedTiles.length === 0) {
        p.gold = 500;
        p.resurrectionUsed = true;
        
        // Permanently reduce stats (Effect applied in next recalc)
        p.stats.str = Math.max(1, p.stats.str - 1);
        p.stats.dex = Math.max(1, p.stats.dex - 1);
        p.stats.int = Math.max(1, p.stats.int - 1);
        
        // We also need to hack the base stats so recalc doesn't overwrite it
        if(p.race) {
            p.race.stats.str = Math.max(1, p.race.stats.str - 1);
            p.race.stats.dex = Math.max(1, p.race.stats.dex - 1);
            p.race.stats.int = Math.max(1, p.race.stats.int - 1);
        }

        addLog(`${p.name} RESURRECTED! (+500G, -1 Perm Stats)`, "log-epic");
        updateHUD();
        return; // Stop elimination
    }
    // -------------------------

    if (p.isAi) {
        while (p.gold < 0 && ownedTiles.length > 0) { const t = ownedTiles.splice(Math.floor(Math.random() * ownedTiles.length), 1)[0]; const val = Math.floor(t.userData.info.cost / 2); sellPropertyLogic(t, p, val); }
        if (p.gold < 0) { eliminatePlayer(p); } else { addLog(`${p.name} sold properties to pay debt.`, "log-fail"); if (recipient && debt > 0) recipient.gold += Math.min(debt, debt + p.gold); updateHUD(); }
    } else { if (ownedTiles.length === 0) { eliminatePlayer(p); } else { showBankruptcyModal(p, debt, recipient, ownedTiles); } }
}
function sellPropertyLogic(t, p, val) { p.gold += val; t.userData.owner = null; t.userData.buildingLevel = 0; t.userData.guardCount = 0; t.userData.defendingStat = null; if (t.userData.prop) { t.remove(t.userData.prop); t.userData.prop = null; } }
function showBankruptcyModal(p, debt, recipient, ownedTiles) {
    const m = document.getElementById('bankruptcy-modal'); const list = document.getElementById('debt-prop-list'); const debtLabel = document.getElementById('debt-amount'); const btn = document.getElementById('btn-debt-done'); m.style.display = 'flex';
    const refreshList = () => {
        debtLabel.innerText = Math.abs(p.gold); list.innerHTML = ''; const currentOwned = tiles.filter(t => t.userData.owner === p.id);
        if (p.gold >= 0) { btn.disabled = false; btn.innerText = "Debt Cleared - Continue"; btn.onclick = () => { m.style.display = 'none'; if(recipient) recipient.gold += debt; else treasuryGold += debt; updateHUD(); }; } else if (currentOwned.length === 0) { btn.disabled = false; btn.innerText = "Accept Fate (Game Over)"; btn.onclick = () => { m.style.display = 'none'; eliminatePlayer(p); }; } else { btn.disabled = true; btn.innerText = `Sell more! (${Math.abs(p.gold)}G needed)`; }
        currentOwned.forEach(t => { const val = Math.floor(t.userData.info.cost / 2); const row = document.createElement('div'); row.className = 'choice-btn'; row.innerHTML = `<span>${t.userData.info.name}</span> <span style="color:var(--gold)">+${val}G</span>`; row.onclick = () => { sellPropertyLogic(t, p, val); refreshList(); updateHUD(); }; list.appendChild(row); });
    }; refreshList();
}
function eliminatePlayer(p) { 
    p.isDead = true; 
    
    // --- RESURRECTION (INHERITANCE) LOGIC ---
    const inheritor = players.find(x => !x.isDead && x.id !== p.id && x.passiveSkillId === 'resurrection');
    if (inheritor && p.gold > 0) {
        const loot = Math.floor(p.gold * 0.5); // Inherit 50%
        inheritor.gold += loot;
        addLog(`${inheritor.name} inherits ${loot}G from ${p.name}.`, "log-epic");
    }
    // -----------------------------------------
    
    p.gold = 0; 
    scene.remove(p.mesh); 
    
    tiles.forEach(t => { 
        if(t.userData.owner === p.id) { 
            t.userData.owner = null; 
            t.userData.buildingLevel = 0; 
            if(t.userData.prop) { t.remove(t.userData.prop); t.userData.prop = null; } 
        } 
    }); 
    
    addLog(`${p.name} has been ELIMINATED!`, "log-fail"); 
    updateHUD(); 
    if (!p.isAi) { showGameOver(false); } else { checkWinCondition(); } 
}
function checkWinCondition() { const livingAi = players.filter(pl => pl.isAi && !pl.isDead); const human = players[0]; if (livingAi.length === 0 && !human.isDead) { showGameOver(true); } }
function showGameOver(victory) { 
    const m = document.getElementById('game-over-modal'); 
    const t = document.getElementById('go-title'); 
    const msg = document.getElementById('go-msg'); 
    const statsDiv = document.getElementById('go-stats');
    const legend = document.getElementById('graph-legend');
    
    m.style.display = 'flex'; 
    
    if(victory) { 
        t.innerText = "VICTORY!"; t.style.color = "var(--gold)"; 
        msg.innerText = "You have defeated all rivals and conquered the realm!"; 
        AUDIO.playSound('sfx_win');
    } else { 
        t.innerText = "DEFEAT"; t.style.color = "var(--accent)"; 
        msg.innerText = "You have lost everything. Your legend ends here."; 
        AUDIO.playSound('sfx_fail');
    } 
    
    // Populate Stats & Legend
    statsDiv.innerHTML = '';
    legend.innerHTML = '';
    
    players.forEach(p => {
        const camps = tiles.filter(tile => tile.userData.owner === p.id && tile.userData.buildingLevel === 1).length;
        const taverns = tiles.filter(tile => tile.userData.owner === p.id && tile.userData.buildingLevel === 2).length;
        
        // Stats Row
        const row = document.createElement('div');
        row.className = 'stat-row';
        row.innerHTML = `
            <span style="color:${p.color}; font-weight:bold;">${p.name}</span>
            <span>ðŸ’°${p.gold} | â›º${camps} | ðŸº${taverns} | âš”ï¸${p.metrics.successfulSieges}</span>
        `;
        statsDiv.appendChild(row);
        
        // Legend Item
        const li = document.createElement('div');
        li.className = 'legend-item';
        li.innerHTML = `<div class="legend-box" style="background:${p.color}"></div> ${p.name}`;
        legend.appendChild(li);
    });
}
function resetGame() {
    // Hide Modals
    document.getElementById('game-over-modal').style.display = 'none';
    document.getElementById('bankruptcy-modal').style.display = 'none';

    // Remove Player Meshes
    players.forEach(p => scene.remove(p.mesh));
    players = [];

    // Reset Board Tiles
    tiles.forEach(t => {
        t.userData.owner = null;
        t.userData.buildingLevel = 0;
        t.userData.guardCount = 0;
        t.userData.defendingStat = null; // Clear defense stat
        if (t.userData.prop) {
            t.remove(t.userData.prop);
            t.userData.prop = null;
        }
    });

    // Reset Global Variables
    turnIndex = 0;
    turnCount = 0;
    isNight = false;
    treasuryGold = 0;
    gameState = 'SETUP';

    // Reset Environment
    const fogColor = 0xcccccc;
    scene.background = new THREE.Color(fogColor);

    // --- FIX: Clear Game Log ---
    const log = document.getElementById('game-log');
    if (log) log.innerHTML = '';
    // ---------------------------

    // Show Character Creation
    document.getElementById('create-screen').style.display = 'flex';
}

// --- REGION 6: UI UPDATES & INTERACTION ---
// SAFE UPDATE FUNCTION (CRASH FIX)

// Add this to your script section
function switchHelpTab(tabId) {
    // 1. Hide all Content Sections
    const sections = document.querySelectorAll('.help-section');
    sections.forEach(s => s.classList.remove('active'));
    
    // 2. Show the Target Section
    const target = document.getElementById(tabId);
    if(target) target.classList.add('active');
    
    // 3. Update Tab Buttons (Visual State)
    const buttons = document.querySelectorAll('.help-tab');
    buttons.forEach(b => {
        b.classList.remove('active');
        // Check data-tab attribute for robust matching
        if(b.getAttribute('data-tab') === tabId) {
            b.classList.add('active');
        }
    });
}

function addLog(m, c) {
    const l = document.getElementById('game-log');
    if (!l) return;
    
    let d = document.createElement('div');
    d.className = 'log-entry ' + (c || '');
    d.innerText = '> ' + m;
    
    // CHANGED: Append to bottom instead of insertBefore
    l.appendChild(d);
    
    // CHANGED: Auto-scroll to the bottom to show new message
    l.scrollTop = l.scrollHeight;
}

// --- NEW HELPER: LONG PRESS TO SELL ---
function setupLongPressSell(element, identifier, source) {
    let pressTimer;

    element.addEventListener('touchstart', (e) => {
        // Start a timer when touch begins
        pressTimer = setTimeout(() => {
            const sellArea = document.getElementById('market-sell-area');
            const modal = document.getElementById('card-modal');
            
            // Only trigger if Modal is Active AND Sell Area is visible (Merchant)
            if (modal.classList.contains('active') && sellArea && sellArea.style.display !== 'none') {
                sellItem(identifier, source);
                if (navigator.vibrate) navigator.vibrate(50); // Little vibration for feedback
            }
        }, 600); // 600ms hold time
		    hideTooltip(); 
    }, { passive: true });

    // Cancel timer if finger moves (scrolling) or lifts up
    const clearTimer = () => clearTimeout(pressTimer);
    element.addEventListener('touchend', clearTimer);
    element.addEventListener('touchmove', clearTimer);
    element.addEventListener('touchcancel', clearTimer);
}

function setupItemInteractions(element, index, source) {
    // 1. Target Local Player
    const p = players.find(pl => pl.id === myPlayerId);
    if (!p) return;

    const item = (source === 'inv') ? p.inventory[index] : p.equipment[index];
    
    // Reset handlers
    element.onclick = null;
    element.oncontextmenu = null;
    element.ondblclick = null;
    element.onmouseenter = null;
    element.onmouseleave = null;
    element.onpointerup = null; 
    element.ontouchstart = null;
    element.ontouchend = null;

    // Hover -> Tooltip
    if (item) {
        element.onmouseenter = () => showTooltip(item);
        element.onmouseleave = hideTooltip;
    }

    // Right Click -> Context Menu
    element.oncontextmenu = (e) => {
        e.preventDefault();
        // Pass myPlayerId context implicitly handled by handleContextOpen logic (updated below)
        if (item) handleContextOpen(e, index, source);
    };

    // Double Click -> Equip/Unequip
    element.ondblclick = (e) => {
        e.preventDefault();
        hideTooltip();
        // Pass myPlayerId instead of 0
        if (source === 'inv' && item) equipItem(myPlayerId, index);
        else if (source === 'equip' && item) unequipItem(index);
    };

    // Single Click (Backup)
    element.onclick = (e) => {
        if(item) showTooltip(item);
    };

    // --- TOUCH LOGIC (Long Press / Double Tap) ---
    let pressTimer;
    let lastTap = 0;

    element.ontouchstart = (e) => {
        pressTimer = setTimeout(() => {
            if (item) {
                handleContextOpen(e, index, source);
                if (navigator.vibrate) navigator.vibrate(50);
            }
        }, 600);
    };

    element.ontouchend = (e) => {
        clearTimeout(pressTimer);
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        
        if (tapLength < 300 && tapLength > 0) {
            e.preventDefault();
            hideTooltip();
            if (source === 'inv' && item) equipItem(myPlayerId, index);
            else if (source === 'equip' && item) unequipItem(index);
            lastTap = 0; 
        } else {
            if (item) showTooltip(item);
            lastTap = currentTime;
        }
    };

    element.ontouchmove = () => clearTimeout(pressTimer);
    element.ontouchcancel = () => clearTimeout(pressTimer);
}

function updateHUD() {
    if(players.length === 0) return;

    // 1. Identify Local Player
    const p = players.find(pl => pl.id === myPlayerId) || players[0];
    
    // 2. Stats
    setT('p1-name', p.name); 
    setT('p1-gold', p.gold); 
    setT('p1-str', p.stats.str); 
    setT('p1-dex', p.stats.dex); 
    setT('p1-int', p.stats.int); 
    setT('treasury-val', treasuryGold);
    
    const elPortrait = document.getElementById('p1-portrait'); 
    if(elPortrait) elPortrait.style.backgroundImage = `url('${p.portrait}')`;
    
    setT('day-night-indicator', isNight ? "â˜¾ NIGHT" : "â˜€ DAY");
    const elDayNight = document.getElementById('day-night-indicator'); 
    if(elDayNight) { elDayNight.style.color = isNight ? "#a855f7" : "#87ceeb"; }
    
    // 3. Turn Banner
    const cur = players[turnIndex]; 
    setT('turn-banner', cur.id === myPlayerId ? "YOUR TURN" : `${cur.name}'S TURN`);
    
    const btnAction = document.getElementById('btn-action');
    if (btnAction) {
        btnAction.disabled = true;
        btnAction.classList.remove('state-end');
        if (cur.id === myPlayerId) {
            if (gameState === 'ROLL') { btnAction.disabled = false; btnAction.innerText = "ROLL"; }
            else if (gameState === 'END') { btnAction.disabled = false; btnAction.classList.add('state-end'); btnAction.innerText = "END TURN"; }
            else if (gameState === 'MOVING') { btnAction.innerText = "MOVING..."; }
            else { btnAction.innerText = "WAIT"; }
        } else { 
            btnAction.innerText = isMultiplayer ? "WAIT" : "AI"; 
        }
    }
    
    // 4. INVENTORY GRID
    const invDiv = document.getElementById('p1-inv'); 
    if(invDiv){ 
        invDiv.innerHTML = ''; 
        for(let i=0; i<12; i++){ 
            let d = document.createElement('div'); 
            d.className = 'inv-slot'; 
            d.dataset.idx = i; 
            d.draggable = true; 
            
            d.ondragstart = (e) => { 
                if(document.getElementById('context-menu').style.display === 'flex') { e.preventDefault(); return; } 
                dragStart(e, i); 
            }; 
            
            const item = p.inventory[i];
            if(item){ 
                d.classList.add('rarity-' + (item.rarity || 'common'));
                if(item.img) {
                    d.style.backgroundImage = `url('${item.img}')`;
                    d.innerText = ""; 
                } else {
                    d.innerText = item.name;
                    d.style.backgroundImage = 'none'; // Clear if no image
                }
            } 

            setupItemInteractions(d, i, 'inv');
            invDiv.appendChild(d); 
        } 
    }
    
    // 5. LEADERBOARD (Unchanged logic)
    const lb = document.getElementById('leader-list'); 
    if(lb){ 
        lb.innerHTML = ''; 
        players.forEach(pl => { 
            let d = document.createElement('div'); 
            let extraClass = '';
            if (pl.isBoss) extraClass = (pl.bossType === 'boss') ? ' boss' : ' merchant';
            else if (pl.isDead) extraClass = ' dead';
            d.className = 'leader-row' + extraClass; 
            let icon = '';
            if (pl.isBoss) icon = (pl.bossType === 'boss') ? '<span class="boss-icon">ðŸ‘¹</span>' : '<span class="boss-icon">ðŸŽ’</span>';
            let nameSpan = document.createElement('span'); 
            nameSpan.className = "leader-name"; 
            nameSpan.style.color = pl.color; 
            if(pl.id === myPlayerId) nameSpan.style.fontWeight = "900";
            nameSpan.innerHTML = icon + pl.name; 
            if(!pl.isDead && !pl.isBoss) { nameSpan.addEventListener('click', function() { openCharDetail(pl.id); }); } 
            let infoSpan = document.createElement('div');
            infoSpan.style.display = 'flex'; infoSpan.style.alignItems = 'center'; infoSpan.style.gap = '8px';
            if (pl.isBoss) {
                if (pl.bossType === 'boss') infoSpan.innerHTML = `<span style="font-size:0.85rem; color:#ef4444; font-weight:bold;">HP: ${pl.hp} / ${pl.maxHp}</span>`;
                else infoSpan.innerHTML = `<span style="font-size:0.8rem; color:#a855f7;">MERCHANT</span>`;
            } else {
                const camps = tiles.filter(t => t.userData.owner === pl.id && t.userData.buildingLevel === 1).length;
                const taverns = tiles.filter(t => t.userData.owner === pl.id && t.userData.buildingLevel === 2).length;
                infoSpan.innerHTML = `<span style="font-size:0.9rem">â›º${camps} ðŸº${taverns}</span><span style="font-weight:bold">${pl.isDead ? "DEAD" : pl.gold + "G"}</span>`;
            }
            d.appendChild(nameSpan); d.appendChild(infoSpan); lb.appendChild(d); 
        });
    }
    
    // 6. SKILL BAR (Class Skill)
    const s0 = document.getElementById('skill-0'); 
    const txt0 = document.getElementById('txt-skill-0'); 
    const actSkill = ABILITY_LIBRARY[p.activeSkillId]; 
    if(actSkill && s0 && txt0) { 
        if(p.classSkillDepleted) { s0.className="skill-slot"; s0.style.opacity="0.5"; txt0.innerText="Recharge"; } 
        else { s0.className="skill-slot filled"; s0.style.opacity="1"; txt0.innerText=actSkill.name; } 
        s0.style.backgroundImage = actSkill.img ? `url('${actSkill.img}')` : 'none';
        s0.onmouseenter = () => showTooltip(p.activeSkillId, true); 
        s0.onmouseleave = hideTooltip; 
    }

    // 7. EQUIPMENT SLOTS (UPDATED FOR PAPER DOLL)
    EQUIP_ORDER.forEach((slotName, i) => { 
        const idx = i + 1; 
        const el = document.getElementById(`skill-${idx}`); 
        const txt = document.getElementById(`txt-skill-${idx}`); 
        const item = p.equipment[slotName]; 
        const dollEl = document.getElementById('slot-'+slotName); 
        
        if(dollEl) { 
            // Reset base classes
            dollEl.className = 'doll-slot'; // CHANGED from 'equip-slot' to 'doll-slot'
            dollEl.style.backgroundImage = 'none';

            if (item) {
                dollEl.classList.add('filled');
                dollEl.classList.add('rarity-' + (item.rarity || 'common'));
                
                if(item.img) {
                    dollEl.style.backgroundImage = `url('${item.img}')`;
                    dollEl.innerText = ""; 
                } else {
                    dollEl.innerText = item.name.substring(0, 4); // Short name fallback
                }
            } else {
                dollEl.innerText = slotName.toUpperCase();
            }
            
            setupItemInteractions(dollEl, slotName, 'equip');
        } 
        
        // Skill Bar Logic
        if(el && txt) { 
            el.style.backgroundImage = 'none'; 
            if (item) {
                // If it has a special ability image, use that, else use item image
                if (item.ability) { 
                    const libSkill = Object.values(ABILITY_LIBRARY).find(s => s.name === item.ability.name); 
                    if(libSkill && libSkill.img) el.style.backgroundImage = `url('${libSkill.img}')`; 
                    else if (item.img) el.style.backgroundImage = `url('${item.img}')`;
                } else if(item.img) {
                    el.style.backgroundImage = `url('${item.img}')`;
                }

                if (item.ability && item.ability.type === 'active') { 
                    if(item.isDepleted) { el.className = "skill-slot"; el.style.opacity="0.5"; txt.innerText = "Recharge"; } 
                    else { el.className = "skill-slot filled"; el.style.opacity="1"; txt.innerText = item.ability.name; } 
                } else { 
                    el.className = "skill-slot"; el.style.opacity="1"; txt.innerText = item.ability ? item.ability.name : item.name; 
                }
                el.onmouseenter = () => showTooltip(item); 
                el.onmouseleave = hideTooltip; 
            } else { 
                el.className = "skill-slot"; el.style.opacity="1"; txt.innerText = "Empty"; 
                el.onmouseenter = null; el.onmouseleave = null; 
            }
        } 
    });
    
    // 8. QUICK SLOTS
    p.quickSlots.forEach((item, i) => { 
        const idx = i + 5; 
        const el = document.getElementById(`skill-${idx}`); 
        const txt = document.getElementById(`txt-skill-${idx}`); 
        if(el && txt) { 
            el.style.backgroundImage = 'none'; 
            if (item && p.inventory.includes(item)) { 
                el.className = "skill-slot consumable"; txt.innerText = item.name; 
                if(item.img) el.style.backgroundImage = `url('${item.img}')`;
                el.onmouseenter = () => showTooltip(item); 
                el.onmouseleave = hideTooltip; 
            } else { 
                p.quickSlots[i] = null; 
                el.className = "skill-slot"; txt.innerText = "Drag Item"; 
                el.onmouseenter = null; el.onmouseleave = null; 
            } 
        } 
    });
    
    // 9. MY STATS WIDGET
    const myTiles = tiles.filter(t => t.userData.owner === myPlayerId);
    const myCamps = myTiles.filter(t => t.userData.buildingLevel === 1).length;
    const myTaverns = myTiles.filter(t => t.userData.buildingLevel === 2).length;
    setT('ms-gold', p.gold); setT('ms-camps', myCamps); setT('ms-taverns', myTaverns);
}

function makeDraggable(elmnt) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    
    // UPDATED: Now looks for .char-header (P1) OR .leader-header (Leaderboard) OR h3 (Mobile fallback)
        const header = elmnt.querySelector('.char-header') || elmnt.querySelector('.leader-header') || elmnt.querySelector('.dm-header') || elmnt.querySelector('h3');
    
    if (header) {
        header.onmousedown = dragMouseDown;
    }

    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        // Get the mouse cursor position at startup:
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        // call a function whenever the cursor moves:
        document.onmousemove = elementDrag;
    }

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        // calculate the new cursor position:
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        
        // set the element's new position:
        elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
        elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
        
        // IMPORTANT: Unset 'right' so the 'left' property takes priority allows movement
        elmnt.style.right = 'auto'; 
    }

    function closeDragElement() {
        // stop moving when mouse button is released:
        document.onmouseup = null;
        document.onmousemove = null;
    }
}
function setT(id,t){ let e=document.getElementById(id); if(e) e.innerText=t; }
function handleContextOpen(e, identifier, source='inv') {
    const p = players.find(pl => pl.id === myPlayerId);
    if (!p) return;

    let item = (source === 'equip') ? p.equipment[identifier] : p.inventory[identifier]; 
    if (!item) return; 
    
    const menu = document.getElementById('context-menu'); 
    menu.style.pointerEvents = 'auto'; 
    menu.innerHTML = ''; 
    
    const sellPrice = Math.floor((item.cost || 0) / 2);

    const createItem = (text, onClick, disabled=false) => { 
        const div = document.createElement('div'); 
        div.className = 'ctx-item' + (disabled ? ' disabled' : ''); 
        div.innerText = text; 
        if(!disabled) { 
            div.onclick = (ev) => { ev.stopPropagation(); onClick(); closeCtx(); }; 
        } 
        menu.appendChild(div); 
    };

    if (source === 'equip') createItem('Unequip Item', () => unequipItem(identifier)); 
    // Pass myPlayerId to equipItem
    else createItem(item.type === 'scroll' ? 'Use Scroll' : 'Equip Item', () => equipItem(myPlayerId, identifier));
    
    createItem(`Sell (${sellPrice}G)`, () => sellItem(identifier, source), false); 
    createItem('Cancel', () => {});
    
    let x = e.touches ? e.touches[0].clientX : e.clientX; 
    let y = e.touches ? e.touches[0].clientY : e.clientY; 
    if (x + 150 > window.innerWidth) x = window.innerWidth - 160; 
    if (y + 150 > window.innerHeight) y = window.innerHeight - 160; 
    menu.style.left = x + 'px'; 
    menu.style.top = y + 'px'; 
    menu.style.display = 'flex';
}
function closeCtx() { document.getElementById('context-menu').style.display = 'none'; }
function togglePanel(id) { const panel = document.getElementById(id); if(!panel) return; panel.classList.toggle('minimized'); const btn = panel.querySelector('.minimize-btn'); if(btn) btn.innerText = panel.classList.contains('minimized') ? "+" : "-"; }
function toggleCreatorPortrait() { const el = document.getElementById('creator-portrait-frame'); const btn = document.getElementById('btn-min-portrait'); if(!el || !btn) return; el.classList.toggle('minimized'); btn.innerText = el.classList.contains('minimized') ? "+" : "-"; }
function showModal(t, d, o) { 
    const m = document.getElementById('card-modal'); 
    
    // Set Title
    setT('enc-title', t); 
    
    // FIX: Use 'enc-desc' to match your HTML, not 'card-desc'
    setT('enc-desc', d); 
    
    // Ensure header is styled generally (not red/green/brown)
    document.getElementById('enc-header').className = 'card-header';

    const l = document.getElementById('choice-list'); 
    l.innerHTML = ''; 
    document.getElementById('dice-result').innerHTML = ''; 
    
    // Hide sell area if visible
    const sell = document.getElementById('market-sell-area');
    if(sell) sell.style.display = 'none';

    o.forEach(x => { 
        let b = document.createElement('div'); 
        b.className = 'choice-btn'; 
        b.innerText = x.txt; 
        b.onclick = () => { 
            // Don't close immediately if action handles it (like paying tax which calls endStep)
            // But usually we close modal to prevent double clicks
            m.classList.remove('active'); 
            x.act(); 
        }; 
        l.appendChild(b); 
    }); 
    
    m.classList.add('active'); 
}
function openCharDetail(id) { 
    // Find player safely
    const p = players.find(pl => pl.id === id); 
    if(!p) return; 

    // --- 1. BUILD HEADER & STATS ---
    let name = p.name;
    let subtitle = "";
    let str=0, dex=0, int=0;
    
    if (p.isBoss) {
        subtitle = (p.bossType === 'boss') ? "Raid Boss" : "Traveling Merchant";
        if(p.bossType === 'boss') {
            str = p.hp; dex = p.maxHp; int = p.stats.str;
        }
    } else {
        subtitle = (p.race ? p.race.name : "Unknown") + " " + (p.class ? p.class.name : "Class");
        str = p.stats.str;
        dex = p.stats.dex;
        int = p.stats.int;
    }
    
    let portraitStyle = p.portrait ? `background-image: url('${p.portrait}');` : `background-color: ${p.color};`;

    // --- 2. BUILD HTML STRUCTURE ---
    const modalBody = document.querySelector('#char-detail-modal .modal-content');
    
    let bodyContainer = document.querySelector('#char-detail-modal .card-body');
    if(!bodyContainer) {
        bodyContainer = document.createElement('div');
        bodyContainer.className = 'card-body';
        modalBody.appendChild(bodyContainer);
    }
    
    bodyContainer.innerHTML = '';
    bodyContainer.style.padding = '0';
    bodyContainer.style.background = 'transparent';

    // A. HEADER
    const headerHtml = `
        <div class="cs-header-bg">
            <div class="cs-portrait" style="${portraitStyle}"></div>
            <div class="cs-info">
                <div class="cs-name">${name}</div>
                <div class="cs-class">${subtitle}</div>
            </div>
            <div class="close-x" onclick="closeCharDetail()">Ã—</div>
        </div>
    `;

    // B. STATS ROW
    let statsHtml = '';
    if (!p.isBoss || p.bossType === 'boss') {
        const lbl1 = p.isBoss ? "HP" : "STR";
        const lbl2 = p.isBoss ? "MAX" : "DEX";
        const lbl3 = p.isBoss ? "ATK" : "INT";
        
        statsHtml = `
            <div class="cs-main-stats">
                <div class="cs-stat-orb"><span class="cs-stat-val" style="color:#ef4444">${str}</span><span class="cs-stat-label">${lbl1}</span></div>
                <div class="cs-stat-orb"><span class="cs-stat-val" style="color:#10b981">${dex}</span><span class="cs-stat-label">${lbl2}</span></div>
                <div class="cs-stat-orb"><span class="cs-stat-val" style="color:#3b82f6">${int}</span><span class="cs-stat-label">${lbl3}</span></div>
            </div>
        `;
    }

    // C. SKILLS
    const act = ABILITY_LIBRARY[p.activeSkillId];
    const pas = ABILITY_LIBRARY[p.passiveSkillId];
    
    const buildSkillRow = (lbl, skill, color) => {
        if(!skill) return '';
        const img = skill.img ? `<img src="${skill.img}" class="cs-skill-icon">` : `<div class="cs-skill-icon" style="background:${color}"></div>`;
        return `
            <div class="cs-skill-row">
                ${img}
                <div class="cs-skill-text">
                    <span class="cs-skill-name" style="color:${color}">${lbl}: ${skill.name}</span>
                    <span class="cs-skill-desc">${skill.desc}</span>
                </div>
            </div>
        `;
    };

    const skillsHtml = `
        <div class="cs-skills">
            ${buildSkillRow('Active', act, '#fbbf24')}
            ${buildSkillRow('Passive', pas, '#a855f7')}
        </div>
    `;

    // D. METRICS
    let metricsHtml = '';
    if (!p.isBoss && !p.isEventEntity) {
        const camps = tiles.filter(t => t.userData.owner === p.id && t.userData.buildingLevel === 1).length;
        const taverns = tiles.filter(t => t.userData.owner === p.id && t.userData.buildingLevel === 2).length;
        const guards = p.metrics.guardsHired || 0;
        const sieges = p.metrics.successfulSieges || 0;
        
        metricsHtml = `
            <div class="cs-metrics">
                <div class="cs-metric-box"><span class="cs-metric-lbl">â›º Camps</span><span class="cs-metric-val">${camps}</span></div>
                <div class="cs-metric-box"><span class="cs-metric-lbl">ðŸº Taverns</span><span class="cs-metric-val">${taverns}</span></div>
                <div class="cs-metric-box"><span class="cs-metric-lbl">ðŸ›¡ï¸ Hired</span><span class="cs-metric-val">${guards}</span></div>
                <div class="cs-metric-box"><span class="cs-metric-lbl">âš”ï¸ Wins</span><span class="cs-metric-val">${sieges}</span></div>
            </div>
        `;
    }

    // E. INVENTORY & PAPER DOLL (Human Only - View Only for others)
    let invHtml = '';
    
    // Updated Paper Doll HTML for Detail View
    invHtml = `
    <div style="padding: 10px; text-align:center;">
        <div class="paper-doll-container" style="transform: scale(0.9); margin: 0 auto;">
            <div id="cd-slot-head" class="doll-slot">HEAD</div>
            <div id="cd-slot-body" class="doll-slot">BODY</div>
            <div id="cd-slot-main" class="doll-slot">MAIN</div>
            <div id="cd-slot-off" class="doll-slot">OFF</div>
        </div>
    </div>
    <div style="padding: 0 20px 20px 20px;">
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:5px; text-transform:uppercase;">Inventory</div>
        <div id="cd-inv-grid-new" class="inv-grid" style="max-height:150px;"></div>
    </div>`;

    // COMBINE
    bodyContainer.innerHTML = headerHtml + statsHtml + skillsHtml + metricsHtml + invHtml;

    // --- 3. POPULATE SLOTS & INVENTORY ---
    // Populate Equip Slots
    ['head','body','main','off'].forEach(slot => {
        const item = p.equipment[slot];
        const el = document.getElementById('cd-slot-' + slot);
        if(el) {
            el.style.backgroundImage = 'none';
            if (item) {
                el.classList.add('filled');
                el.classList.add('rarity-' + (item.rarity || 'common'));
                if(item.img) {
                    el.style.backgroundImage = `url('${item.img}')`;
                    el.innerText = "";
                } else {
                    el.innerText = item.name.substring(0, 4);
                }
                // Only allow interaction if it's ME
                if(p.id === myPlayerId) {
                     // Add click handlers if you want edit capability here
                }
            } else {
                el.innerText = slot.toUpperCase();
            }
        }
    });

    // Populate Inventory
    const grid = document.getElementById('cd-inv-grid-new');
    if(grid) {
        p.inventory.forEach(item => {
            let d = document.createElement('div');
            d.className = 'inv-slot rarity-' + (item.rarity || 'common');
            if(item.img) {
                d.style.backgroundImage = `url('${item.img}')`;
            } else {
                d.innerText = item.name;
            }
            d.onclick = () => showTooltip(item);
            grid.appendChild(d);
        });
        // Fill empty slots
        for(let i=p.inventory.length; i<12; i++) {
            let d = document.createElement('div'); d.className = 'inv-slot'; grid.appendChild(d);
        }
    }

    const modal = document.getElementById('char-detail-modal');
    if(modal) {
        modal.classList.add('active');
        const oldClose = modal.querySelector(':scope > .close-x');
        if(oldClose) oldClose.style.display = 'none';
    }
}
//if(invSection) invSection.style.display = 'block'; if(hiddenMsg) hiddenMsg.style.display = 'none'; ['head','body','main','off'].forEach(slot => { const item = p.equipment[slot]; const el = document.getElementById('cd-slot-'+slot); if(el) { el.innerHTML = item ? item.name : slot.toUpperCase(); el.className = 'equip-slot' + (item ? ' filled' : ''); if(item) { el.onmouseenter = () => showTooltip(item); el.onmouseleave = hideTooltip; } else { el.onmouseenter = null; } } }); const grid = document.getElementById('cd-inv-grid'); if(grid) { grid.innerHTML = ''; p.inventory.forEach(item => { let d = document.createElement('div'); d.className = 'inv-slot'; d.innerText = item.name; d.classList.add('rarity-' + item.rarity); d.onmouseenter = () => showTooltip(item); d.onmouseleave = hideTooltip; grid.appendChild(d); }); for(let i=p.inventory.length; i<12; i++) { let d = document.createElement('div'); d.className = 'inv-slot'; grid.appendChild(d); } } } else { if(invSection) invSection.style.display = 'none'; if(hiddenMsg) hiddenMsg.style.display = 'block'; } const modal = document.getElementById('char-detail-modal'); if(modal) modal.classList.add('active'); }
function closeCharDetail() { document.getElementById('char-detail-modal').classList.remove('active'); hideTooltip(); }
function getRarityColor(r) { if(r==='common')return '#fff'; if(r==='rare')return '#3b82f6'; if(r==='epic')return '#a855f7'; return '#f59e0b'; }
function showTooltip(data, isSkillId = false) { 
    if (!data) return; 
    const tt = document.getElementById('tooltip'); 
    let html = ''; 
    let imgSrc = '';

    if (isSkillId) { 
        const s = ABILITY_LIBRARY[data]; 
        if(!s) return; 
        if(s.img) imgSrc = `<img src="${s.img}" class="tt-icon">`;
        html = `<div class="tt-header" style="display:flex; align-items:center;">${imgSrc}<div><span class="tt-name">${s.name}</span><br><span class="tt-rarity">${s.type || 'Active'}</span></div></div><div class="tt-abil" style="border:none;">${s.desc}</div>`; 
    } else { 
        const col = getRarityColor(data.rarity || 'common'); 
        // Check if item has an ability with an image in the library
        if(data.ability) {
             const libSkill = Object.values(ABILITY_LIBRARY).find(s => s.name === data.ability.name);
             if(libSkill && libSkill.img) imgSrc = `<img src="${libSkill.img}" class="tt-icon">`;
        }
        // Fallback: Check if item NAME matches a skill (e.g. scrolls)
        else if (Object.values(ABILITY_LIBRARY).some(s => s.name === data.name)) {
             const libSkill = Object.values(ABILITY_LIBRARY).find(s => s.name === data.name);
             if(libSkill && libSkill.img) imgSrc = `<img src="${libSkill.img}" class="tt-icon">`;
        }
        
        html = `<div class="tt-header" style="display:flex; align-items:center;">${imgSrc}<div><span class="tt-name" style="color:${col}">${data.name}</span><br><span class="tt-rarity">${data.rarity || 'Common'}</span></div></div>`; 
        if (data.bonus) Object.keys(data.bonus).forEach(k => { html += `<span class="tt-stat">+${data.bonus[k]} ${k.toUpperCase()}</span>`; }); 
        if(data.desc) html += `<span class="tt-stat" style="color:#aaa; font-style:italic; margin-bottom:5px;">${data.desc}</span>`; 
        if(data.ability) html += `<div class="tt-abil">${data.ability.name}: ${data.ability.desc}</div>`; 
    } 
    tt.innerHTML = html; 
    tt.style.display = 'block'; 
}
function hideTooltip() { document.getElementById('tooltip').style.display = 'none'; }
// --- UPDATED TOOLTIP FOLLOWER ---
document.addEventListener('mousemove', (e) => { 
    const tt = document.getElementById('tooltip'); 
    if (tt && tt.style.display === 'block') { 
        const pad = 20; // Increased padding to prevent cursor overlap
        
        let left = e.clientX + pad; 
        let top = e.clientY + pad; 
        
        // Prevent going off right screen edge
        if (left + tt.offsetWidth > window.innerWidth) {
            left = e.clientX - tt.offsetWidth - pad; 
        }
        
        // Prevent going off bottom screen edge
        if (top + tt.offsetHeight > window.innerHeight) {
            top = e.clientY - tt.offsetHeight - pad; 
        }
        
        tt.style.left = left + 'px'; 
        tt.style.top = top + 'px'; 
    } 
});
document.addEventListener('click', (e) => { const menu = document.getElementById('context-menu'); if (menu && !e.target.classList.contains('inv-slot') && !e.target.classList.contains('ctx-item')) menu.style.display = 'none'; });
let lastTouchTime = 0; let lastTouchSlot = "";
function toggleHelpModal() { 
    const m = document.getElementById('help-modal'); 
    if (m.style.display === 'flex') {
        m.style.display = 'none';
    } else {
        m.style.display = 'flex';
        // Reset to first tab when opening
        switchHelpTab('tab-basics');
    }
}

// --- SECRET DEBUG TRIGGER ---
let secretTapCount = 0;
let secretTapTimer = null;

function handleSecretDebugTap() {
    secretTapCount++;
    
    // Clear the timer so it doesn't reset while you are still tapping
    clearTimeout(secretTapTimer);
    
    // Reset count if you stop tapping for more than 1 second
    secretTapTimer = setTimeout(() => {
        secretTapCount = 0;
    }, 1000);

    // If tapped 10 times...
    if (secretTapCount >= 10) {
        secretTapCount = 0; // Reset
        
        // 1. Close Settings to clear the screen
        toggleSettingsModal();
        
        // 2. Open Debug Console
        const consoleDiv = document.getElementById('debug-console');
        const input = document.getElementById('console-input');
        
        consoleDiv.style.display = 'block';
        input.value = '';
        input.focus(); // Pops up keyboard on mobile
        
        // 3. Play sound confirmation
        if(typeof AUDIO !== 'undefined') AUDIO.playSound('sfx_gold');
        
        addLog("Debug Console Accessed.", "log-rare");
    }
}

function toggleSettingsModal() { 
    const m = document.getElementById('settings-modal'); 
    // Toggle between Flex and None
    m.style.display = (m.style.display === 'flex') ? 'none' : 'flex'; 
}
function toggleUIMode(isForced) {
    if (isForced) {
        document.body.classList.add('force-mobile');
    } else {
        document.body.classList.remove('force-mobile');
    }
    // Recalculate camera because viewport size/logic effectively changed
    updateCamera();
}
function handleEquipTouch(slot) { const currentTime = new Date().getTime(); const tapLength = currentTime - lastTouchTime; if (lastTouchSlot === slot && tapLength < 500 && tapLength > 0) { unequipItem(slot); lastTouchTime = 0; } else { useEquipped(slot); lastTouchTime = currentTime; lastTouchSlot = slot; } }
function allowDrop(ev){ev.preventDefault();}
function dragStart(ev, i){ev.dataTransfer.setData("idx",i);}
function handleSellDrop(ev){ ev.preventDefault(); if(document.getElementById('market-sell-area').style.display!=='none'){const idx=ev.dataTransfer.getData("idx"); if(idx!==null) sellItem(idx); }}
function handleSkillDrop(ev, slotIdx) { ev.preventDefault(); const invIdx = ev.dataTransfer.getData("idx"); const p = players[0]; if (invIdx !== null && p.inventory[invIdx]) { const item = p.inventory[invIdx]; if (item.type === 'scroll' || (item.ability && item.ability.type === 'active')) { p.quickSlots[slotIdx] = item; updateHUD(); } else { addLog("Cannot assign passive item.", "log-fail"); } } }
function setupEquipDragDrop() { ['head', 'body', 'main', 'off'].forEach(slot => { const el = document.getElementById('slot-' + slot); if(el) { el.ondragover = allowDrop; el.ondrop = (e) => handleEquipDrop(e, slot); } }); }
function handleEquipDrop(ev, slotName) { ev.preventDefault(); const invIdx = ev.dataTransfer.getData("idx"); const p = players[0]; if (invIdx !== null && p.inventory[invIdx]) { const item = p.inventory[invIdx]; if(item.slot === slotName) equipItem(0, invIdx); else addLog(`Cannot equip ${item.name} to ${slotName.toUpperCase()}`, "log-fail"); } }
function unequipItem(slot) { 
    const p = players.find(pl => pl.id === myPlayerId);
    if (!p) return;

    if(p.equipment[slot] && p.inventory.length < 12) { 
        const it = p.equipment[slot]; 
        if (it.bonus) p.stats[Object.keys(it.bonus)[0]] -= Object.values(it.bonus)[0]; 
        p.equipment[slot] = null; 
        p.inventory.push(it); 
        
        AUDIO.playSound('sfx_equip');
        updateHUD(); 
        syncPlayerState(); // <--- SYNC
    } 
}

function equipItem(pId, invIdx) { 
    // 1. Find Player
    const p = players.find(pl => pl.id === pId); 
    if (!p) return;
    
    // 2. Validate
    if (invIdx < 0 || invIdx >= p.inventory.length) return;
    const item = p.inventory[invIdx]; 
    if (!item) return;

    // 3. Logic
    if (item.type === 'scroll') { 
        if (typeof item.fn === 'function') item.fn(p); 
        else addLog("Scroll fizzled.", "log-fail");
        p.inventory.splice(invIdx, 1); 
    } 
    else { 
        const slot = item.slot; 
        const cur = p.equipment[slot]; 
        
        if(cur){
            if(cur.bonus) p.stats[Object.keys(cur.bonus)[0]] -= Object.values(cur.bonus)[0];
            p.inventory[invIdx] = cur;
        } else {
            p.inventory.splice(invIdx, 1);
        } 
        
        p.equipment[slot] = item; 
        
        if(item.bonus) p.stats[Object.keys(item.bonus)[0]] += Object.values(item.bonus)[0];
        
        if(p.id === 0) AUDIO.playSound('sfx_equip');
    } 
    
    // 4. --- FIX: MULTIPLAYER SYNC ---
    if (isMultiplayer && db && gameId) {
        // A. If I am equipping my own item
        if (p.id === myPlayerId) {
            syncPlayerState();
        }
        // B. If I am Host and I just equipped an item for an AI
        else if (myPlayerId === 0 && p.isAi) {
            // Write the new stats/inventory/equip to DB so clients see it
            // Note: We need to serialize equipment because it might contain functions
            // simplified sync for brevity, focusing on Stats/Gold which are critical for combat calc
            // For full equipment visual sync, clients need the equipment list
            
            // Serialize Equipment for DB
            const cleanEquip = {};
            ['head','body','main','off'].forEach(s => {
                if(p.equipment[s]) cleanEquip[s] = serializeItem(p.equipment[s]);
            });

            // Serialize Inventory
            const cleanInv = p.inventory.map(i => serializeItem(i));

            db.ref(`games/${gameId}/players/${p.id}`).update({
                stats: p.stats,
                gold: p.gold,
                equipment: cleanEquip,
                inventory: cleanInv
            });
        }
    }

    updateHUD(); 
}
function equipItem(pId, invIdx) { 
    // 1. Find Player by ID
    const p = players.find(pl => pl.id === pId); 
    
    if (!p) {
        console.warn(`equipItem: Player ID ${pId} not found.`);
        return;
    }
    
    // 2. Validate Inventory Index
    if (invIdx < 0 || invIdx >= p.inventory.length) {
        return;
    }

    const item = p.inventory[invIdx]; 
    
    // 3. CRITICAL SAFETY CHECK
    // If the item slot is empty/null/undefined, do not proceed.
    if (!item) {
        console.warn(`equipItem: Found null item at index ${invIdx} for ${p.name}. Skipping.`);
        // Optional: Clean inventory here if you have the helper function
        // cleanInventory(p); 
        return;
    }

    // 4. Logic
    // Now it is safe to check .type because we know item is not null
    if (item.type === 'scroll') { 
        // Scroll Logic
        if (typeof item.fn === 'function') {
            item.fn(p); 
        } else {
            addLog("Scroll fizzled.", "log-fail");
        }
        // Remove scroll
        p.inventory.splice(invIdx, 1); 
    } 
    else { 
        // Equipment Logic
        const slot = item.slot; 
        const cur = p.equipment[slot]; 
        
        if(cur){
            // Remove stats from current item
            if(cur.bonus) {
                const k = Object.keys(cur.bonus)[0];
                p.stats[k] -= Object.values(cur.bonus)[0];
            }
            // Swap: Put current back in inventory at specific index
            p.inventory[invIdx] = cur;
        } else {
            // Remove from inventory
            p.inventory.splice(invIdx, 1);
        } 
        
        // Equip new item
        p.equipment[slot] = item; 
        
        // Add stats from new item
        if(item.bonus) {
            const k = Object.keys(item.bonus)[0];
            p.stats[k] += Object.values(item.bonus)[0];
        }
        
        if(p.id === 0) AUDIO.playSound('sfx_equip');
    } 
    
    updateHUD(); 
}
function useEquipped(slot) { 
    // 1. Target Local Player
    const p = players.find(pl => pl.id === myPlayerId);
    if (!p) return;

    if (turnIndex !== myPlayerId) {
        addLog("Not your turn!", "log-fail");
        return;
    }

    const it = p.equipment[slot]; 
    if (it && it.ability && it.ability.type === 'active') { 
        if (!it.isDepleted) { 
            const success = it.ability.fn(p); 
            if (success === true) {
                it.isDepleted = true; 
                updateHUD(); 
                syncPlayerState(); // <--- SYNC CHANGE
            }
        } else { 
            addLog("Ability depleted! Pass Start to recharge.", "log-fail"); 
        } 
    } 
}

function useSkill(slotIndex) { 
    // Safety Check
    if (players.length === 0) return;

    // 1. Target the Local Player (You), not Player 0
    const p = players.find(pl => pl.id === myPlayerId);
    if (!p) return;

    // 2. Check Turn (Must match YOUR ID)
    if (turnIndex !== myPlayerId) { 
        addLog("Not your turn!", "log-fail"); 
        return; 
    } 
    
    // Class Skill (Slot 1)
    if(slotIndex === 0) { 
        if(p.classSkillDepleted) { 
            addLog("Skill depleted! Visit Inn to recharge.", "log-fail"); 
            return; 
        } 
        const skill = ABILITY_LIBRARY[p.activeSkillId]; 
        if(skill && skill.fn) { 
            const success = skill.fn(p); 
            if (success === true) {
                p.classSkillDepleted = true; 
                updateHUD(); 
                syncPlayerState(); // <--- SYNC CHANGE
            }
        } 
        return; 
    } 
    
    // Equipped Skills (Slots 2-5)
    if(slotIndex >= 1 && slotIndex <= 4) { 
        const equipSlot = EQUIP_ORDER[slotIndex - 1]; 
        const item = p.equipment[equipSlot]; 
        if (item && item.ability && item.ability.type === 'active') { 
            if (!item.isDepleted) { 
                const success = item.ability.fn(p); 
                if (success === true) {
                    item.isDepleted = true; 
                    updateHUD(); 
                    syncPlayerState(); // <--- SYNC CHANGE
                }
            } else { 
                addLog("Ability depleted! Visit Inn to recharge.", "log-fail"); 
            } 
        } else { 
            addLog("Passive or Empty.", "log-fail"); 
        } 
        return; 
    } 
    
    // Quick Slots (Slots 6-7)
    if(slotIndex >= 5) { 
        const qIdx = slotIndex - 5; 
        const item = p.quickSlots[qIdx]; 
        if(item && item.type === 'scroll' && item.fn) { 
            const success = item.fn(p); 
            if (success !== false) {
                const invIdx = p.inventory.indexOf(item); 
                if(invIdx > -1) p.inventory.splice(invIdx, 1); 
                p.quickSlots[qIdx] = null; 
                updateHUD(); 
                syncPlayerState(); // <--- SYNC CHANGE
            }
        } 
    } 
}
function sellItem(identifier, source='inv'){ 
    const p = players.find(pl => pl.id === myPlayerId);
    if (!p) return;

    let item = (source === 'equip') ? p.equipment[identifier] : p.inventory[identifier]; 
    if(item){ 
        let multiplier = 0.5;
        if (p.passiveSkillId === 'fence') multiplier = 0.8;
        if (p.passiveSkillId === 'heal') multiplier = 3.0;

        let v = Math.floor((item.cost || 0) * multiplier); 
        p.gold += v; 
        
        if(source === 'equip') { 
            if(item.bonus) p.stats[Object.keys(item.bonus)[0]] -= Object.values(item.bonus)[0]; 
            p.equipment[identifier] = null; 
        } else { 
            p.inventory.splice(identifier, 1); 
        } 
        
        AUDIO.playSound('sfx_gold');
        
        let msg = `Sold for ${v}G`;
        if (multiplier === 3.0) msg += " (Well Made!)";
        else if (multiplier === 0.8) msg += " (Fence)";
        
        addLog(msg, "log-gold"); 
        updateHUD(); 
        syncPlayerState(); // <--- SYNC
    } 
}
document.addEventListener('keydown', (e) => { if (["1","2","3","4","5","6","7"].includes(e.key)) useSkill(parseInt(e.key) - 1); });

// --- REGION 7: CREATION SCREEN ---
function enterCreation(isMP = false) { 
    isMultiplayer = isMP;
    // 1. Disable Start Music Flag immediately
    AUDIO.allowStartMusic = false;
    
    // 2. Audio Transitions
    AUDIO.stopStartMusic();   // Fade out Intro
    AUDIO.playMusic(false);   // Start Day Music

    // 3. Visual Transition
    const splash = document.getElementById('splash-screen');
    const create = document.getElementById('create-screen');

    // STEP A: Turn on the Create Screen immediately
    // It sits at z-index 200, so it appears BEHIND the Splash Screen (z-index 300)
    create.style.display = 'flex';
    
    // STEP B: Ensure Create Screen is fully opaque so we see it when Splash fades
    // We use a tiny timeout to ensure the browser registers 'display:flex' first
    setTimeout(() => {
        create.style.opacity = '1';
        
        // STEP C: Fade out the Splash Screen
        // This effectively "Crossfades" or reveals the Create Screen underneath
        splash.style.opacity = '0';
    }, 50);

    // STEP D: Cleanup Splash Screen after animation finishes
    setTimeout(() => {
        splash.style.display = 'none';
    }, 1500); // Matches CSS transition time
}

function cleanInventory(p) {
    if (!p || !p.inventory) return;
    // Remove nulls, undefined, or items without a type
    p.inventory = p.inventory.filter(item => item && item.type);
}

function setupCreationUI() {
    const cg=document.getElementById('color-grid'); PLAYER_COLORS.forEach(c=>{let d=document.createElement('div');d.className='color-opt';d.style.backgroundColor=c;d.onclick=()=>{selColor=c;document.querySelectorAll('.color-opt').forEach(e=>e.classList.remove('selected'));d.classList.add('selected');};cg.appendChild(d);});
    const rg=document.getElementById('race-grid'); RACES.forEach(r=>{let d=document.createElement('div');d.className='sel-opt';d.innerHTML=`<b>${r.name}</b><small>S:${r.stats.str} D:${r.stats.dex} I:${r.stats.int}</small>`;d.onclick=()=>{selRace=r;hl(d);up();};rg.appendChild(d);});
    const clg=document.getElementById('class-grid'); CLASSES.forEach(c=>{let d=document.createElement('div');d.className='sel-opt';d.innerHTML=`<b>${c.name}</b>`;d.onclick=()=>{selClass=c;hl(d);showClassOptions(c);up();};clg.appendChild(d);});
}
function showClassOptions(c) {
    document.getElementById('active-section').style.display='flex'; 
    const ag = document.getElementById('active-grid'); ag.innerHTML='';
    c.actives.forEach(id => { 
        const skill = ABILITY_LIBRARY[id]; 
        let d=document.createElement('div'); 
        d.className='skill-card'; 
        // Inject Image if it exists
        d.innerHTML=`<img src="${skill.img || ''}" style="${!skill.img ? 'display:none' : ''}"><b>${skill.name}</b><small>${skill.desc}</small>`; 
        d.onclick=()=>{ selActiveId=id; document.querySelectorAll('#active-grid .skill-card').forEach(e=>e.classList.remove('selected')); d.classList.add('selected'); up(); }; 
        ag.appendChild(d); 
    });
    
    document.getElementById('passive-section').style.display='flex'; 
    const pg = document.getElementById('passive-grid'); pg.innerHTML='';
    c.passives.forEach(id => { 
        const skill = ABILITY_LIBRARY[id]; 
        let d=document.createElement('div'); 
        d.className='skill-card'; 
        // Inject Image if it exists
        d.innerHTML=`<img src="${skill.img || ''}" style="${!skill.img ? 'display:none' : ''}"><b>${skill.name}</b><small>${skill.desc}</small>`; 
        d.onclick=()=>{ selPassiveId=id; document.querySelectorAll('#passive-grid .skill-card').forEach(e=>e.classList.remove('selected')); d.classList.add('selected'); up(); }; 
        pg.appendChild(d); 
    });
}
function hl(el){el.parentElement.childNodes.forEach(c=>c.classList&&c.classList.remove('selected'));el.classList.add('selected');}
function up() { 
    const btn = document.getElementById('btn-start-game');
    const isReady = (selRace && selClass && selActiveId && selPassiveId);
    
    // Enable/Disable button
    btn.disabled = !isReady;
    
    // Toggle Alpha (Opacity)
    btn.style.opacity = isReady ? "1" : "0.5"; 
    btn.style.cursor = isReady ? "pointer" : "not-allowed";

    // Update Portrait if ready
    if(selRace && selClass) { 
        const key = `${selRace.id}_${selClass.id}`; 
        const url = CHAR_PORTRAITS[key]; 
        if(url) { 
            const frame = document.getElementById('creator-portrait-frame'); 
            frame.style.backgroundImage = `url('${url}')`; 
            frame.style.display = 'block'; 
        } 
    } 
}
function startGame() {
    document.getElementById('create-screen').style.display='none';
    const name = document.getElementById('char-name-input').value || "Hero";

    // --- MULTIPLAYER STARTUP ---
    if (isMultiplayer && gameId && db) {
        
        db.ref(`games/${gameId}`).once('value', snap => {
            const g = snap.val();
            if(!g) return;

            if(players.length === 0) {
                gameState = 'ROLL';
                players = []; 

                for(let i=0; i<4; i++) {
                    const slot = g.slots[i];
                    
                    // Defaults
                    let pName = "Empty", pColor = '#333', isBot = false, isDead = true;
                    let pRace = RACES[0], pClass = CLASSES[0], pAct = CLASSES[0].actives[0], pPas = CLASSES[0].passives[0];

                    if(slot && (slot.type === 'human' || slot.type === 'ai')) {
                        isDead = false;
                        pName = slot.name;
                        pColor = slot.color;
                        isBot = (slot.type === 'ai');

                        // LOAD SAVED DATA (Works for both Human and AI now)
                        if (slot.charData) {
                            // Re-map simple objects back to full Const references if needed
                            // But usually storing the object in DB is fine if structure matches
                            pRace = RACES.find(r => r.id === slot.charData.race.id) || slot.charData.race;
                            pClass = CLASSES.find(c => c.id === slot.charData.class.id) || slot.charData.class;
                            pAct = slot.charData.active;
                            pPas = slot.charData.passive;
                        }
                    } 

                    // SPAWN
                    spawnPlayer(i, pName, pRace, pClass, pAct, pPas, isBot, pColor, 0);
                    
                    const justSpawned = players[i];
                    justSpawned.isDead = isDead;
                    if (!isDead && g.players && g.players[i] && g.players[i].gold !== undefined) {
                        justSpawned.gold = g.players[i].gold;
                    }
                }
                
                updateHUD();
                addLog("The Adventure Begins!");
            }

            setupMultiplayerListeners();
        });

    } else {
        // ... (Keep existing Single Player Logic) ...
        // If you need the SP logic here, let me know, otherwise just keep your existing else block
        spawnPlayer(0, name, selRace, selClass, selActiveId, selPassiveId, false, selColor);
        let aiColors = PLAYER_COLORS.filter(c => c !== selColor); 
        let availableNames = [...NPC_NAMES];
        for(let i=1; i<4; i++) { 
            const r = RACES[Math.floor(Math.random()*RACES.length)]; 
            const c = CLASSES[Math.floor(Math.random()*CLASSES.length)]; 
            const aiName = availableNames.splice(Math.floor(Math.random() * availableNames.length), 1)[0]; 
            const aiCol = aiColors.splice(Math.floor(Math.random()*aiColors.length), 1)[0]; 
            spawnPlayer(i, aiName, r, c, c.actives[0], c.passives[0], true, aiCol); 
        }
        gameState='ROLL'; updateHUD(); addLog("Welcome to Questopoly!");
        AUDIO.playMusic(false); 
    }
}

// Remove functions from objects before sending to Firebase
function serializeItem(item) {
    if (!item) return null;
    // Deep clone to avoid modifying the actual game object by ref
    const clean = JSON.parse(JSON.stringify(item));
    
    // Explicitly delete function properties
    delete clean.fn; 
    if (clean.ability) {
        delete clean.ability.fn;
        delete clean.ability.onRoll;
        delete clean.ability.onLanding;
        delete clean.ability.onCapture;
        delete clean.ability.onCombatVictory;
        delete clean.ability.effect;
    }
    return clean;
}

// Restore functions to objects received from Firebase
function hydrateItem(item) {
    if (!item) return null;
    
    // Attempt to find original template to restore logic based on Name
    // We check DECK_TREASURE first as it contains most items
    const original = DECK_TREASURE.find(i => i.name === item.name);
    
    if (original) {
        if (original.fn) item.fn = original.fn;
        if (original.ability) {
             if (!item.ability) item.ability = {};
             // Restore logic properties
             Object.assign(item.ability, original.ability);
             // Ensure function references are copied
             item.ability.fn = original.ability.fn;
        }
    }
    return item;
}

// --- NEW HELPER FUNCTION FOR MP LISTENERS ---
function setupMultiplayerListeners() {
    if(listenersActive) return;
    listenersActive = true;

    console.log("Setting up Host-Authoritative Listeners...");
    const connectionTime = Date.now();

    // ==========================================
    //  SECTION A: HOST LOGIC
    // ==========================================
    if (myPlayerId === 0) {
        db.ref(`games/${gameId}/request`).on('child_added', snap => {
            const req = snap.val();
            const reqKey = snap.key;
            if(!req) return;

            // 1. ROLL
            if (req.type === 'ROLL') {
                const p = players.find(pl => pl.id === req.pid);
                if (p) {
                    let d1 = 0, d2 = 0, total = 0;
                    if (p.isPolymorphed) { d1 = 1; d2 = 0; total = 1; } 
                    else {
                        d1 = Math.floor(Math.random() * 6) + 1;
                        d2 = Math.floor(Math.random() * 6) + 1;
                        total = d1 + d2;
                        if (p.passiveSkillId && ABILITY_LIBRARY[p.passiveSkillId] && ABILITY_LIBRARY[p.passiveSkillId].name === "Shadow Step") total += 1;
                        if (activeEvent && activeEvent.data && activeEvent.data.id === 'weather_blizzard') total = Math.max(1, total - 1);
                    }
                    db.ref(`games/${gameId}/moveHistory`).push({
                        pid: p.id, d1: d1, d2: d2, finalSteps: total, startPos: p.pos,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                }
                db.ref(`games/${gameId}/request/${reqKey}`).remove();
            }

            // 2. TILE_EVENT
            if (req.type === 'TILE_EVENT') {
                const p = players.find(pl => pl.id === req.pid);
                const tile = tiles[req.tileIndex];
                const info = tile.userData.info;
                let eventData = { pid: req.pid, tileIndex: req.tileIndex, timestamp: firebase.database.ServerValue.TIMESTAMP, mode: 'normal' };

                if (info.type === 'goto') eventData.mode = 'goto';
                else if (info.type === 'jail') eventData.mode = 'jail';
                else if (info.type === 'park') eventData.mode = 'park';
                else if (info.type === 'tax') { eventData.mode = 'tax_card'; eventData.card = { cost: 50 }; }
                else if (info.type === 'shop' || info.type === 'start') {
                    eventData.mode = 'shop';
                    const stock = DECK_TREASURE.filter(i => !i.name.includes('Gold'));
                    const shopItems = [];
                    for(let k=0; k<3; k++) shopItems.push(serializeItem(createItemInstance(stock[Math.floor(Math.random()*stock.length)])));
                    eventData.items = shopItems;
                } 
                else if (info.type === 'chest') {
                    eventData.mode = 'loot';
                    eventData.card = serializeItem(createItemInstance(DECK_TREASURE[Math.floor(Math.random() * DECK_TREASURE.length)]));
                }
                else if (info.type === 'mystery') {
                    eventData.mode = 'mystery_event';
                    eventData.card = JSON.parse(JSON.stringify((isNight ? DECK_SKIRMISH : DECK_ENCOUNTER)[Math.floor(Math.random() * 15)]));
                }
                else {
                    const owner = tile.userData.owner;
                    if (owner !== null && owner !== req.pid) { eventData.mode = 'enemy'; eventData.card = JSON.parse(JSON.stringify(DECK_ENCOUNTER[0])); }
                    else { 
                        eventData.mode = (isNight ? 'wild_skirmish' : 'wild'); 
                        eventData.card = JSON.parse(JSON.stringify((isNight ? DECK_SKIRMISH : DECK_ENCOUNTER)[Math.floor(Math.random() * 15)]));
                    }
                }
                db.ref(`games/${gameId}/currentEvent`).set(eventData);
                db.ref(`games/${gameId}/request/${reqKey}`).remove();
            }

            // 3. END_TURN
            if (req.type === 'END_TURN') {
                const prevP = players[turnIndex];
                let nextIndex = turnIndex;
                
                // HOST: Clear Polymorph Flag Here
                if (prevP && prevP.isPolymorphed) {
                    db.ref(`games/${gameId}/players/${prevP.id}`).update({ isPolymorphed: false });
                }

                if (prevP && prevP.extraTurn) {
                    db.ref(`games/${gameId}/players/${prevP.id}/extraTurn`).set(false); 
                } else {
                    nextIndex = (turnIndex + 1) % players.length;
                    let safety = 0;
                    while(players[nextIndex].isDead && safety < 4) { nextIndex = (nextIndex + 1) % players.length; safety++; }
                }

                if (nextIndex === 0 && !prevP.extraTurn) {
                    db.ref(`games/${gameId}/globalEvent`).once('value', snap => {
                        const currentEv = snap.val();
                        if (currentEv) {
                            const newDur = currentEv.turns - 1;
                            if (newDur <= 0) db.ref(`games/${gameId}/globalEvent`).remove(); 
                            else db.ref(`games/${gameId}/globalEvent`).update({ turns: newDur });
                        } else {
                            if (Math.floor(Math.random() * 6) + 1 === 6) {
                                const idx = Math.floor(Math.random() * MAP_EVENTS.length);
                                db.ref(`games/${gameId}/globalEvent`).set({
                                    idx: idx,
                                    turns: MAP_EVENTS[idx].duration,
                                    timestamp: firebase.database.ServerValue.TIMESTAMP
                                });
                            }
                        }
                    });
                }
                db.ref(`games/${gameId}`).update({ turnIndex: nextIndex });
                db.ref(`games/${gameId}/request/${reqKey}`).remove();
            }
        });
    }

    // ==========================================
    //  SECTION B: CLIENT LOGIC
    // ==========================================

    // 1. MOVEMENT
    db.ref(`games/${gameId}/moveHistory`).orderByChild('timestamp').startAt(connectionTime).on('child_added', snap => {
        const move = snap.val();
        if(!move) return;
        const p = players.find(pl => pl.id === move.pid);
        if(p) {
            p.pos = move.startPos;
            if(tiles[p.pos]) p.mesh.position.copy(tiles[p.pos].position);
            addLog(`${p.name} rolled ${move.d1 + move.d2}.`);
            if(p.id === myPlayerId) AUDIO.playSound('sfx_roll');
            gameState = 'MOVING';
            animateMove(p, move.finalSteps);
        }
    });

    // 2. EVENTS
    db.ref(`games/${gameId}/currentEvent`).on('value', snap => {
        const ev = snap.val();
        if (!ev) return;
        if (window.lastEventTimestamp && ev.timestamp <= window.lastEventTimestamp) return;
        window.lastEventTimestamp = ev.timestamp;

        const p = players.find(pl => pl.id === ev.pid);
        if(!p) return;
        const isMe = (p.id === myPlayerId);
        const isMyAi = (p.isAi && myPlayerId === 0);

        if (isMe || isMyAi) {
            const tile = tiles[ev.tileIndex]; const info = tile.userData.info;
            if (ev.items) ev.items = ev.items.map(hydrateItem);
            if (ev.card) ev.card = hydrateItem(ev.card);

            if (p.isAi && myPlayerId === 0) {
                if(ev.mode === 'goto') {
                     if (p.passiveSkillId === 'smoke_bomb') addLog("Skeleton Key Used!", "log-epic");
                     else { p.pos=10; p.mesh.position.copy(tiles[10].position); p.isSkipping=true; db.ref(`games/${gameId}/players/${p.id}`).update({ isSkipping: true }); }
                     endStep();
                }
                else if(ev.mode === 'park') { if(treasuryGold>0){ p.gold+=treasuryGold; treasuryGold=0; updateHUD(); syncPlayerState(); } endStep(); }
                else if(ev.mode === 'jail') { endStep(); }
                else if(ev.mode === 'tax_card') { processTax(p, ev.card ? ev.card.cost : 50); endStep(); }
                else { resolveAiEvent(p, ev.card, tile, ev.mode, ev.items); }
            } 
            else {
                const executeNextStep = () => {
                    document.getElementById('arrival-modal').classList.remove('active'); 
                    if(ev.mode === 'goto') { 
                        if (p.passiveSkillId === 'smoke_bomb') { addLog("Skeleton Key!", "log-epic"); endStep(); }
                        else { 
                            p.pos=10; p.mesh.position.copy(tiles[10].position); addLog("Jailed!", "log-fail"); 
                            p.isSkipping=true; 
                            if(isMultiplayer) db.ref(`games/${gameId}/players/${p.id}`).update({ isSkipping: true, pos: 10 });
                            endStep(); 
                        }
                    }
                    else if(ev.mode === 'jail') { addLog("Just visiting."); endStep(); }
                    else if(ev.mode === 'park') { if(treasuryGold>0){ p.gold+=treasuryGold; addLog(`Won ${treasuryGold}G!`, "log-success"); treasuryGold=0; updateHUD(); if(isMultiplayer) syncPlayerState(); } else addLog("Treasury empty."); endStep(); }
                    else if (ev.mode === 'tax_card') {
                        const cost = ev.card ? ev.card.cost : 50;
                        showModal("Royal Tax", "The King demands " + cost + "G.", [ { txt: `Pay ${cost}G`, act: () => { processTax(p, cost); if(isMultiplayer) syncPlayerState(); endStep(); } } ]);
                    }
                    else if (ev.mode === 'shop') openCustomShop(p, ev.items, info.name, () => endStep()); 
                    else if (ev.mode === 'loot') showEncounter(p, info, tile, 'loot', ev.card); 
                    else showEncounter(p, info, tile, ev.mode, ev.card);
                };
                const m = document.getElementById('arrival-modal');
                const imgEl = document.getElementById('arrival-image');
                const flavorEl = document.getElementById('arrival-flavor');
                const btn = m.querySelector('button.primary');
                const closeBtn = m.querySelector('.close-x');
                if(info.cardImg) { imgEl.src = info.cardImg; imgEl.style.display = 'block'; } 
                else { imgEl.style.display = 'none'; }
                flavorEl.innerText = info.flavor || "You arrive at " + info.name + ".";
                btn.onclick = executeNextStep;
                closeBtn.onclick = executeNextStep;
                m.classList.add('active');
                AUDIO.playSound('sfx_gold');
            }
        }
    });

    // 3. TURN INDEX
    db.ref(`games/${gameId}/turnIndex`).on('value', snap => {
        const idx = snap.val();
        if(idx !== null && idx !== turnIndex) {
            turnIndex = idx;
            const curP = players[turnIndex];
            gameState = 'ROLL'; 
            updateHUD();
            if(curP) {
                if (curP.isSkipping) {
                    addLog(`${curP.name} is stunned/jailed and skips turn.`, "log-fail");
                    if (myPlayerId === 0) {
                        setTimeout(() => {
                            db.ref(`games/${gameId}/players/${curP.id}`).update({ isSkipping: false });
                            db.ref(`games/${gameId}/request`).push({ type: 'END_TURN', pid: curP.id });
                        }, 2000); 
                    }
                    return; 
                }
                zoomToPiece(curP);
                if(curP.id === myPlayerId) { addLog("Your Turn!"); AUDIO.playSound('sfx_transition'); } 
                else { addLog(`${curP.name}'s Turn`); }
                if (curP.isAi && myPlayerId === 0) { setTimeout(() => { db.ref(`games/${gameId}/request`).push({ type: 'ROLL', pid: curP.id }); }, 1500); }
            }
        }
    });

    // 4. PLAYERS SYNC (FIXED ORDER OF OPERATIONS)
    db.ref(`games/${gameId}/players`).on('child_changed', snap => {
        const pData = snap.val();
        const pId = parseInt(snap.key);
        const p = players.find(pl => pl.id === pId);
        
        if(p && pData) {
            if(pData.gold !== undefined) p.gold = pData.gold;
            if(pData.stats !== undefined) p.stats = pData.stats;
            if(pData.extraTurn !== undefined) p.extraTurn = pData.extraTurn;
            if(pData.isSkipping !== undefined) p.isSkipping = pData.isSkipping;
            
            // --- FIX: VISUAL SYNC LOGIC ---
            if(pData.isPolymorphed !== undefined) {
                // If DB says we should be different from what we are...
                if (p.isPolymorphed !== pData.isPolymorphed) {
                    
                    if (pData.isPolymorphed) {
                        // DB says TRUE -> Turn into Sheep
                        // Only do it if we haven't already locally
                        if (!p.isPolymorphed) {
                            makeSheep(p); 
                        }
                    } else {
                        // DB says FALSE -> Cure Sheep
                        // Force cure even if we think we aren't polymorphic (e.g. initial load)
                        // to ensure mesh is correct
                        p.isPolymorphed = true; // Hack to force cureSheep to run
                        cureSheep(p); 
                    }
                    
                    // Update Local State to match DB exactly
                    p.isPolymorphed = pData.isPolymorphed;
                    recalcStats(p); 
                    updateHUD();
                }
            }
        }
    });

    // 5. BOARD SYNC
    const boardHandler = (snap) => {
        const tileId = parseInt(snap.key); const data = snap.val(); const tile = tiles[tileId]; const owner = players.find(p => p.id === data.owner);
        if(tile && owner) {
            tile.userData.owner = owner.id; tile.userData.buildingLevel = data.level; tile.userData.guardCount = data.guardCount || 0; tile.userData.defendingStat = data.defendingStat || 'str';
            if(gameState === 'MOVING') setTimeout(() => applyCaptureVisuals(tile, owner, data.level), 3000); else applyCaptureVisuals(tile, owner, data.level);
        }
    };
    db.ref(`games/${gameId}/board`).on('child_added', boardHandler);
    db.ref(`games/${gameId}/board`).on('child_changed', boardHandler);

    // 6. TELEPORT SYNC
    db.ref(`games/${gameId}/teleportLog`).orderByChild('timestamp').startAt(connectionTime).on('child_added', snap => {
        const data = snap.val();
        if (!data) return;
        const p = players.find(pl => pl.id === data.pid);
        if (p) {
            p.pos = data.targetPos;
            addLog(`${p.name} teleported!`, "log-epic");
            AUDIO.playSound('sfx_transition');
            closeEnc(); 
            gameState = 'MOVING';
            animateTeleport(p, tiles[data.targetPos], () => { resolveLanding(p); });
        }
    });

    // 7. GLOBAL EVENT SYNC
    db.ref(`games/${gameId}/globalEvent`).on('value', snap => {
        const val = snap.val();
        if (val) {
            if (!activeEvent || activeEvent.data.id !== MAP_EVENTS[val.idx].id) forceTriggerEvent(val.idx);
        } else {
            if (activeEvent) {
                if(activeEvent.data.onEnd) activeEvent.data.onEnd();
                if(activeEvent.playerRef) removeEventEntity(activeEvent.playerRef);
                activeEvent = null; removeParticles(); updateHUD();
            }
        }
    });
}
function resolveAiEvent(p, card, t, mode, items) {
    debugLog(`AI ${p.name} resolving event: ${mode}`);

    // 1. SHOPS & START (AI skips shopping)
    if (mode === 'shop') {
        endStep(); 
        return;
    }

    // 2. LOOT (Chest)
    if (mode === 'loot') {
        if (card) {
            p.inventory.push(createItemInstance(card));
            addLog(`${p.name} found ${card.name}.`, "log-success");
            
            if (card.name === "Pouch of Gold" && p.passiveSkillId === 'alchemist_pas') {
                const extra = DECK_TREASURE[Math.floor(Math.random() * DECK_TREASURE.length)];
                p.inventory.push(createItemInstance(extra));
                addLog(`Alchemist Bonus: ${extra.name}!`, "log-epic");
            }
            if (isMultiplayer) syncPlayerState(); 
        }
        endStep();
        return;
    }

    // 3. COMBAT / MYSTERY / SKIRMISH
    if (card && card.choices) {
        // AI Logic: Pick best option based on Stats
        let best = card.choices[0];
        
        if (card.choices[1]) {
            if (activeEvent && activeEvent.data && activeEvent.data.id === 'event_fog') {
                best = card.choices[Math.floor(Math.random() * card.choices.length)];
            } else {
                const stat1 = p.stats[best.stat] || 0;
                const stat2 = p.stats[card.choices[1].stat] || 0;
                // Basic heuristic: higher stat is better, lower TN is better
                const score1 = stat1 - (best.tn * 0.5);
                const score2 = stat2 - (card.choices[1].tn * 0.5);
                if (score2 > score1) best = card.choices[1];
            }
        }

        // Execute "Headless" Combat
        setTimeout(() => {
            const actionStat = best.stat;
            const tn = best.tn;
            const req = best.req || 1;
            const failCost = best.fail || 50;
            
            let resultMode = best.mode;
            if (mode === 'mystery_event' && !resultMode) resultMode = 'teleport';
            if (mode === 'upgrade') resultMode = 'upgrade';
            if (mode === 'enemy') resultMode = 'capture'; 

            resolveAiCombat(p, actionStat, tn, req, t, resultMode, 0, failCost);
        }, 800);
        return;
    }

    // 4. Default
    endStep();
}

function handleBoardUpdate(snap) {
    const tileId = parseInt(snap.key); // Ensure int
    const data = snap.val();
    
    const tile = tiles[tileId];
    const owner = players.find(p => p.id === data.owner);
    
    if(tile && owner) {
        // Update Internal Data immediately
        tile.userData.owner = owner.id;
        tile.userData.buildingLevel = data.level;
        tile.userData.guardCount = data.guardCount || 0;
        tile.userData.defendingStat = data.defendingStat || 'str';

        // DELAY VISUALS if game is moving
        if(gameState === 'MOVING') {
            // Wait 3 seconds (approx move time) before showing tent
            setTimeout(() => {
                applyCaptureVisuals(tile, owner, data.level);
            }, 3000);
        } else {
            applyCaptureVisuals(tile, owner, data.level);
        }
    }
}
function forcePortrait() {
    // Check if the Screen Orientation API is supported
    if (screen.orientation && screen.orientation.lock) {
        // Attempt to lock to portrait-primary
        screen.orientation.lock('portrait-primary').catch(function(error) {
            // Locking failed (common on iOS or if not fullscreen), but the CSS overlay will handle it visually.
            console.log("Orientation lock not supported/allowed: " + error);
        });
    }
}

// Attempt to lock when the game starts
document.getElementById('btn-start-game').addEventListener('click', forcePortrait);

function toggleGraph() {
    const gc = document.getElementById('graph-container');
    if (gc.style.display === 'none' || gc.style.display === '') {
        gc.style.display = 'block';
        setTimeout(drawGraph, 100); 
    } else {
        gc.style.display = 'none';
    }
}

function drawGraph() {
    const canvas = document.getElementById('game-chart');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width; canvas.height = rect.height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const showGold = document.getElementById('chk-gold').checked;
    const showProps = document.getElementById('chk-props').checked;
    const pad = 40; const gw = canvas.width - pad * 2; const gh = canvas.height - pad * 2;
    
    let maxGold = 100; let maxProps = 1; let maxTurns = 1;
    players.forEach(p => {
        if(p.history.length > maxTurns) maxTurns = p.history.length;
        p.history.forEach(h => {
            if(h.gold > maxGold) maxGold = h.gold;
            if(h.props > maxProps) maxProps = h.props;
        });
    });
    
    ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, canvas.height - pad); ctx.lineTo(canvas.width - pad, canvas.height - pad); ctx.stroke();
    
    players.forEach(p => {
        if(showGold) drawLine(ctx, p, 'gold', maxGold, pad, gw, gh, maxTurns, p.color, false);
        if(showProps) drawLine(ctx, p, 'props', maxProps, pad, gw, gh, maxTurns, p.color, true);
    });
}

function drawLine(ctx, p, key, maxVal, pad, gw, gh, maxTurns, color, dashed) {
    if(p.history.length < 2) return;
    ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
    if(dashed) ctx.setLineDash([5, 5]); else ctx.setLineDash([]);
    p.history.forEach((h, i) => {
        const x = pad + (i / (maxTurns - 1)) * gw;
        const y = (canvas.height - pad) - (h[key] / maxVal) * gh;
        if(i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);
}

function togglePanelVisibility(id) {
    const el = document.getElementById(id);
    if (!el) return;
    
    // Check if it is currently hidden
    // We check for 'none' OR if the class 'active' is missing on mobile
    const isHidden = (getComputedStyle(el).display === 'none');
    
    if (isHidden) {
        // OPEN IT
        el.style.display = 'flex'; // Force flex display
        el.classList.add('active'); // For mobile popup styling
        if(typeof AUDIO !== 'undefined') AUDIO.playSound('sfx_click');
    } else {
        // CLOSE IT
        el.style.display = 'none'; // Force hide
        el.classList.remove('active');
        if(typeof AUDIO !== 'undefined') AUDIO.playSound('sfx_click');
    }
}

// --- HELPER: PLAYER PICKER MODAL ---
function showPlayerPicker(title, targets, onPick) {
    const m = document.getElementById('card-modal');
    document.getElementById('enc-title').innerText = title;
    document.getElementById('enc-desc').innerText = "Choose a target:";
    document.getElementById('enc-header').className = 'card-header';
    const l = document.getElementById('choice-list');
    l.innerHTML = '';
    document.getElementById('dice-result').innerHTML = '';
    document.getElementById('market-sell-area').style.display = 'none';

    targets.forEach(t => {
        let b = document.createElement('div');
        b.className = 'choice-btn';
        b.innerText = t.name + (t.isBoss ? " (Boss)" : "");
        b.onclick = () => {
            m.classList.remove('active');
            onPick(t);
        };
        l.appendChild(b);
    });

    // Cancel Button
    let b = document.createElement('div');
    b.className = 'choice-btn';
    b.innerText = "Cancel";
    b.onclick = () => { m.classList.remove('active'); };
    l.appendChild(b);

    m.classList.add('active');
}

// --- HELPER: CREATE SHRINE MESH ---
function createShrineMesh() {
    const g = new THREE.Group();
    const matStone = new THREE.MeshStandardMaterial({ color: 0x888888 });
    const matGlow = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa });

    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.2, 6), matStone);
    base.position.y = 0.1;
    
    const pillar = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), matStone);
    pillar.position.y = 0.8;
    
    const orb = new THREE.Mesh(new THREE.SphereGeometry(0.25), matGlow);
    orb.position.y = 1.6;

    g.add(base, pillar, orb);
    return g;
}

// ==========================================
//   DEBUG CONSOLE LOGIC
// ==========================================

// 1. Listen for Backtick (`)
document.addEventListener('keydown', function(e) {
    if (e.key === '`') {
        const consoleDiv = document.getElementById('debug-console');
        const input = document.getElementById('console-input');
        
        if (consoleDiv.style.display === 'none') {
            consoleDiv.style.display = 'block';
            input.focus();
        } else {
            consoleDiv.style.display = 'none';
        }
        e.preventDefault(); // Prevent typing ` in the box
    }
});

// 2. Handle Console Command
document.getElementById('console-input').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        const val = this.value.trim();
        
        if (val === "Testy") {
            // ENABLE DEBUG
            enableDebugMode();
            this.value = "";
            document.getElementById('debug-console').style.display = 'none';
            const settings = document.getElementById('settings-modal');
            settings.style.display = 'flex';
            AUDIO.playSound('sfx_gold'); 
        } 
        else if (val === "TestyOff") {
            // DISABLE DEBUG
            disableDebugMode();
            this.value = "";
            document.getElementById('debug-console').style.display = 'none';
            AUDIO.playSound('sfx_fail'); // Audio confirmation
        } 
        else {
            // UNKNOWN COMMAND
            this.value = "";
            this.placeholder = "Unknown Command";
            setTimeout(() => this.placeholder = "Type command...", 1000);
        }
    }
});

function enableDebugMode() {
    const debugContainer = document.getElementById('debug-controls');
    const list = document.getElementById('debug-event-list');
    const logOverlay = document.getElementById('debug-log-overlay'); 
    
    // Reveal UI
    debugContainer.style.display = 'block';
    logOverlay.style.display = 'flex'; 
    
    list.innerHTML = ''; 

    // 1. ADMIN TOGGLE BUTTON
    const adminBtn = document.createElement('button');
    adminBtn.className = 'debug-btn';
    adminBtn.innerHTML = `TOGGLE ADMIN MODE <span>(OFF)</span>`;
    adminBtn.style.borderColor = '#ef4444';
    adminBtn.onclick = () => {
        isAdminMode = !isAdminMode;
        adminBtn.innerHTML = `TOGGLE ADMIN MODE <span>(${isAdminMode ? 'ON' : 'OFF'})</span>`;
        adminBtn.style.backgroundColor = isAdminMode ? '#7f1d1d' : '#333';
        
        // Refresh lobby if visible to show/hide delete buttons
        if(document.getElementById('lobby-screen').style.display !== 'none') {
            LOBBY.refreshList();
        }
        
        addLog(`Admin Mode: ${isAdminMode}`);
    };
    list.appendChild(adminBtn);

    // 2. Force End Turn Button
    const fixBtn = document.createElement('button');
    fixBtn.className = 'debug-btn';
    fixBtn.innerHTML = `EMERGENCY: FORCE END TURN <span>FIX</span>`;
    fixBtn.style.borderColor = '#f59e0b';
    fixBtn.onclick = () => {
        debugLog("Force Ending Turn...");
        gameState = 'END'; 
        turnProcessing = false;
        if (activeEvent && activeEvent.mesh) scene.remove(activeEvent.mesh);
        document.getElementById('card-modal').classList.remove('active');
        endTurn();
    };
    list.appendChild(fixBtn);

    // 3. Event Triggers
    MAP_EVENTS.forEach((ev, index) => {
        const btn = document.createElement('button');
        btn.className = 'debug-btn';
        btn.innerHTML = `${ev.name} <span>INPUT</span>`;
        btn.onclick = () => {
            forceTriggerEvent(index);
            toggleSettingsModal(); 
        };
        list.appendChild(btn);
    });
    
    debugLog("Debug Mode Enabled.");
}

function disableDebugMode() {
    // 1. Hide Debug UI elements
    document.getElementById('debug-controls').style.display = 'none';
    document.getElementById('debug-log-overlay').style.display = 'none';
    
    // 2. Close Settings modal if open (to hide the debug controls inside it)
    document.getElementById('settings-modal').style.display = 'none';

    // 3. Reset Admin Mode to False
    isAdminMode = false;

    // 4. Refresh Lobby list to remove red "Delete" buttons if currently in lobby
    if(document.getElementById('lobby-screen').style.display !== 'none') {
        LOBBY.refreshList();
    }

    addLog("Debug Mode Deactivated.", "log-fail");
}

// 3. Logic to Force a Specific Event (Modified triggerRandomEvent)
function forceTriggerEvent(index) {
    // 1. Cleanup existing event
    if(activeEvent) {
        if(activeEvent.data.onEnd) activeEvent.data.onEnd();
        if(activeEvent.playerRef) removeEventEntity(activeEvent.playerRef); // Use removeEventEntity
        activeEvent = null;
        removeParticles(); // Clear weather
    }

    // 2. Validate
    const evData = MAP_EVENTS[index];
    if (!evData) return;

    // 3. Start New Event
    activeEvent = {
        data: evData,
        turnsLeft: evData.duration,
        playerRef: null 
    };

    if(evData.onStart) evData.onStart();

    addLog(`EVENT: ${evData.name}!`, "log-epic");
    addLog(evData.desc, "log-rare");
    AUDIO.playSound('sfx_transition');
    updateHUD();
}

function toggleDebugLog() {
    const overlay = document.getElementById('debug-log-overlay');
    const btn = document.getElementById('btn-min-log');
    
    // Toggle the class
    overlay.classList.toggle('minimized');
    
    // Change Button Icon based on state
    if (overlay.classList.contains('minimized')) {
        btn.innerText = "â–¡"; // Square icon to represent "Maximize"
        // Optional: Scroll log to bottom just in case when minimizing
    } else {
        btn.innerText = "_"; // Underscore to represent "Minimize"
        
        // Auto-scroll to bottom when maximizing so you see latest logs
        const content = document.getElementById('debug-log-content');
        if(content) content.scrollTop = 0; // Since it uses flex-reverse, 0 is bottom
    }
}

function copyDebugLog() {
    const content = document.getElementById('debug-log-content');
    if (!content) return;
    
    // Get text content (preserves newlines usually)
    const text = content.innerText;
    
    navigator.clipboard.writeText(text).then(() => {
        // Visual feedback
        const btn = document.getElementById('btn-copy-log');
        const originalText = btn.innerText;
        btn.innerText = "COPIED!";
        setTimeout(() => {
            btn.innerText = originalText;
        }, 1000);
    }).catch(err => {
        console.error('Failed to copy log:', err);
        alert("Failed to copy log. Check console permissions.");
    });
}

// Start Engine
init();
</script>
</body>
</html>

